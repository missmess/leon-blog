{"data":{"fusejs":{"index":"{\"keys\":[{\"path\":[\"body\"],\"id\":\"body\",\"weight\":1,\"src\":\"body\",\"getFn\":null}],\"records\":[{\"i\":0,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"AI聊天统一后台\\\"\\ncover: aibackstage/cover.jpg\\ncoverAlt: \\\"后台概览\\\"\\ndescription: \\\"AI聊天后台为AI应用提供后台管理功能\\\"\\ndatePublished: \\\"2023-06-16 19:22:38\\\"\\ndateModified: \\\"2023-06-16 19:22:38\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - Antd\\n  - Vite\\n---\\n\\n**AI聊天统一后台**为FastMind和AI女友项目，提供了统一的管理后台。\\n\\n访问地址：http://ai.siyisea.com:8860\\n\\n查看：[FastMind](/fast-mind)\\n\\n查看：[GF's Heart](/g-fs-heart)\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n1. **AI角色管理**\\n\\n    在后台管理FastMind助手或者AI女友角色。\\n\\n1. **会话管理**\\n\\n    管理所有开启过的会话，也可查询对应会话的聊天消息。\\n\\n1. **用户管理**\\n\\n    管理用户增删改查。\\n\\n1. **系统管理**\\n\\n    GPT token管理、收入管理等。\\n\\n### 我的职责\\n\\n1. 页面及功能开发。\\n\\n1. AI女友角色创建时，需要拼接对应的prompt。\\n\\n### 技术实现\\n\\n1. 基于React、Ant-Deign开发。从vite-reactts脚手架启动。\\n\\n  查看：[vite-reactts脚手架](/vite-reactts-starter)\\n\\n1. 富文本使用react-quill。\\n\\n### 截图\\n\\n![创建FastMind助手](./aibackstage/fastmind-create.jpg)\\n![创建FastMind助手](./aibackstage/fastmind-create2.jpg)\\n![创建AI女友](./aibackstage/aigf-edit.jpg)\",\"n\":0.154}}},{\"i\":1,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"GF's Heart\\\"\\ncover: aigf/cover.jpg\\ncoverAlt: \\\"GF's Heart应用\\\"\\ndescription: \\\"这是你的AI女友，陪她聊天吧\\\"\\ndatePublished: \\\"2023-05-11 12:34:01\\\"\\ndateModified: \\\"2023-05-11 12:34:01\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - 大模型\\n  - AI\\n---\\n\\n**GF's Heart**是你身边最真实的AI女友。\\n\\n访问地址：http://47.251.51.76:3838\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n1. **AI大模型**\\n\\n    文字聊天使用gpt提供语言服务，构建prompt让女友按照设定去聊天。\\n\\n2. **保留记忆**\\n\\n    使用langchain构建有记忆的AI。\\n\\n3. **计划性**\\n\\n    利用定时任务和llm，生成后续明日或下一周的计划。\\n\\n4. **发送自己的照片**\\n\\n    利用prompt工程，在需要发送照片的时候，发送自己的照片。照片预先生成。\\n\\n### 我的职责\\n\\n1. 产品UI设计\\n\\n2. 多个女友的prompt调整优化\\n\\n3. 前端页面开发\\n\\n4. flowise插件开发\\n\\n### 技术实现\\n\\n1. 使用CRA创建和开发项目\\n\\n2. i18n提供多语言支持\\n\\n3. 参照[斯坦福某研究论文](https://arxiv.org/pdf/2304.03442v1.pdf)实现记忆和计划\\n\\n4. 使用flowise来图形化构建langchain，并实时测试聊天效果\\n\\n### 截图\\n\\n![首页](./aigf/home.jpg)\\n![登录](./aigf/login.jpg)\\n![注册](./aigf/register.jpg)\\n![聊天](./aigf/chat.jpg)\\n![flowise后台](./aigf/flowise.jpg)\",\"n\":0.147}}},{\"i\":2,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"AutoRollPager\\\"\\ncover: images/arp_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"轮播图控件，支持自定义view、支持无限循环\\\"\\ndatePublished: \\\"2015-12-21 20:08:09\\\"\\ndateModified: \\\"2015-12-21 20:08:09\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - UI组件\\n  - 开源\\n---\\n\\n轮播图控件，支持自定义view、支持无限循环。\\n\\ngithub仓库：https://github.com/missmess/autorollpager\\n\\n---\\n\\nAutoRollViewPager控件可以展示一组轮播图或一组自定义view，可以自动横向滚动，带指示点和标题，支持无限循环模式。\\n\\nAn AutoRollViewPager can be used to display a sort of images or your custom views which can auto roll horizontally. Loop Mode supported.\\n  \\n---\\n\\n### 主要功能介绍\\n\\n* 可以实现view自动轮播，带指示点。\\n* 支持轮播图：可以使用网络图片、本地图片资源、Drawable对象，可以混用。\\n* 支持轮播自定义的view。 \\n* 支持显示轮播view的文字描述。\\n* 支持开关自动轮播。\\n* 支持普通模式和无限循环模式。\\n* 支持轮播view的点击事件\\n* 支持选择自动轮播方向。\\n* 可以自定义轮播时间间隔。\\n* 触摸时停止自动滚动，离开后继续滚动。\\n* 不影响竖向滑动。如ScrollView、ListView。\\n\\n---\\n\\n### 如何添加到项目中\\n\\nAndroid Studio用户，可以很轻松地通过maven仓库引用到本library。只需要在项目的build.gradle中添加该depandencies：\\n  \\n  `\\n    compile 'com.missmess.autorollpager:library:1.0.4'\\n  `\\n\\n---\\n\\n### 如何使用\\n  \\n###### 1、在xml布局中定义，或者代码中 new AutoRollViewPager(context)。\\n  ```xml\\n  <com.missmess.autorollpager.AutoRollImagePager\\n            android:id=\\\"@+id/arp\\\"\\n            android:layout_width=\\\"wrap_content\\\"\\n            android:layout_height=\\\"220dp\\\"/>\\n  ```\\n  \\n###### 2、代码中提供适配器，并显示：\\n  \\n  ```java\\n  AutoRollViewPager arp = (AutoRollViewPager) findViewById(R.id.arp);\\n  arp.setRollAdapter(new MyRollAdapter());\\n  arp.showUp();\\n  ```\\n  \\n###### 3、在activity的onDestory()或fragment的onDestoryView()中关闭AutoRollViewPager。\\n  ```java\\n  @Override\\n    protected void onDestroy() {\\n        super.onDestroy();\\n        arp.tearDown();\\n }\\n  ```\\n---\\n\\n### 示例代码\\n###### 1、使用AutoRollImagePager显示轮播图\\n\\nAutoRollImagePager为AutoRollViewPager专用于轮播图片的一个实现。支持网络图片、本地资源、自定义drawable，以及三者混用的显示。\\n\\n```java\\n        List<Object> images = new ArrayList<>();\\n        titles = new ArrayList<>();\\n\\n        images.add(R.mipmap.pic1);\\n        images.add(R.mipmap.pic2);\\n        images.add(\\\"http://img3.imgtn.bdimg.com/it/u=509912007,3678988032&fm=21&gp=0.jpg\\\");\\n        images.add(createADrawable());\\n\\n        titles.add(\\\"本地图片1\\\");\\n        titles.add(\\\"本地图片2\\\");\\n        titles.add(\\\"网络图片\\\");\\n        titles.add(\\\"Drawable图片\\\");\\n\\n        //设置图片源\\n        arp.setImageLists(images);\\n        //设置描述标题\\n        arp.setTitles(titles);\\n        //自动滚动（默认true）\\n        arp.setAutoRoll(true);\\n        //设置指示点间隔（默认5dp）\\n        arp.setDotInterval(8);\\n        //是否无限循环模式（默认false）\\n        arp.setLoopMode(true);\\n        //设置自动滚动间隔（默认3秒）\\n        arp.setRollInterval(3000);\\n        //设置轮播view点击事件\\n        arp.setOnPageClickListener(new ClickPager());\\n        //设置自动滚动方向\\n        arp.setRollDirection(AutoRollViewPager.DIRECTION_RIGHT);\\n        //完成配置并显示\\n        arp.showUp();\\n\\n```\\n\\n###### 2、使用AutoRollViewPager\\n\\n使用AutoRollViewPager可参考上文中的 `如何使用` 。提供的adapter需要继承于BaseRollAdapter。\\n```java\\n    class MyRollAdapter extends BaseRollAdapter {\\n\\n        public MyRollAdapter(Context context) {\\n            super(context);\\n        }\\n\\n        @Override\\n        public View getView(ViewGroup container, int position) {\\n            View content = null;\\n            switch (position) {\\n                case 0:\\n                    content = View.inflate(context, R.layout.item_roll_view_1, null);\\n                    break;\\n                case 1:\\n                    content = View.inflate(context, R.layout.item_roll_view_2, null);\\n                    break;\\n                case 2:\\n                    content = View.inflate(context, R.layout.item_roll_view_3, null);\\n                    break;\\n                case 3:\\n                    content = View.inflate(context, R.layout.item_roll_view_4, null);\\n                    break;\\n            }\\n\\n            return content;\\n        }\\n\\n        @Override\\n        public int getRealCount() {\\n            return 4;\\n        }\\n    }\\n```\\n\\n---\\n\\n### 截图\\n\\n![image](https://raw.githubusercontent.com/missmess/autorollpager/master/raw/picc1.jpg)\\n![image](https://raw.githubusercontent.com/missmess/autorollpager/master/raw/picc2.png)\\n![image](https://raw.githubusercontent.com/missmess/autorollpager/master/raw/picc3.jpg)\\n![image](https://raw.githubusercontent.com/missmess/autorollpager/master/raw/picc4.jpg)\\n\",\"n\":0.069}}},{\"i\":3,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"Big Test\\\"\\ncover: images/default_img.jpg\\ncoverAlt: \\\"An image tagged as nature and water for the big test.\\\"\\ndescription: \\\"A big test intended for checking the MDX rendering.\\\"\\ndatePublished: \\\"2000-01-01 00:00:00\\\"\\ndateModified: \\\"2000-01-01 00:00:00\\\"\\nslug: \\\"Big_Sample_Test\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 测试\\n---\\n<!-- markdownlint-disable-->\\nNOTE: This \\\"post\\\" is based on [Markdown Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) and is meant to test styling of Markdown generated documents.\\n\\nThis is intended as a quick reference and showcase. For more complete info, see [John Gruber's original spec](http://daringfireball.net/projects/markdown/) and the [Github-flavored Markdown info page](http://github.github.com/github-flavored-markdown/).\\n\\nThis cheatsheet is specifically _Markdown Here's_ version of Github-flavored Markdown. This differs slightly in styling and syntax from what Github uses, so what you see below might vary a little from what you get in a _Markdown Here_ email, but it should be pretty close.\\n\\nYou can play around with Markdown on our [live demo page](http://www.markdown-here.com/livedemo.html).\\n\\n(If you're not a Markdown Here user, check out the [Markdown Cheatsheet](./Markdown-Cheatsheet) that is not specific to MDH. But, really, you should also use Markdown Here, because it's awesome. http://markdown-here.com)\\n\\n## Table of Contents\\n\\n- [Headers](#headers)\\n\\n- [Emphasis](#emphasis)\\n\\n- [Lists](#lists)\\n\\n- [Links](#links)\\n\\n- [Images](#images)\\n\\n- [Code and Syntax Highlighting](#code-and-syntax-highlighting)\\n\\n- [Tables](#tables)\\n\\n- [Blockquotes](#blockquotes)\\n\\n- [Inline HTML](#inline-html)\\n\\n- [Horizontal Rule](#horizontal-rule)\\n\\n- [Line Breaks](#line-breaks)\\n\\n- [YouTube Videos](#you-tube-videos)\\n\\n## Headers\\n\\n```no-highlight\\n# H1\\n## H2\\n### H3\\n#### H4\\n##### H5\\n###### H6\\n\\nAlternatively, for H1 and H2, an underline-ish style:\\n\\nAlt-H1\\n======\\n\\nAlt-H2\\n------\\n```\\n\\n# H1\\n\\n## H2\\n\\n### H3\\n\\n#### H4\\n\\n##### H5\\n\\n###### H6\\n\\nAlternatively, for H1 and H2, an underline-ish style:\\n\\n# Alt-H1\\n\\n## Alt-H2\\n\\n## Emphasis\\n\\n```no-highlight\\nEmphasis, aka italics, with *asterisks* or _underscores_.\\n\\nStrong emphasis, aka bold, with **asterisks** or __underscores__.\\n\\nCombined emphasis with **asterisks and _underscores_**.\\n\\nStrikethrough uses two tildes. ~~Scratch this.~~\\n```\\n\\nEmphasis, aka italics, with _asterisks_ or _underscores_.\\n\\nStrong emphasis, aka bold, with **asterisks** or **underscores**.\\n\\nCombined emphasis with **asterisks and _underscores_**.\\n\\nStrikethrough uses two tildes. ~~Scratch this.~~\\n\\n## Lists\\n\\n```no-highlight\\n1. First ordered list item\\n2. Another item\\n  * Unordered sub-list.\\n1. Actual numbers don't matter, just that it's a number\\n  1. Ordered sub-list\\n4. And another item.\\n\\n   Some text that should be aligned with the above item.\\n\\n* Unordered list can use asterisks\\n- Or minuses\\n+ Or pluses\\n```\\n\\n1. First ordered list item\\n2. Another item\\n\\n   - Unordered sub-list.\\n\\n3. Actual numbers don't matter, just that it's a number\\n\\n   1. Ordered sub-list\\n\\n4. And another item.\\n\\n   Some text that should be aligned with the above item.\\n\\n- Unordered list can use asterisks\\n\\n* Or minuses\\n\\n- Or pluses\\n\\n## Links\\n\\nThere are two ways to create links.\\n\\n```no-highlight\\n[I'm an hash link](#links)\\n\\n[I'm an internal link](/)\\n\\n[I'm an inline-style link](https://www.google.com)\\n\\n[I'm a reference-style link][Arbitrary case-insensitive reference text]\\n\\n[You can use numbers for reference-style link definitions][1]\\n\\nOr leave it empty and use the [link text itself]\\n\\nURLs and URLs in angle brackets will automatically get turned into links.\\nhttp://www.example.com or <http://www.example.com> and sometimes\\nexample.com (but not on Github, for example).\\n\\nSome text to show that the reference links can follow later.\\n\\n[arbitrary case-insensitive reference text]: https://www.mozilla.org\\n[1]: http://slashdot.org\\n[link text itself]: http://www.reddit.com\\n```\\n\\n[I'm an hash link](#links)\\n\\n[I'm an internal link](/)\\n\\n[I'm an inline-style link](https://www.baidu.com)\\n\\n[I'm a reference-style link][arbitrary case-insensitive reference text]\\n\\n[You can use numbers for reference-style link definitions][1]\\n\\nOr leave it empty and use the [link text itself]\\n\\nURLs and URLs in angle brackets will automatically get turned into links.\\nhttp://www.example.com or <http://www.example.com> and sometimes\\nexample.com (but not on Github, for example).\\n\\nSome text to show that the reference links can follow later.\\n\\n[arbitrary case-insensitive reference text]: https://www.mozilla.org\\n[1]: http://slashdot.org\\n[link text itself]: http://www.reddit.com\\n\\n## Images\\n\\n```no-highlight\\nHere's our logo (hover to see the title text):\\n\\nInline-style:\\n![alt text](https://foruda.gitee.com/avatar/1718886307882607881/1208717_missmess_1718886307.png \\\"Logo Title Text 1\\\")\\n\\nReference-style:\\n![alt text][logo]\\n\\n[logo]: https://foruda.gitee.com/avatar/1718886307882607881/1208717_missmess_1718886307.png \\\"Logo Title Text 2\\\"\\n```\\n\\nHere's our logo (hover to see the title text):\\n\\nInline-style:\\n![alt text](https://foruda.gitee.com/avatar/1718886307882607881/1208717_missmess_1718886307.png \\\"Logo Title Text 1\\\")\\n\\nReference-style:\\n![alt text][logo]\\n\\n[logo]: https://foruda.gitee.com/avatar/1718886307882607881/1208717_missmess_1718886307.png \\\"Logo Title Text 2\\\"\\n\\nLocal picture:\\n\\n![local picture](./images/local_test.jpeg)\\n\\nBig picture:\\n\\n![big picture that applies to water or nature](https://pic.rmb.bdstatic.com/bjh/events/8444faff1b3925f854eae33f904e1e2d1222.png@h_1280)\\n\\n## Code and Syntax Highlighting\\n\\nCode blocks are part of the Markdown spec, but syntax highlighting isn't. However, many renderers -- like Github's and _Markdown Here_ -- support syntax highlighting. _Markdown Here_ supports highlighting for dozens of languages (and not-really-languages, like diffs and HTTP headers); to see the complete list, and how to write the language names, see the [highlight.js demo page](http://softwaremaniacs.org/media/soft/highlight/test.html).\\n\\n```no-highlight\\nInline `code` has `back-ticks around` it.\\n```\\n\\nInline `code` has `back-ticks around` it.\\n\\nBlocks of code are either fenced by lines with three back-ticks <code>```</code>, or are indented with four spaces. I recommend only using the fenced code blocks -- they're easier and only they support syntax highlighting.\\n\\n```javascript\\nvar s = \\\"JavaScript syntax highlighting\\\";\\nalert(s);\\n```\\n\\n```python\\ns = \\\"Python syntax highlighting\\\"\\nprint s\\n```\\n\\n```no-highlight\\nNo language indicated, so no syntax highlighting in Markdown Here (varies on Github).\\nBut let's throw in a <b>tag</b>.\\n```\\n\\nAgain, to see what languages are available for highlighting, and how to write those language names, see the [highlight.js demo page](http://softwaremaniacs.org/media/soft/highlight/test.html).\\n\\n## Tables\\n\\nTables aren't part of the core Markdown spec, but they are part of GFM and _Markdown Here_ supports them. They are an easy way of adding tables to your email -- a task that would otherwise require copy-pasting from another application.\\n\\n```no-highlight\\nColons can be used to align columns.\\n\\n| Tables        |      Are      |  Cool |\\n| ------------- | :-----------: | ----: |\\n| col 3 is      | right-aligned | $1600 |\\n| col 2 is      |   centered    |   $12 |\\n| zebra stripes |   are neat    |    $1 |\\n\\nThe outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown.\\n\\n| | Markdown | Less           | Pretty     |     |\\n| | ------------- | --------------- | ---------- |------- |\\n| | *Still*   | `renders` | **nicely** | |\\n| | 1               | 2                 | 3          |          |\\n```\\n\\nColons can be used to align columns.\\n\\n| Tables        |      Are      |  Cool |\\n| ------------- | :-----------: | ----: |\\n| col 3 is      | right-aligned | $1600 |\\n| col 2 is      |   centered    |   $12 |\\n| zebra stripes |   are neat    |    $1 |\\n\\nThe outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown.\\n\\n| Markdown | Less      | Pretty     | Pretty     | Pretty     |\\n| -------- | --------- | ---------- | ---------- | ---------- |\\n| _Still_  | `renders` | **nicely** | **nicely** | **nicely** |\\n| 1        | 2         | 3          | 3          | 3          |\\n\\n## Blockquotes\\n\\n```no-highlight\\n> Blockquotes are very handy in email to emulate reply text.\\n> This line is part of the same quote.\\n\\nQuote break.\\n\\n> This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote.\\n```\\n\\n> Blockquotes are very handy in email to emulate reply text.\\n> This line is part of the same quote.\\n\\nQuote break.\\n\\n> This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can _put_ **Markdown** into a blockquote.\\n\\n## Inline HTML\\n\\nYou can also use raw HTML in your Markdown, and it'll mostly work pretty well.\\n\\n```no-highlight\\n<dl>\\n  <dt>Definition list</dt>\\n  <dd>Is something people use sometimes.</dd>\\n\\n  <dt>Markdown in HTML</dt>\\n  <dd>Does *not* work **very** well. Use HTML <em>tags</em>.</dd>\\n</dl>\\n```\\n\\n<dl>\\n  <dt>Definition list</dt>\\n  <dd>Is something people use sometimes.</dd>\\n\\n  <dt>Markdown in HTML</dt>\\n  <dd>Does *not* work **very** well. Use HTML <em>tags</em>.</dd>\\n</dl>\\n\\n## Horizontal Rule\\n\\n```no-highlight\\nThree or more...\\n\\n---\\n\\nHyphens\\n\\n***\\n\\nAsterisks\\n\\n___\\n\\nUnderscores\\n```\\n\\nThree or more...\\n\\n---\\n\\nHyphens\\n\\n---\\n\\nAsterisks\\n\\n---\\n\\nUnderscores\\n\\n## Line Breaks\\n\\nMy basic recommendation for learning how line breaks work is to experiment and discover -- hit &lt;Enter&gt; once (i.e., insert one newline), then hit it twice (i.e., insert two newlines), see what happens. You'll soon learn to get what you want. \\\"Markdown Toggle\\\" is your friend.\\n\\nHere are some things to try out:\\n\\n```no-highlight\\nHere's a line for us to start with.\\n\\nThis line is separated from the one above by two newlines, so it will be a *separate paragraph*.\\n\\nThis line is also a separate paragraph, but...\\nThis line is only separated by a single newline, so it's a separate line in the *same paragraph*.\\n```\\n\\nHere's a line for us to start with.\\n\\nThis line is separated from the one above by two newlines, so it will be a _separate paragraph_.\\n\\nThis line is also begins a separate paragraph, but...\\nThis line is only separated by a single newline, so it's a separate line in the _same paragraph_.\\n\\n(Technical note: _Markdown Here_ uses GFM line breaks, so there's no need to use MD's two-space line breaks.)\\n\\n## YouTube Videos\\n\\nThey can't be added directly but you can add an image with a link to the video like this:\\n\\n```no-highlight\\n<a href=\\\"http://www.youtube.com/watch?feature=player_embedded&v=8AkLfYOgIrE\\n\\\" target=\\\"_blank\\\"><img src=\\\"http://img.youtube.com/vi/8AkLfYOgIrE/0.jpg\\\"\\nalt=\\\"IMAGE ALT TEXT HERE\\\" width=\\\"240\\\" height=\\\"180\\\" border=\\\"10\\\" /></a>\\n```\\n\\nOr, in pure Markdown, but losing the image sizing and border:\\n\\n```no-highlight\\n[![IMAGE ALT TEXT HERE](http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg)](http://www.youtube.com/watch?v=YOUTUBE_VIDEO_ID_HERE)\\n```\\n\\n`video: [VoiceBot Demo](https://www.youtube.com/watch?v=vRwp--RoJdo)`\\n\",\"n\":0.028}}},{\"i\":4,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"CSS即时通（App+后台）\\\"\\ncover: css-oa/cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"CSS即时通为集团内部通讯和办公app\\\"\\ndatePublished: \\\"2023-10-27 13:44:33\\\"\\ndateModified: \\\"2023-10-27 13:44:33\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - 前端\\n  - Vue2\\n  - Vant\\n  - Hybrid\\n---\\n\\nCSS即时通为集团内部通讯和办公app。\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [员工端App截图](#员工端-app截图)\\n- [管理端App截图](#管理端-app截图)\\n- [管理后台截图](#管理后台截图)\\n\\n### 主要功能\\n\\n1. 实时告警传达到对应组成员，app弹出系统级通知弹窗。\\n\\n2. 查看组织架构通讯录。\\n\\n3. 发起OA流程，自定义流程，领导审批。\\n\\n4. 【后台】管理员工、组织架构、分组\\n\\n5. 【后台】管理通讯录、流程\\n\\n6. 【后台】管理告警模版、告警和收取记录\\n\\n### 我的职责\\n\\n1. 负责App和管理端UI、风格设计\\n\\n2. 负责原生Android App开发\\n\\n3. 负责管理端web项目开发\\n\\n### 技术实现\\n\\n1. 员工APP支持Android，使用Java开发。\\n\\n2. 工作台设计为应用容器，动态可配置。支持原生页面，也支持webview嵌入H5页面。\\n\\n3. 告警部分，使用独立service拉取告警。重难点为任意界面的系统级弹窗，以及service保活。\\n\\n4. 管理端为纯H5套壳APP。使用javascriptInterface通信。\\n\\n### 员工端App截图\\n\\n![](./css-oa/login.jpg)\\n![](./css-oa/workbench.jpg)\\n![](./css-oa/mine.jpg)\\n![](./css-oa/alarm.jpg)\\n![](./css-oa/oa.jpg)\\n![](./css-oa/export.jpg)\\n\\n### 管理端App截图\\n\\n![](./css-oa/workbench2.jpg)\\n![](./css-oa/template.jpg)\\n\\n### 管理后台截图\\n\\n![](./css-oa/login3.jpg)\\n![](./css-oa/workflow.jpg)\",\"n\":0.143}}},{\"i\":5,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"CalendarView\\\"\\ncover: images/calendarview.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"CalendarView是一个用于Android的可任意定制的日历组件\\\"\\ndatePublished: \\\"2016-05-12 19:19:40\\\"\\ndateModified: \\\"2016-05-12 19:19:40\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - UI组件\\n  - 开源\\n---\\n\\ngithub仓库：https://github.com/missmess/CalendarView\\n\\n一个Android日历控件库，包含年历，月历，滚动月历，以及一个实现了年历、月历过渡的控件。它们既可以单独使用，也可以组合使用。\\n主要特点是包含丰富的自定义属性；年历月历可以为某一天添加各种样式的decorator。支持android api 11以上。\\n\\nThanks for [ScrollerCalendar](https://github.com/guanchao/ScrollerCalendar), a material style calendar widget library, contains some widget, you\\ncan be use them alone, also you can use them in combination. For Android api level 11+.\\n\\n---\\n  GIF预览：\\n\\n  ![gif](https://raw.githubusercontent.com/missmess/CalendarView/master/raw/cd.gif)\\n\\n---\\n\\n  * [主要功能简介](#主要功能简介)\\n  * [添加到项目中](#添加到项目中)\\n  * [主要API](#api)\\n\\n---\\n\\n### 主要功能简介\\n\\n* 包含年历，月历。并且每个控件都有全方面的自定义属性。\\n* 为某一天添加自定义文字样式和背景。\\n* 包含滚动月历。支持滑动显示其它月份。\\n* 支持多种监听。\\n* 类似小米日历实现的，月历和周历上滑切换功能。\\n* 支持disable；禁选，单选，多选，范围选择。\\n* 提供一个帮助实现年历到月历的过渡动画的viewgroup。\\n\\n---\\n\\n### 添加到项目中\\n\\nAndroid Studio用户，在项目的build.gradle中添加该dependencies：\\n\\n  `\\n    compile \\\"com.missmess.calendarview:calendarview:2.5.3\\\"\\n  `\\n\\n从2.2.0及以下升级到2.4.0的请注意：\\n1、由于2.4.0增加了控件对多选和范围选择的支持。原来MonthView中跟selection相关的方法有部分已经被删除或者修改。\\n2、同样由于对多选的支持。周历滑动时，由于要保留多选模式下的selections，控件不再默认选中下一周的某一天，这里跟小米日历已经不一样了。其它方面在实现时已经尽量保持一致。\\n\\n---\\n\\n<h3 id='api'>主要API</h3>\\n\\n介绍一下主要的控件和api，更详细的可以下载demo来了解~\\n\\n###### 1、YearView\\n\\n  年历，显示一年的所有日期。YearView提供了16个自定义属性，用于完全定义你想要的布局：\\n```xml\\n    <declare-styleable name=\\\"YearView\\\">\\n        <attr name=\\\"showYearLabel\\\" format=\\\"boolean\\\"/>\\n        <attr name=\\\"showYearLunarLabel\\\" format=\\\"boolean\\\"/>\\n        <attr name=\\\"dividerColor\\\" format=\\\"color\\\"/>\\n        <attr name=\\\"yearHeaderTextColor\\\" format=\\\"color\\\" />\\n        <attr name=\\\"yearHeaderTextHeight\\\" format=\\\"dimension\\\"/>\\n        <attr name=\\\"yearHeaderTextSize\\\" format=\\\"dimension\\\"/>\\n        <attr name=\\\"yearHeaderLunarTextColor\\\" format=\\\"color\\\"/>\\n        <attr name=\\\"yearHeaderLunarTextSize\\\" format=\\\"dimension\\\"/>\\n        <attr name=\\\"yearHeaderDashColor\\\" format=\\\"color\\\"/>\\n        <attr name=\\\"monthLabelTextColor\\\" format=\\\"color\\\"/>\\n        <attr name=\\\"monthLabelTextSize\\\" format=\\\"dimension\\\"/>\\n        <attr name=\\\"monthLabelTextHeight\\\" format=\\\"dimension\\\"/>\\n        <attr name=\\\"dayLabelTextColor\\\" format=\\\"color\\\"/>\\n        <attr name=\\\"dayLabelTextSize\\\" format=\\\"dimension\\\"/>\\n        <attr name=\\\"dayLabelRowHeight\\\" format=\\\"dimension\\\"/>\\n        <attr name=\\\"dayLabelCircleRadius\\\" format=\\\"dimension\\\"/>\\n    </declare-styleable>\\n```\\n\\n  可以通过setDecors方法为YearView设置decorators。setDecors方法对于其它的控件都可用。详细见 [这里](#decorDetail) 。\\n```java\\n\\tyearView.setToday(new CalendarDay(2017, 2, 12));\\n\\tDayDecor dayDecor = new DayDecor();\\n\\tdayDecor.putOne(new CalendarDay(2017, 1, 1), Color.GREEN);\\n\\tyearView.setDecors(dayDecor);\\n```\\n\\n  截图：\\n\\n  ![image1](https://raw.githubusercontent.com/missmess/CalendarView/master/raw/yv.jpg)\\n\\n###### 2、MonthView\\n\\n  月历。提供了17个自定义属性来控制MonthView布局。\\n  ```xml\\n    <declare-styleable name=\\\"MonthView\\\">\\n        <attr name=\\\"dayCircleRadius\\\" format=\\\"dimension\\\" />\\n\\t\\t<attr name=\\\"selectDayCircleBgColor\\\" format=\\\"color\\\" />\\n\\t\\t<attr name=\\\"dayTextColor\\\" format=\\\"color\\\"/>\\n\\t\\t<attr name=\\\"dayDisableTextColor\\\" format=\\\"color\\\"/>\\n\\t\\t<attr name=\\\"dayTextSize\\\" format=\\\"dimension\\\"/>\\n\\t\\t<attr name=\\\"dayRowHeight\\\" format=\\\"dimension\\\" />\\n\\t\\t<attr name=\\\"firstDayOfWeek\\\" format=\\\"integer\\\" />\\n\\t\\t<attr name=\\\"monthTitleColor\\\" format=\\\"color\\\" />\\n\\t\\t<attr name=\\\"monthTextSize\\\" format=\\\"dimension\\\" />\\n\\t\\t<attr name=\\\"monthHeaderHeight\\\" format=\\\"dimension\\\" />\\n\\t\\t<attr name=\\\"weekLabelTextColor\\\" format=\\\"color\\\" />\\n\\t\\t<attr name=\\\"weekLabelTextSize\\\" format=\\\"dimension\\\" />\\n\\t\\t<attr name=\\\"weekLabelPadding\\\" format=\\\"dimension\\\" />\\n\\t\\t<attr name=\\\"showWeekLabel\\\" format=\\\"boolean\\\"/>\\n\\t\\t<attr name=\\\"showWeekDivider\\\" format=\\\"boolean\\\"/>\\n\\t\\t<attr name=\\\"showMonthTitle\\\" format=\\\"boolean\\\"/>\\n\\t\\t<attr name=\\\"weekMode\\\" format=\\\"boolean\\\"/>\\n    </declare-styleable>\\n  ```\\n\\n 截图：\\n\\n ![image2](https://raw.githubusercontent.com/missmess/CalendarView/master/raw/mv2.jpg)\\n\\n###### 3、MonthViewPager\\n\\n  可滚动的月历，左右滑动或点击indicator切换显示的月份。\\n\\n  **使用MonthViewPager需要在xml中为它设置一个子view。这个子view只可以用来添加属性，但是不可以通过findViewById使用它。这个子view仅用作定义样式。**\\n\\n  截图：\\n\\n  ![gif2](https://raw.githubusercontent.com/missmess/CalendarView/master/raw/mvp.gif)\\n\\n###### 4、TransitRootView\\n\\n  这个viewgroup用来控制年历和月历之间的过渡。在xml中需要使用TransitRootView作为根布局，增加两个子view或viewgroup，它们分别包含你的YearView和MonthView（或者MonthViewPager）。\\n  顺序不能颠倒，否则达不到指定的效果。详见demo。\\n\\n  提供了多个自定义属性用来控制过渡过程：\\n  ```xml\\n  <declare-styleable name=\\\"TransitRootView\\\">\\n\\t  <attr name=\\\"y2m_interpolator\\\" format=\\\"reference\\\" />\\n\\t  <attr name=\\\"m2y_interpolator\\\" format=\\\"reference\\\" />\\n\\t  <attr name=\\\"y_anim_duration\\\" format=\\\"integer\\\" />\\n\\t  <attr name=\\\"transit_base_duration\\\" format=\\\"integer\\\" />\\n\\t  <attr name=\\\"m_anim_duration\\\" format=\\\"integer\\\" />\\n  </declare-styleable>\\n  ```\\n\\n<h6 id='decorDetail'>5、DayDecor和Style</h6>\\n\\n  DayDecor可以为某一个显示的天，添加多种样式的Decorator或定义文字样式。示例：\\n  ```java\\n\\t// add decorators\\n\\tDayDecor dayDecor = new DayDecor();\\n\\t// circle bg\\n\\tdayDecor.putOne(new CalendarDay(2017, 2, 1), 0xFFFF6600);\\n\\t// rectangle bg\\n\\tint color = 0xFFAAAAAA;\\n\\tdayDecor.putOne(new CalendarDay(2017, 2, 4), color, DayDecor.Style.RECTANGLE);\\n\\tdayDecor.putOne(new CalendarDay(2017, 2, 11), color, DayDecor.Style.RECTANGLE);\\n\\tdayDecor.putOne(new CalendarDay(2017, 2, 18), color, DayDecor.Style.RECTANGLE);\\n\\tdayDecor.putOne(new CalendarDay(2017, 2, 25), color, DayDecor.Style.RECTANGLE);\\n\\t// drawable bg\\n\\tdayDecor.putOne(new CalendarDay(2017, 2, 19), getResources().getDrawable(R.drawable.a_decor));\\n\\t// styled background and text\\n\\tDayDecor.Style style = new DayDecor.Style();\\n\\tstyle.setTextSize(getResources().getDimensionPixelSize(R.dimen.big_text));\\n\\tstyle.setTextColor(0xFF72E6BC);\\n\\tstyle.setBold(true);\\n\\tstyle.setItalic(true);\\n\\tstyle.setUnderline(true);\\n\\tstyle.setStrikeThrough(true);\\n\\tstyle.setPureColorBgShape(DayDecor.Style.CIRCLE);\\n\\tstyle.setPureColorBg(0xFF66AA76);\\n\\tdayDecor.putOne(new CalendarDay(2017, 2, 24), style);\\n\\tmonthView.setDecors(dayDecor);\\n  ```\\n\\n###### 6、周历到月历切换\\n  \\n  1、支持月历周历的竖直滑动切换。需要配合nested scrolling。示例：\\n  ```xml\\n      <!-- 顶层需使用CoordinatorLayout -->\\n      <android.support.design.widget.CoordinatorLayout\\n          android:layout_width=\\\"match_parent\\\"\\n          android:layout_height=\\\"match_parent\\\">\\n  \\n          <com.missmess.calendarview.MonthViewPager\\n              android:id=\\\"@+id/mvp\\\"\\n              android:layout_width=\\\"match_parent\\\"\\n              android:layout_height=\\\"match_parent\\\"\\n              calendar:ic_next_month=\\\"@mipmap/right_icon\\\"\\n              calendar:ic_previous_month=\\\"@mipmap/left_icon\\\"\\n              calendar:month_marginTop=\\\"0dp\\\"\\n              calendar:otherMonthTextColor=\\\"#CCCCCC\\\"\\n              calendar:showOtherMonth=\\\"true\\\"\\n              calendar:show_indicator=\\\"false\\\">\\n  \\n              <com.missmess.calendarview.MonthView\\n                  android:layout_width=\\\"match_parent\\\"\\n                  android:layout_height=\\\"wrap_content\\\"\\n                  calendar:showMonthTitle=\\\"false\\\"\\n                  calendar:showWeekDivider=\\\"false\\\"\\n                  calendar:dayRowHeight=\\\"50dp\\\"\\n                  calendar:showWeekLabel=\\\"false\\\"/>\\n  \\n          </com.missmess.calendarview.MonthViewPager>\\n  \\n  \\t\\t  <!-- 这个view将覆盖MonthViewPager，并且需要支持nested scrolling -->\\n  \\t\\t  <!-- 需要增加behavior,  使用@string/monthViewPager_scroll_behavior-->\\n          <android.support.v4.widget.NestedScrollView\\n              android:id=\\\"@+id/scrollView\\\"\\n              android:layout_width=\\\"match_parent\\\"\\n              calendar:layout_behavior=\\\"@string/monthViewPager_scroll_behavior\\\"\\n              android:background=\\\"@android:color/white\\\"\\n              android:layout_height=\\\"match_parent\\\" >\\n  \\n              <TextView\\n                  android:id=\\\"@+id/tv\\\"\\n                  android:layout_width=\\\"match_parent\\\"\\n                  android:layout_height=\\\"wrap_content\\\"\\n                  android:gravity=\\\"center\\\"\\n                  android:padding=\\\"15dp\\\"\\n                  android:text=\\\"@string/no_event\\\"\\n                  android:textSize=\\\"20sp\\\"/>\\n  \\n          </android.support.v4.widget.NestedScrollView>\\n      </android.support.design.widget.CoordinatorLayout>\\n  ```\\n  \\n  2、如果不需要嵌套垂直滑动切换week/month mode。则不要使用behavior即可。同时提供直接在代码中进行切换。\\n  ```java\\n  \\t\\tif(monthViewPager.isMonthMode()) {\\n\\t\\t\\tmonthViewPager.setWeekMode();\\n\\t\\t} else {\\n\\t\\t\\tmonthViewPager.setMonthMode();\\n\\t\\t}\\n  ```\\n  \\n  通过上述步骤就能实现周历、月历切换功能。\\n\\n---\\n\\n### 接下来的工作\\n###### 还有一些工作需要完善：\\n\\n  ~~1、 强化DayDecor的功能，包括对样式（加粗、斜体），任意背景，任意字体颜色的自定义。~~\\n\\n  ~~2、 增加月历上滑显示到周历的功能。类似于小米日历的效果。~~\\n\\n  ~~3、周历上切换时，默认设置selection也根据切换变化。~~\\n\\n  ~~4、设置某一天disable属性~~\\n  \",\"n\":0.052}}},{\"i\":6,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"CoverFlowView\\\"\\ncover: images/coverflow.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"CoverFlowView是一个在Android上实现coverflow效果的组件\\\"\\ndatePublished: \\\"2016-11-21 15:44:15\\\"\\ndateModified: \\\"2016-11-21 15:44:15\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - UI组件\\n  - 开源\\n---\\n\\nCoverFlowView是一个在Android上实现coverflow效果的组件。它的Item支持任意自定义布局。\\n\\ngithub仓库：https://github.com/missmess/CoverFlowView\\n\\n---\\n\\n  基于[ImageCoverFlow](https://github.com/dolphinwang/ImageCoverFlow)，但是有较大改动，在ImageCoverFlow的基础上增加了\\n  对自定义布局的支持，可以支持任意布局。同时增加了一些其他支持，并修复了一些bug，提升绘制速度。\\n\\n  Based on [ImageCoverFlow](https://github.com/dolphinwang/ImageCoverFlow), add support to custom\\n  layout in CoverFlow, fix some bugs, add other function.\\n\\n---\\n  GIF预览：\\n\\n  ![gif](https://raw.githubusercontent.com/missmess/CoverFlowView/master/raw/sample.gif)\\n\\n---\\n\\n  * [主要功能介绍](#主要功能介绍)\\n  * [如何添加到项目中](#如何添加到项目中)\\n  * [如何使用](#如何使用)\\n  * [其它API](#其它API)\\n\\n---\\n\\n### 主要功能介绍\\n\\n* 支持自定义布局。\\n* 支持多种view切换方式。\\n* 支持view on top， top click， long click监听。\\n* 支持notify刷新数据源和重设适配器。\\n\\n---\\n\\n### 如何添加到项目中\\n\\n本library已经支持Gradle直接添加远程依赖。Android Studio用户，只需要在项目的build.gradle中添加该dependencies：\\n\\n  `\\n    compile \\\"com.missmess.coverflowview:coverflowview:1.2.8\\\"\\n  `\\n\\n---\\n\\n###如何使用\\n\\n使用非常简单。仅需几句代码。用法如下：\\n###### 1、在xml中定义布局。\\n```xml\\n<com.missmess.coverflowview.CoverFlowView\\n    android:id=\\\"@+id/coverflow_view\\\"\\n    android:layout_width=\\\"match_parent\\\"\\n    android:layout_height=\\\"180dp\\\"\\n    app:loopMode=\\\"true\\\"\\n\\tapp:visibleViews=\\\"3\\\"/>\\n```\\n###### 2、创建adapter。继承于ACoverFlowAdapter。adapter的实现与RecyclerView.Adapter完全相同。\\n```java\\npublic class MyCoverFlowAdapter extends ACoverFlowAdapter<MyCoverFlowAdapter.ViewHolder> {\\n    @Override\\n    public int getCount() {\\n        return 0;\\n    }\\n\\n    @Override\\n    public ViewHolder onCreateViewHolder(ViewGroup parent, int type) {\\n        return null;\\n    }\\n\\n    @Override\\n    public void onBindViewHolder(ViewHolder vh, int position) {\\n    }\\n\\n    class ViewHolder extends ACoverFlowAdapter.ViewHolder {\\n        public ViewHolder(View itemView) {\\n            super(itemView);\\n        }\\n    }\\n}\\n```\\n\\n###### 3、为CoverFlowView设置adapter。\\n```java\\nCoverFlowView coverflow_view = (CoverFlowView) findViewById(R.id.coverflow_view);\\nMyCoverFlowAdapter adapter = new MyCoverFlowAdapter();\\ncoverflow_view.setAdapter(adapter);\\n```\\n---\\n\\n### 其它API\\n###### 1、切换CoverFlow\\n* 你可以通过滑动切换，也可以通过点击CoverFlow的左右两侧实现快速切换。但点击切换需要确保clickSwitchEnable为\\ntrue。\\n\\n  通过coverFlowView.setClick2SwitchEnabled(boolean enable)方法设置是否启用点击左右侧切换。\\n\\n* 如果你想在在代码中切换view。可以有如下的几种方法：\\n\\n  1. gotoPrevious()：当前位置往前切换一个。\\n\\n  2. gotoForward()：当前位置往后切换一个。\\n\\n  3. setSelection(int selection, boolean smooth)：切换到指定的位置，smooth为true则显示过渡动画，为false\\n则快速切换。\\n\\n###### 2、更新数据\\n* 你可以直接使用adapter.notifyDataSetChanged()来刷新你的适配器数据。\\n* 也可以使用新的adapter：\\n```java\\ncoverflow_view.setAdapter(new NewCoverFlowAdapter());\\n```\\n\\n###### 3、设置监听\\nCoverFlowView提供三种lister：\\n\\n* setOnViewOnTopListener：当任意一个新的view停止滑动后，位于顶部。就会调用。这个是最常用的。\\n* setOnTopViewClickListener：当位于顶部的view被点击后调用。\\n* setOnTopViewLongClickListener：当位于顶部的view接收了long click事件时调用。\\n\\n\\n###### 4、循环模式\\n使用setLoopMode(boolean)方法或者在xml中定义loopMode来启用和关闭循环模式。\\n在循环模式下，将可以无限向左和向右滑动，item将会循环显示。关闭后，滑动到第一个或者最后一个item，将\\n不能继续向左或向右滑动。\\n\\n\\n---\\n\\n### 截图\\n\\n  ![image1](https://raw.githubusercontent.com/missmess/CoverFlowView/master/raw/screenshot_1.jpg)\\n  ![image2](https://raw.githubusercontent.com/missmess/CoverFlowView/master/raw/screenshot_2.jpg)\\n  ![image3](https://raw.githubusercontent.com/missmess/CoverFlowView/master/raw/screenshot_3.jpg)\\n\",\"n\":0.081}}},{\"i\":7,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"EmotionKeyboard\\\"\\ncover: images/ekb_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"帮助实现类似微信的聊天界面表情布局和功能布局与键盘同高，并且无缝切换的特效。\\\"\\ndatePublished: \\\"2017-06-20 10:40:32\\\"\\ndateModified: \\\"2017-06-20 10:40:32\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - 库\\n  - 开源\\n---\\n\\n帮助实现类似微信的聊天界面表情布局和功能布局与键盘同高，并且无缝切换的特效。\\n\\ngithub仓库：https://github.com/missmess/EmotionKeyboard\\n\\n---\\n\\n类似微信聊天界面的表情窗口控制，窗口跟软键盘同高，无缝切换效果。\\n有两个类，原先的EmotionKeyboard使用的核心代码参考的是dss886的开源项目（ https://github.com/dss886/Android-EmotionInputDetector ）。\\n但是经测试发现，这个类有一些无法解决的问题（源于它的方法实现原理），如\\n\\n<ol>\\n<li>表情键盘显示时，长按输入框文字会导致表情键盘，软键盘切换出错。</li>\\n<li>表情键盘和软键盘无法平滑的过渡。</li>\\n<li>使用不太方便，默认只支持LinearLayout，要自己实现locker</li>\\n</ol>\\n\\n所以这个类已经不提供更新了，仅仅提供大家作为参考。\\n现在用了一个新的思路去实现同样的功能。使用方法相同，但是却解决了以上无法解决的所有问题。详情请查看EmojiconKeyBoard源码。\\n  \\n---\\n  GIF和图片预览：\\n\\n  ![gif](https://raw.githubusercontent.com/missmess/EmotionKeyboard/master/raw/sample.gif)\\n  \\n  ![gif](https://raw.githubusercontent.com/missmess/EmotionKeyboard/master/raw/sample2.gif)\\n\\n---\\n\\n### 如何添加到项目中\\n\\n在项目的build.gradle中添加该dependencies：\\n\\n  `\\n    compile 'com.missmess.emotionkeyboard:emotionkeyboard:1.1.3'\\n  `\\n\\n---\\n\\n### 功能介绍\\n\\n#### KeyboardInfo\\n  \\n  KeyboardInfo可以用来监听键盘状态变化和获取键盘高度信息，并缓存。使用步骤：\\n  \\n  1. 在onCreate中获取：\\n  ```java\\n  KeyboardInfo keyboardInfo = KeyboardInfo.from(this);\\n  ```\\n  \\n  2. 设置监听listener:\\n  ```java\\n    keyboardInfo.setOnKeyboardChangeListener(new KeyboardInfo.OnSoftKeyboardChangeListener() {\\n\\t\\t@Override\\n\\t\\tpublic void onSoftKeyboardStateChanged(boolean shown, int height) {\\n\\t\\t\\tif (shown) {\\n\\t\\t\\t\\ttv_status.setText(String.format(\\\"键盘弹出了，高度为 %d\\\", height));\\n\\t\\t\\t} else {\\n\\t\\t\\t\\ttv_status.setText(\\\"键盘收起了\\\");\\n\\t\\t\\t}\\n\\t\\t}\\n\\t});\\n  ```\\n  \\n  3. 在onCreate或者onResume中开始监听键盘状态变化：\\n  ```java\\n    keyboardInfo.startListening();\\n  ```\\n  \\n  4. 在onDestory或者onPause中结束监听：\\n  ```java\\n    keyboardInfo.stopListening();\\n  ```\\n  \\n  也可以通过调用getSoftKeyboardHeight()方法，只要打开过一次键盘之后这个方法就总能取到正确的键盘高度值。\\n  \\n#### EmojiconKeyBoard\\n\\n  帮助协调聊天内容布局，聊天输入框，表情按钮和表情布局的控制类。这个类的作用有：\\n  \\n  1. 实现弹出键盘和表情布局；\\n  2. 实现表情布局和软键盘同高，无缝切换；\\n  3. 实现输入框和内容布局的焦点控制。\\n  \\n  实现效果类似微信的聊天输入框交互，并能实现很多的自定义扩展功能。\\n  \\n  使用步骤：\\n  1. 使用Builder创建和定义你需要的功能：\\n  ```java\\n  \\t\\t\\t  emotionKeyboard = new EmojiconKeyBoard.Builder(this)\\n                  .contentLayout(contentView)//绑定内容view\\n                  .editText(editText)//绑定EditView\\n                  .addEmotionBtnAndLayout(emoji_button1, layout_button1)//添加第一个表情按钮布局\\n                  .addEmotionBtnAndLayout(emoji_button2, layout_button2)//第二个\\n                  .touchContentViewHideAllEnabled(null)//是否在触摸内容view时获取焦点隐藏键盘\\n                  .keyboardStateCallback(callback)//键盘状态监听\\n                  .emotionPanelStateCallback(callback)//表情布局状态监听\\n                  .build();//创建\\n  ```\\n  \\n  2. 注意在按下返回键时判断是否要隐藏表情布局：\\n  ```java\\n      @Override\\n      public void onBackPressed() {\\n          if (!emotionKeyboard.interceptBackPress()) {\\n              super.onBackPressed();\\n          }\\n      }\\n  ```\\n  \\n  参考DEMO中的WechatActivity，可以完全的实现类似微信聊天界面的交互。\\n  \\n  <b>你的主题和你的window属性很多情况下都会导致，键盘弹出和收起不平滑，即动画的背景不是我们的表情布局。\\n  建议你使用全屏主题。如果使用透明状态栏主题，请自行设置fitSystemWindow为true，和clipToPadding为false。</b>\\n  \\n#### EmojiconKeyBoard\\n\\n  已经废弃，仅供参考，不要使用。已经使用的请使用新的类EmojiconKeyBoard\\n  \",\"n\":0.086}}},{\"i\":8,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"FastMind\\\"\\ncover: fastmind/cover.jpg\\ncoverAlt: \\\"FastMind工作台\\\"\\ndescription: \\\"FastMind是一个AI大模型助手平台\\\"\\ndatePublished: \\\"2023-06-23 09:13:11\\\"\\ndateModified: \\\"2023-06-23 09:13:11\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - 大模型\\n  - Antd\\n  - AI\\n---\\n\\n**FastMind**是一个免费可用的AI大语言模型**自建助手**平台，可以创建你自己想要的助手，并可以在平台内外分享。\\n\\n访问地址：http://ai.siyisea.com\\n\\n![](./fastmind/intro.jpg)\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [PC截图](#pc截图)\\n- [H5截图](#h-5-截图)\\n\\n### 主要功能\\n\\n1. **AI大模型**\\n\\n    接入llm提供商（gpt3.5、gpt4、文心一言等）处理语言服务。\\n\\n2. **180+官方助手**\\n\\n    已涵盖大部分大语言模型可以提效的场景，开箱即用。\\n\\n3. **自建知识库**\\n\\n    支持自己上传任意常用格式的文档，让助手理解你的业务。\\n\\n    ![](./fastmind/zhishiku.jpg)\\n\\n4. **自建助手**\\n\\n    可以任意自定义助手的形象、名称、对话风格、聊天框背景、llm模型、模型设置、知识库等。\\n\\n    并且可以在修改配置后，实时预览移动端效果。\\n\\n    ![](./fastmind/zhushou.jpg)\\n\\n5. **支持多话题**\\n\\n    可以和同一个助手聊多个不同的话题。\\n\\n    ![](./fastmind/huati.jpg)\\n\\n6. **支持会员**\\n\\n    免费用户流量受限，购买会员后解锁更多功能。\\n\\n7. **管理后台**\\n\\n    配套的统一管理后台，包含助手管理、会话管理、用户管理、token管理、收入管理等\\n\\n    查看：[AI统一管理后台](/ai聊天统一后台)\\n\\n### 我的职责\\n\\n1. 产品UI设计。\\n\\n2. 前端页面开发。\\n\\n### 技术实现\\n\\n1. 前端使用React、Ant-Design、craco开发。\\n\\n2. 响应式设计，同时支持PC和手机浏览器。PC访问时默认展示应用官网、移动端访问时默认展示工作台。\\n\\n3. 可以切换暗黑/明亮两种主题。\\n\\n4. 接入微信支付，支持购买会员计划。\\n\\n5. 用户登录、信息查询等接入[用户中心服务](/用户中心服务)，使用Express开发。\\n\\n6. AI大模型部分接入gpt3.5。\\n\\n7. 聊天消息渲染使用react-markdown。\\n\\n### PC截图\\n\\n![官网](./fastmind/capture_1.jpg)\\n![购买会员](./fastmind/capture_2.jpg)\\n![登录](./fastmind/capture_3.jpg)\\n![助手详情](./fastmind/capture_4.jpg)\\n![知识库](./fastmind/capture_5.jpg)\\n![邀请好友](./fastmind/capture_6.jpg)\\n\\n### H5截图\\n\\n![首页](./fastmind/capture_1_m.jpg)\\n![助手详情](./fastmind/capture_2_m.jpg)\\n![会话列表](./fastmind/capture_3_m.jpg)\\n![我的](./fastmind/capture_4_m.jpg)\\n![我的会员](./fastmind/capture_5_m.jpg)\",\"n\":0.13}}},{\"i\":9,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"HandWritingRecognize【手写识别】\\\"\\ncover: images/hwr_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"手写识别\\\"\\ndatePublished: \\\"2018-09-11 09:12:11\\\"\\ndateModified: \\\"2018-09-11 09:12:11\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Android端\\n  - AI\\n  - 库\\n  - 开源\\n  - 图像处理\\n---\\n\\n## HardwritingRecognition\\nAndroid端手写识别组件，目前主要实现手写数字识别方面。支持单数字和多数字。\\n\\ngitee仓库：https://gitee.com/missmess/HardwritingRecognition\\n\\n技术实现：通过opencv对输入图像进行拆分/缩放/归一化等处理，送入推理框架推理取得分值最高的结果。\\n\\n> 当前已支持pytorch、tensorflow lite框架，如果需要支持其他推理框架，请自行实现接口。\\n\\n---\\n\\n  * [主要功能简介](#主要功能简介)\\n  * [添加到项目中](#添加到项目中)\\n  * [主要API](#主要API)\\n\\n---\\n\\n### 主要功能简介\\n  * 单个数字识别\\n  * 多个数字组合识别\\n\\n### 添加到项目中\\n\\na. 在根目录下的build.gradle下添加远程仓库地址:\\n```java\\nallprojects {\\n    repositories {\\n        google()\\n        jcenter()\\n        maven { url \\\"http://10.2.1.12:8081/repository/cloudlearning-release/\\\" }\\n    }\\n}\\n```\\n\\nb. 在app的build.gradle里添加远程库的依赖:\\n```java\\nimplementation 'com.xes.hardwritingrecognition:hardwritingrecognition:1.2.0'\\n```\\n\\n**从1.2.0开始，改为使用输入笔画的方式来识别，替代了之前版本中输入整个bitmap的方式。**\\n\\n### 主要API\\n##### 1. 使用HWRecognizer的构造方法创建实例，第二个参数是识别库需要使用到的Model文件。（对应的tensorflow则使用的是pb文件）。\\n```java\\nHWRecognizer recognizer = new HWRecognizer(this, \\\"mnist_1207.pb\\\");\\n```\\n\\n##### 2. 每手写一个笔画，将path输入到HWRecognizer。\\n```java\\nrecognizer.addPath(path);\\n```\\npath以画布的左上角为原点，参考[demo](app/src/main/java/com/xes/recognitiondemo/HandWriteView.java)中path的获取。\\n\\n##### 3. 调用识别方法，将会处理已输入的所有笔画，并返回字符串的结果\\n```java\\nString result = recognizer.start();\\n```\\n\\n##### 4. 新一轮识别前，需要清空已输入的paths。\\n```java\\nrecognizer.clearPaths();\\n```\\n\\n##### 5. 在合适的地方关闭，释放资源。\\n```java\\nrecognizer.destroy();\\n```\\n\\n##### 此外，如果需要查看日志和图片切割过程。请在创建实例前打开debug模式。\\n```java\\nHWRecognizer.DEBUG_MODE = true;\\n```\\ndebug模式下，会生成日志，并在sd卡中app目录下按时间生成图片处理多个流程的生成图像，方便调试。\\n\\n\",\"n\":0.119}}},{\"i\":10,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"心动天气\\\"\\ncover: weather/cover.jpeg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"心动天气\\\"\\ndatePublished: \\\"2021-05-30 09:08:40\\\"\\ndateModified: \\\"2021-05-30 09:08:40\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - Android端\\n  - kotlin\\n  - 组件化\\n---\\n\\n心动天气是一款主打天气预报，集热点新闻、日历提醒为一体的生活服务类app。\\n\\n---\\n\\n#### 技术特点\\n\\n1. 整体使用kotlin语言开发。部分控件使用java开发。\\n\\n2. 使用ARouter实现组件化开发。组件可单独运行、调试。\\n\\n3. 使用glide加载图片，图片缓存/优化。\\n\\n4. 使用OkHttp作为请求框架，使用Retrofit注解式定义接口，使用RxJava处理接口数据流。\\n\\n5. **【corelib】**module包含：业务无关的基础依赖、基础UI框架、事件总线RxBus、基础请求框架、常用弹窗、常用工具类。\\n\\n6. **【cmpt】**module包含：业务相关的基础依赖、BaseActivity/BaseFragment、页面路由定义、业务请求封装、基础控件、一些常量。\\n\\n7. **【app】**module包含：Application基类，启动页。（仅作为app壳子）。\\n\\n8. 其他业务模块：如home、mine、live，各个模块包含自己独立的业务代码。这部分代码包含：\\n\\n    - 页面，activity/fragment/view\\n    - bean model\\n    - 接口类\\n    - 业务资源\\n\\n#### 抽离脚手架\\n\\n心动天气是一个比较完善的```组件化+kotlin+Retrofit+Glide+MessUi```的实践项目。可以作为Android项目的启动脚手架使用。\\n\\n注意，如果要作为脚手架，遵循以下三步：\\n\\n1. 删除业务模块。\\n\\n2. 修改cmpt模块，它是业务基础module，这里面需要根据自己的业务规范和UI风格来相应调整。\\n\\n3. corelib不需要修改，它是业务无关的基础module\\n\\n#### 截图\\n\\n![首页](./weather/home.jpg)\",\"n\":0.16}}},{\"i\":11,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"云流\\\"\\ncover: yunliu/dashboard.jpg\\ncoverAlt: \\\"云流工作台\\\"\\ndescription: \\\"云流是低代码B端数据平台\\\"\\ndatePublished: \\\"2023-03-11 09:40:09\\\"\\ndateModified: \\\"2023-03-11 09:40:09\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - Vue2\\n  - ElementUI\\n  - 低代码\\n---\\n\\n**云流**是低代码的B端管理后台+数据平台产品。\\n\\n访问地址：http://114.55.92.229/backstage/\\n\\n参考：[yudao源码](https://gitee.com/y_project/RuoYi-Vue)。\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n1. **常见后台管理功能**\\n\\n  - 平台用户管理\\n  - 部门/组织架构/岗位管理\\n  - 菜单管理，菜单全动态配置，支持n级树状菜单\\n  - 角色/权限管理，管理菜单、数据权限\\n  - 通知公告\\n\\n2. **流程管理**\\n\\n  可以自己创建流程应用。\\n  ![创建应用](./yunliu/app-create.jpg)\\n  \\n  创建应用后可以设计流程表单，图形化拖动方式。支持全部常用组件。\\n  ![表单设计](./yunliu/app-form.jpg)\\n  \\n  可以使用流程设计器（bpmn），图形化拖动来设置流程。\\n  ![流程设计](./yunliu/app-bpmn.jpg)\\n\\n  流程应用调整设置后，可以发布，后续员工可以使用该流程。\\n  ![流程发布](./yunliu/app-set.jpg)\\n\\n3. **nocodb数据管理**\\n\\n  nocodb服务作为一个子服务，云流内嵌nocodb的GUI作为项目下的数据管理功能。\\n\\n  员工申请流程后，也可以在数据表格中进行数据管理。\\n\\n### 我的职责\\n\\n1. 产品UI调整。\\n\\n2. 管理后台UI开发。\\n\\n3. nocodb对接协议设计、开发。\\n\\n### 技术实现\\n\\n1. 云流使用vue2、element-ui开发。\\n\\n2. 流程设计器使用bpmn-js。\\n\\n3. 表单设计器使用form-generator。\\n\\n4. 富文本使用quill，表格使用echarts。\\n\\n### 截图\\n\\n![登录](./yunliu/login.jpg)\\n![项目](./yunliu/project.jpg)\",\"n\":0.13}}},{\"i\":12,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"【造轮子】async/await实现原理\\\"\\ncover: ../static/assets/async_await.jpeg\\ncoverAlt: \\\"封面图\\\"\\ndescription: \\\"async/await是ES7的新特性，是一种异步编程的解决方案\\\"\\ndatePublished: \\\"2022-12-27 18:47:13\\\"\\ndateModified: \\\"2022-12-27 18:47:13\\\"\\nslug: \\\"async-await-intro\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 前端\\n  - 造轮子\\n---\\n\\nasync/await是ES7的新特性，它是处理异步操作的一种语法糖，主要是为了使异步代码更加简洁和直观。\\n\\n#### async/await基础知识\\n\\n`async`用在函数上，声明这个函数是异步函数。异步函数会返回一个Promise对象。\\n\\n`await`用在一个返回Promise的表达式前面，它会等待这个Promise的结束，并获取Promise的结果值（如果包含error，需要try catch）。`await`只能用在异步函数内，即和`async`搭配使用。如下：\\n\\n```javascript\\nasync function asyncFunc() {\\n    ...\\n    // anotherAsyncFunc返回Promise，result是它的结果值\\n    const result = await anotherAsyncFunc()\\n    ...\\n}\\n```\\n\\n`async/await`的出现，让异步代码编写很类似于同步代码的风格，比起`Promise`的写法，代码可读性要高很多。\\n\\n本次主要扒一下`async/await`的底层实现，它是一个语法糖，所以它可以转为老的代码写法：它可以使用`generator`和`Promise`实现一样的功能。\\n\\n#### generator（生成器）\\n\\n`generator`是ES6的新特性，它是一种特殊的函数，可以通过`yield`关键字来控制函数的执行流程。它能实现代码的暂停和恢复执行，所以它可以用于实现异步编程、状态机等比较复杂的控制流程。\\n\\n`generator`函数使用`function*`声明，调用`generator`函数后，它不会立即执行，而是返回一个迭代器对象`iterator`。调用`iterator`的`next`方法，会逐步执行`generator`函数中的代码，并执行到`yield`语句时暂停，将`yield`后的表达式的值作为`next`方法的返回值。`next`方法的参数值，会作为上一个`yield`语句的返回值。`generator`函数执行结束后，`iterator`的`done`会返回true。示例：\\n\\n```javascript\\nfunction* generatorFunc() {\\n    console.log('Start')\\n    const data1 = yield 'state 1';\\n    console.log('return 1', data1);\\n    const data2 = yield 'state 2';\\n    console.log('return 2', data2);\\n}\\n\\nconst iterator = generatorFunc();\\nconsole.log(iterator.next()); // 会依次打印：Start、{ done: false, value: 'state 1' }\\nconsole.log(iterator.next(\\\"张三\\\"));  // 会依次打印：return 1 张三、{ done: false, value: 'state 2' }\\nconsole.log(iterator.next(\\\"李四\\\"));  // 会依次打印：return 2 李四、{ done: true, value: undefined }\\n```\\n\\n`generator`一个典型的用途就是搭配对象的`[Symbol Iterator]`迭代器属性，让任意对象实现`for..of`迭代。\\n\\n#### generator实现async/await\\n\\n比如如下使用了`async/await`的函数：\\n```javascript\\n// async/await的写法\\nconst doAsync = async () => {\\n    console.log(\\\"start await\\\");\\n    const data1 = await asyncFunc(\\\"asyncFunc 1\\\");\\n    console.log(\\\"middle await\\\", data1);\\n    const data2 = await asyncFunc(data1);\\n    console.log(\\\"end await\\\", data2);\\n};\\n```\\n\\n该函数调用方法为：`doAync()`，返回Promise\\n\\n要转成`generator`，让`generator`函数内的写法和该方法类似。\\n\\n```javascript\\n// generator的写法\\nfunction* generator() {\\n    console.log(\\\"start generator\\\");\\n    const data1 = yield asyncFunc(\\\"asyncFunc 1\\\");\\n    console.log(\\\"middle generator\\\", data1);\\n    const data2 = yield asyncFunc(data1);\\n    console.log(\\\"end generator\\\", data2);\\n}\\n```\\n\\n因为`yield`会暂停执行代码，所以使用`yield`也实现了类似`await`的效果。有了`generator`函数，需要调用函数后获取`iterator`，让`iterator`全部执行并直到结果done为true。\\n\\n```javascript\\n// 通用的generatorRunner，将yield全部执行，并且获取异步函数返回值\\n// 效果就是类似于async/await\\nconst generatorRunner = (genFunc: () => Generator) => {\\n  const iterator = genFunc();\\n  // 连续调用next方法，直到done为true\\n  return (function run(arg?: any): any {\\n    const result = iterator.next(arg);\\n    if (result.done) {\\n      return result.value;\\n    }\\n    return Promise.resolve(result.value).then(run);\\n  })();\\n};\\n```\\n\\n看代码，因为`yield`后面跟的是一个`Promise`，所以需要使用`Promise.resolve`来处理value。然后在`then回调`里递归调用`run()`。直到done为true。\\n\\n这个`generatorRunner`是通用的，参数是`generator`函数，会将`generator`函数内的语句按顺序执行完，遇到`Promise`会等待resolved，最终返回`generator`函数的返回值。\\n\\n`generatorRunner`和`generator`函数都写好了，调用方法：`generatorRunner(generator)`，也是返回Promise。\\n\\n#### babel或ts是怎么转译的\\n\\n前面我们使用`generator`+`Promise`的方式，实现了同`async/await`一模一样的效果。现在看一下babel或ts对`async/await`是怎么处理的。\\n\\n周所周知，一些老的浏览器是没法运行es新特性的，所以才需要ts、babel之类的工具来转译代码。还是上面的`async/await`函数的例子，我们看一下它被typescript从es7代码转为es6代码后，变成了什么样子。\\n\\n> 怎么操作：在webpack.config.js中，关闭sourcemap，ts代码配置用ts-loader加载，在tsconfig.json中配置target为'es6'\\n\\n![es6转译后代码](../static/assets/async-await-转译.jpg)\\n\\n可以看到`async/await`函数转为了```()=>__awaiter(this, ..., function* () { ... })```。\\n即\\\\__awaiter函数加`generator`函数，其中`generator`函数代码，和我们上面的例子的代码一模一样。这么推算的话，那\\\\__awaiter函数估计就和我们上面的例子里的`generatorRunner`功能差不多啦。看看\\\\__awaiter函数：\\n\\n![__awaiter函数](../static/assets/async__awaiter.jpg)\\n\\n可以看到差不太多，只不过多做了一些适配。都是返回Promise，递归处理result，知道done为true。\\n\\n再往下看的话，比如将代码转为es6之前，会看到`Promise`和`generator`也被转成了低版本的实现，而`async/await`仍然使用同样的代码。或者使用babel去转译，也是一样的。\\n\\n所以说`async/await`就是个语法糖，它的底层实现就是`Promise` + `generator`，但是耐不住它真的很香，代码非常简洁直观。\",\"n\":0.075}}},{\"i\":13,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"用户中心服务\\\"\\ncover: user-center/login.jpg\\ncoverAlt: \\\"登录方式\\\"\\ndescription: \\\"用户中心服务提供用户登录、注册、认证、用户信息管理等功能\\\"\\ndatePublished: \\\"2023-05-08 14:28:03\\\"\\ndateModified: \\\"2023-05-08 14:28:03\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 后端\\n  - Node.js\\n  - Express\\n---\\n\\n**用户中心服务**提供统一的用户登录、认证服务。\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n\\n### 主要功能\\n\\n1. **登录/注册**\\n\\n  支持邮箱注册、邮箱验证码、邮箱用户名jwt登录、修改密码。\\n  \\n  支持关注微信公众号注册/登录、微信扫码注册/登录。\\n\\n  支持google登录。\\n\\n2. **用户信息**\\n\\n  提供对外的api接口，查询、修改、删除用户信息。\\n\\n3. **扩展认证方式**\\n\\n  使用passport实现用户认证，可以通过添加passport子组件任意添加其他认证方式。\\n\\n### 我的职责\\n\\n1. 用户中心服务开发。\\n\\n2. API接口设计，遵循RESTful规范。\\n\\n### 技术实现\\n\\n1. 使用Express开发服务。\\n\\n2. 使用passport实现用户认证。\\n\\n3. db部分使用knex，实现可对接多种类型数据库，同时方便管理库表升级。\\n\\n4. 发送email设计为plugin模式，方便替换email服务提供商。\\n\\n5. 使用ioredis添加redis缓存支持。\",\"n\":0.16}}},{\"i\":14,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"1h手撸一个PC批量混剪软件\\\"\\ncover: images/bing-tool.png\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"小饼混剪助手\\\"\\ndatePublished: \\\"2023-10-09 17:05:11\\\"\\ndateModified: \\\"2023-10-09 17:05:11\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - Node.js\\n  - Electron\\n  - 视频处理\\n---\\n\\n本文将介绍怎么样使用`electron + ffmpeg`在**1小时内**快速开发一个运营人常用的工具：视频批量混剪工具。\\n\\n> 混剪工具就是将一个长视频，按照设定的时间，分割成一段一段的视频切片的工具。\\n\\n### 准备工作\\n\\n准备好基础环境：\\n\\n- 安装Node.js（推荐安装nvm，使用nvm安装Node.js，方便后续随时切换Node.js版本）\\n- 安装VS code\\n- 学习一下javascript语言和ffmpeg知识\\n\\nDONE！🀄️\\n\\n### 运行启动模版\\n\\n使用Electron启动模版快速创建一个桌面端软件。启动模版仓库地址：https://github.com/missmess/electron-template\\n\\n```shell\\n# 进入到要存储项目代码的文件夹内\\n# 执行该命令拷贝启动模版到本地\\n# (my-project-name)要替换为自己想要的项目名称\\nnpx degit missmess/electron-template (my-project-name)\\n```\\n\\n创建完成后如何使用，请参考README。\\n\\n### 写代码\\n\\n分析一下需求，需求就是将单个视频按照时间长度，切割成视频切片。单个视频做完之后，批量就简单了，for循环一下就行。\\n\\n##### ffmpeg命令\\n\\n首先单个视频如何切片？视频处理我们常用的工具是`ffmpeg`。为了在软件中切片，我们也使用`ffmpeg`去做处理。我们需要知道直接使用ffmpeg程序如何对进行视频切片。\\n\\n```shell\\n# -ss 从视频某位置开始 -t 时长 -i 输入文件 -c copy 复制输入文件的视频格式\\n# starttime-切片的开始时间 gap-切片时长 input.mp4-输入视频文件 output.mp4-输出视频文件\\nffmpeg -ss (starttime) -t (gap) -i (input.mp4) -c copy (output.mp4)\\n```\\n\\n知道了ffmpeg怎么处理单个视频的切片，后面我们需要将这段代码移植到Node.js上。\\n\\n##### Node.js上使用ffmpeg\\n\\nNode.js上比较好用的一个ffmpeg开源库是[Fluent-ffmpeg](https://github.com/fluent-ffmpeg/node-fluent-ffmpeg)。在桌面端代码根目录下，执行`shell`命令安装Fluent-ffmpeg：`npm install fluent-ffmpeg`。\\n\\nFluent-ffmpeg默认需要电脑上已安装好ffmpeg，并设置好系统环境变量。不过它也支持手动指定ffmpeg的二进制运行库的位置，这才是我们需要的。因为我们不能保证用户电脑上已经安装ffmpeg，所以我们要把ffmpeg打包到我们的软件中。\\n\\n然后就是安装ffmpeg和ffprobe（ffprobe是一个查询音视频文件基础信息的工具）。在node上希望安装对应系统的ffmpeg和ffprobe工具，也可以使用开源库实现，这样就不需要自己手动下载安装了。\\n\\n[@ffmpeg-install](https://github.com/kribblo/node-ffmpeg-installer#readme)：自动安装当前系统的ffmpeg运行库，也可以手动安装希望软件可以支持的系统对应的ffmpeg运行库。\\n\\n[@ffprobe-installer](https://github.com/SavageCore/node-ffprobe-installer#readme)：同上面的`@ffmpeg-install`。用法一模一样。\\n\\n都安装好后，在`javascript`代码中引入ffmpeg！我们选择在`src/core/eventHandler`中引入，因为我们将在这里接收渲染线程发送过来的“请求切割”事件。也可以新建一个js文件，这样代码规整些。\\n\\n```javascript\\n// eventHandler.js\\n...\\nconst ffmpegPath = require(\\\"@ffmpeg-installer/ffmpeg\\\").path;\\nconst ffprobePath = require(\\\"@ffprobe-installer/ffprobe\\\").path;\\nvar ffmpeg = require(\\\"fluent-ffmpeg\\\");\\nffmpeg.setFfmpegPath(ffmpegPath);\\nffmpeg.setFfprobePath(ffprobePath);\\n...\\n```\\n\\nffmpeg和ffprobe现在就可以使用了。接着简单做一下用户界面。\\n\\n##### 写webUI\\n\\n按理说，用户界面要写的好看、功能清晰才行，毕竟是软件的门面。不过为了演示我就随便加几个按钮，能演示功能就行。\\n\\n在/webapps/vue3-webapp/src/views/HomeView中，编辑一下页面内容：一个logo、一个选择批量待处理视频目录的按钮、一个选择保存处理好的视频切片目录的按钮、一个选择切片时长的输入框、一个开始按钮。\\n\\n对应的按钮操作和文本展示，写在script中：\\n\\n```html\\n<script setup lang=\\\"ts\\\">\\nimport { ref } from 'vue';\\nimport service from '@/NativeService';\\n\\nconst inputPath = ref(\\\"\\\")\\nconst outputPath = ref(\\\"\\\")\\nconst gapValue = ref(5)\\n\\nvar chooseInputDir = () => {\\n  service.chooseDir().then((paths: any) => {\\n    if (paths[0]) inputPath.value = paths[0];\\n  })\\n}\\nvar chooseOutputDir = () => {\\n  service.chooseDir().then((paths: any) => {\\n    if (paths[0]) outputPath.value = paths[0];\\n  })\\n}\\nvar startProcess = () => {\\n  console.log('调用混剪功能', inputPath.value, outputPath.value, gapValue.value);\\n  if (!inputPath.value || !outputPath.value) {\\n    alert('未选择输入文件或输出目录')\\n  } else {\\n    service.handleVideos(inputPath.value, outputPath.value, gapValue.value)\\n  }\\n}\\n</script>\\n\\n<template>\\n  <div class=\\\"flex-col flex-middle flex-justify-center container\\\">\\n    <div class=\\\"content\\\">\\n      <ElDescriptions title=\\\"🫓 小饼混剪助手\\\" border :column=\\\"1\\\">\\n        <ElDescriptionsItem labelClassName=\\\"label\\\">\\n          <template #label>\\n            <ElButton type=\\\"primary\\\" style=\\\"padding: 0;\\\" text @click=\\\"chooseInputDir\\\">源视频目录</ElButton>\\n          </template>\\n          {{ inputPath || '-' }}\\n        </ElDescriptionsItem>\\n        <ElDescriptionsItem labelClassName=\\\"label\\\">\\n          <template #label>\\n            <ElButton type=\\\"primary\\\" style=\\\"padding: 0;\\\" text @click=\\\"chooseOutputDir\\\">切片保存目录</ElButton>\\n          </template>\\n          {{ outputPath || '-' }}\\n        </ElDescriptionsItem>\\n        <ElDescriptionsItem label=\\\"视频切片时长\\\" labelClassName=\\\"label\\\">\\n          <ElInput v-model=\\\"gapValue\\\" placeholder=\\\"输入视频切片时长\\\">\\n            <template #append>秒</template>\\n          </ElInput>\\n        </ElDescriptionsItem>\\n      </ElDescriptions>\\n\\n      <div class=\\\"flex mt-16\\\">\\n        <ElButton type=\\\"primary\\\" @click=\\\"startProcess\\\">开始混剪</ElButton>\\n      </div>\\n    </div>\\n  </div>\\n</template>\\n\\n<style>\\n.container {\\n  height: 100vh;\\n  background: linear-gradient(180deg, #fcf0ff, #fff 30%);\\n}\\n.content {\\n  width: 520px;\\n}\\n</style>\\n```\\n\\n其中`service.handleVideos`方法是启动模版里没有的，需要在`/webapps/vue3-webapp/src/types/index`和`/src/wins/preload`中分别添加该方法。并在`/src/core/eventHandler`中注册监听。\\n\\n```javascript\\nipcMain.handle(\\\"handle-videos\\\", async (event, data) => {\\n  // 执行批量剪辑\\n}\\n```\\n\\nUI做完后效果如下：\\n\\n![](./images/bing-tool-home.jpg)\\n\\n##### node-ffmpeg实现单视频剪辑\\n\\n先实现单视频剪辑，分为两步：\\n\\n1. **获取视频总时长**\\n\\n    通过node-ffprobe获取视频信息，并根据时长递归的处理视频切割。\\n\\n    ```javascript\\n    function handleSingleFile(finput, foutput, gap) {\\n      ffmpeg.ffprobe(finput, function (err, metadata) {\\n        const duration = metadata.format.duration;\\n        console.log(\\\"获取到视频时长\\\", duration);\\n\\n        let index = 0;\\n        while (index * gap < duration) {\\n          videoSplit(index, gap);\\n          index++;\\n        }\\n      });\\n      ...\\n    }\\n    ```\\n\\n2. **切割视频**\\n\\n    前面我们知道了怎么使用ffmpeg命令进行视频切片，现在我们将命令转译到node上。\\n\\n    ```javascript\\n    function videoSplit(index, gap) {\\n      console.log(\\\"剪辑片段：\\\", index, gap);\\n      const start = gap * index;\\n      ffmpeg(finput)\\n        .inputOptions([`-ss ${start}`, `-t ${gap}`])\\n        .outputOptions(\\\"-c copy\\\")\\n        .output(foutput + `/output-${index + 1}.mp4`)\\n        .on(\\\"progress\\\", function (progress) {\\n          console.log(\\\"正在执行: \\\", progress);\\n        })\\n        .on(\\\"end\\\", function () {\\n          console.log(\\\"执行结束\\\");\\n        })\\n        .run();\\n    }\\n    ```\\n\\n到此，单个视频切割已经ok。👌\\n\\n##### 实现批量\\n\\n批量就比较简单，只需要读取输入目录下，全部文件即可。\\n\\n```javascript\\n// 监听并处理批量切割\\nipcMain.handle(\\\"handle-videos\\\", async (event, { inputDir, outputDir, gap }) => {\\n  // 通过fs读取目录\\n  const files = fs.readdirSync(inputDir);\\n  // 循环执行\\n  for (let i = 0; i < files.length; i++) {\\n    const file = files[i];\\n    const fname = file.substring(0, file.lastIndexOf(\\\".\\\"));\\n    const output = `${outputDir}/${fname}`\\n    fs.mkdirSync(output)\\n    await handleSingleFile(`${inputDir}/${file}`, output, gap);\\n  }\\n});\\n```\\n\\n### 打包\\n\\n利用启动模版的打包命令即可打包成最终的桌面软件啦～\\n\\n```shell\\n# 打包webUI\\nnpm run webBuild\\n# 打包软件\\nnpm run make\\n```\\n\\n### 优化建议\\n\\n到这里，一个基础的批量混剪工具就完成啦！\\n\\n不过整个软件目前也只是能正常跑通流程，还是有很多bug和优化需要去解决。比如：\\n\\n1. 单视频文件分割，还可以使用`segment muxer`来实现。比递归切割效率要高一些。\\n\\n2. 输入目录下不一定全部都是视频文件，非视频文件需要过滤掉\\n\\n3. 如果处理过程出现任何异常，应该通知到界面上。\\n\\n4. 界面需要实时显示处理进度。处理视频比较耗时，如果不显示进度，会让人误以为软件卡死了。\\n\",\"n\":0.052}}},{\"i\":15,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"优优小班-日志sdk\\\"\\ncover: banma/bmlog.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"用于优优小班的app内日志上传\\\"\\ndatePublished: \\\"2020-05-08 13:02:01\\\"\\ndateModified: \\\"2020-05-08 13:02:01\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - iOS端\\n  - Hybrid\\n  - 库\\n  - 架构\\n---\\n\\n**用于优优小班课app内的日志收集及上报。**\\n\\n### 架构\\n\\nAndroid和iOS原生开发日志sdk。sdk实现功能大概列为：\\n\\n1. 日志sdk设计为单例模式。\\n\\n2. 支持字符串、文件、图片上报。\\n\\n3. 字符串支持tag和日志内容，自动追加时间戳和基础信息。字符串也会写入文件。\\n\\n4. 日志设计为三级缓存：\\n\\n    a. 内存缓存。日志push后先存入内存，达到一定数量或达到一定时间间隔或主动调用flush方法，刷入文件缓存。\\n\\n    b. 文件缓存。日志文件存储日志内容，调用upload方法上传oss。\\n\\n    c. oss存储。日志文件或其他文件或图片上报最终上传到oss。\\n\\n### 使用方法\\n\\n1. 初始化传入context，并设置oss参数\\n\\n```java\\nBmLog.getInstance().init(context);\\n\\nBmLog.getInstance().setOssConfig(xxxx);\\n```\\n\\n2. 写入日志或图片或文件\\n\\n```java\\nBmLog.getInstance().push(\\\"TAG\\\", \\\"LOG\\\");\\n```\\n\\n3. upload主动上传oss\\n\\n```java\\nBmLog.getInstance().upload();\\n```\",\"n\":0.162}}},{\"i\":16,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"云学习\\\"\\ncover: xes/xes_cloudlearning.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"学而思云学习\\\"\\ndatePublished: \\\"2018-05-29 10:22:31\\\"\\ndateModified: \\\"2018-05-29 10:22:31\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - 组件化\\n---\\n\\n学而思云学习，包含在线答题，实时批改，错题订正，金币激励等。\\n\\n---\\n\\n#### 技术特点\\n\\n1. 使用Java语言开发。\\n\\n2. 使用ARouter实现组件化开发。组件可单独运行、调试。\\n\\n3. EventBus实现组件间通讯。\\n\\n4. 使用OkHttp作为网络请求框架。\\n\\n5. UI框架基于MessUi。\",\"n\":0.213}}},{\"i\":17,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"优优小班-课件容器\\\"\\ncover: banma/courseware_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"优优小班H5课件容器\\\"\\ndatePublished: \\\"2020-04-01 14:27:18\\\"\\ndateModified: \\\"2020-04-01 14:27:18\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - Hybrid\\n  - 架构\\n---\\n\\n课件容器是一个用于**windows、Android、iOS、H5端**加载和控制**cocos游戏、ppt文档、h5课件、普通图片文档**的中间层。\\n\\n---\\n\\n### 架构\\n\\n![架构设计](./banma/courseware_arch.jpg)\\n\\n- 课件容器整体使用React开发，运行在各个端的webview或者iframe中\\n\\n- AppSocket处理与各端的双向通信问题\\n\\n- RoomSdk作为课件容器的sdk，供各类型课件的wb（白板）调用\\n\\n- 每种类型的课件有自己的wb（白板）实现类，在这里处理课件规范，并与课件双向通信\\n\\n### 为什么需要？\\n\\n课件需要呈现的端较多，研发课件的时候需要考虑如何去和每个端交互。\\n\\n端要支持的课件类型也很多，端研发的时候也要考虑每种类型的课件该如何处理。\\n\\n所以研发一个中间层：这个中间层解决与各个端的通信问题，统一交互规范；这个中间层需要支持各个类型课件，处理每种课件的交互方式，抹平差异，统一接口到端。\\n也就是课件容器。\\n\\n### 项目价值\\n\\n1. 端研发不需要关心课件是什么，只需要：*a. 提供原生能力的api以供课件调用；b. 根据规范调用api操作课件。*\\n\\n2. 各个课件研发不需要关心运行在哪里，只需要：*a.根据规范实现接口，实现课件控制；b. 调用原生能力api实现自己的需求。*\\n\\n3. 后续如果想新增端、或者支持新的课件类型，不需要修改任何端、任何课件，只需要在**课件容器**中修改即可。\",\"n\":0.18}}},{\"i\":18,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"深杨跨境电商\\\"\\ncover: shenyang/cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"深杨跨境电商是一个招商小程序\\\"\\ndatePublished: \\\"2022-03-25 16:30:20\\\"\\ndateModified: \\\"2022-03-25 16:30:20\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 小程序\\n  - 云开发\\n  - 后端\\n  - serverless\\n---\\n\\n**深杨跨境电商**是一个招商小程序。\\n\\n---\\n\\n### 技术实现\\n\\n1. 使用微信开发者工具开发。\\n\\n2. 使用微信官方语言js、wxss、wxml开发。\\n\\n3. 后端使用腾讯云开发，serverless，接口使用云函数，db使用云数据库。\\n\\n### 截图\\n\\n![添加商品](./shenyang/mine_add.jpg)\\n![入住信息](./shenyang/mine_info.jpg)\\n![商家入驻](./shenyang/company.jpg)\\n![个人入驻](./shenyang/individual.jpg)\",\"n\":0.209}}},{\"i\":19,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"天天花园\\\"\\ncover: dailygarden/cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"天天花园是一款种花网赚类休闲游戏\\\"\\ndatePublished: \\\"2021-07-09 10:18:23\\\"\\ndateModified: \\\"2021-07-09 10:18:23\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - Unity\\n  - Android端\\n  - Java\\n  - 游戏\\n---\\n\\n天天花园是一款种花网赚类休闲游戏。\\n\\n---\\n\\n### 主要功能\\n\\n- 种花玩法，为花浇水、投入阳光。一定时间后可升级花。不断升级得现金奖励。\\n\\n- 累计经验值可提升王冠等级，升级后可得现金奖励。\\n\\n- 现金转盘等其他玩法。\\n\\n- 现金奖励累积到一定程度可以提现。支持微信支付。\\n\\n- app内会出现开屏广告、插屏广告、激励广告。\\n\\n### 我的职责\\n\\n1. 负责项目研发。\\n\\n2. 负责Android端的开发。\\n\\n3. 负责部分unity游戏内容的开发。\\n\\n4. 接入Gromore sdk广告sdk，实现广告播放逻辑。\\n\\n### 技术实现\\n\\n1. 游戏本体使用unity开发，支持热更新。\\n\\n2. Android端使用原生开发。包含开屏页、隐私协议、设备权限、开屏广告、防沉迷认证、检查更新、微信登录等。\\n\\n3. unity导出资源后，在Android容器中运行，在隐私等条款弹窗结束后，合适的时机初始化。\\n\\n4. unity点击提现，调用Android暴露的接口，唤起微信支付sdk。\\n\\n5. 广告部分接入Gromore。\\n\\n### 截图\\n\\n![](./dailygarden/garden.jpg)\\n![](./dailygarden/plants.jpg)\\n![](./dailygarden/task.jpg)\",\"n\":0.164}}},{\"i\":20,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"和平守护者\\\"\\ncover: defender/cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"和平守护者\\\"\\ndatePublished: \\\"2021-09-03 10:49:39\\\"\\ndateModified: \\\"2021-09-03 10:49:39\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 跨平台\\n  - Android端\\n  - iOS端\\n  - Flutter\\n  - dart\\n  - 游戏\\n  - Koa\\n  - Node.js\\n---\\n\\nFlutter制作的跨平台小游戏。通过点击天空来的陨石来保护家园。\\n\\n---\\n\\n### 技术实现\\n\\n1. 使用flutter开发，material主题。\\n\\n2. 背景音乐使用audioPlayer。\\n\\n3. 动画使用AnimationController。\\n\\n4. server端使用koa2框架开发接口，mysql数据库。\\n\\n### 截图\\n\\n![](./defender/home.jpg)\\n![](./defender/intro.jpg)\\n![](./defender/game.jpg)\",\"n\":0.177}}},{\"i\":21,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"dmp作业开发后台\\\"\\ncover: lixiang/dmp.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"理想汽车大数据作业开发平台\\\"\\ndatePublished: \\\"2023-01-09 08:44:38\\\"\\ndateModified: \\\"2023-01-09 08:44:38\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - 微前端\\n  - 模块联邦\\n---\\n\\n理想汽车大数据作业开发平台，目标用户是大数据工程师，通过在线编辑sparksql、hive等作业的代码，参与到后续的调度等流程中。\\n\\n### 主要功能\\n\\n- 支持sparksql、hive、shell、sparkJar等类型的作业，在编辑器中在线编辑、测试、调试并实时显示日志。\\n\\n- 支持各类型作业编辑作业信息、调度信息、查看历史版本、发布上线。\\n\\n- 支持其他业务如数据调度、数据查询等提供的组件，显示在内容区的某个tab下。\\n\\n### 技术特点\\n\\n- 基于React、craco开发。\\n\\n- 项目中使用到的很多组件来自于公共组件、或其他项目中的组件。通过使用module federation方案实现组件共享，页面微前端。\\n\\n- 作业开发页面，使用mosaic组件，实现类似于vscode的交互，页面元素分区域、可拖动、可隐藏。\\n\\n- 作业内容区域，需要展示各种标签页，这些标签页除了作业开发内的组件，通过mf方案，可以加载其他项目提供的组件。\\n\\n- 所有的tab相关数据都在本地存储，使用zustand实现全局workbench状态共享，针对作业的任何信息编辑都是编辑状态。\\n\\n- 使用rxdb实现本地数据库（原来使用的是localStorage），zustand的变化也会延迟同步到rxdb中。\\n\\n- 使用monaco实现编辑器部分，并添加了sparksql、log等语言的语法支持、高亮、错误提示等。并支持语言服务懒加载。\\n\\n- 使用ramda函数式编程规范。\",\"n\":0.177}}},{\"i\":22,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"袋鼠小班后台系统\\\"\\ncover: banma/dsxb_back_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"袋鼠小班后台系统\\\"\\ndatePublished: \\\"2019-04-15 16:20:27\\\"\\ndateModified: \\\"2019-04-15 16:20:27\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - Vue2\\n  - ElementUI\\n---\\n\\n袋鼠小班/优优小班后台管理系统。包括课程、课堂、班级、课时、订单、素材、转介绍、团购等等。\\n\\n---\\n\\n### 我的职责\\n\\n1. 负责技术选型、框架搭建、一期项目开发。\\n\\n2. 后续部分功能维护。\\n\\n3. 团队管理。\\n\\n### 技术点\\n\\n1. 基于webpack、vue2\\n\\n2. axios请求框架\\n\\n3. echarts图表绘制\\n\\n4. katex数学公式绘制\\n\\n5. lottie播放动效\\n\\n6. quill富文本编辑\\n\\n### 截图\\n\\n![登录](./banma/dsxb_back_login.png)\\n\\n![素材管理](./banma/dsxb_back_content.png)\",\"n\":0.189}}},{\"i\":23,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"袋鼠小班\\\"\\ncover: banma/dsxb_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"K12教育直播课产品\\\"\\ndatePublished: \\\"2019-05-08 09:43:48\\\"\\ndateModified: \\\"2019-05-08 09:43:48\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - iOS端\\n  - Windows端\\n  - Hybrid\\n  - React\\n  - 组件化\\n---\\n\\n袋鼠小班是K12教育直播课产品。包含学生端和教师端。\\n\\n学生端为上课端，包含登录、课表、直播课堂页等。支持Android、iphone、ipad、Windows。\\n\\n教师端为授课端，包含登录、课程计划、直播课堂页、备课等。支持Windows。\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n1. 老师查看自己的课程计划，提前进入课堂备课，到点进入课堂授课。\\n\\n2. 学生查看自己的课表，到点可以进入课堂上课。\\n\\n3. 课堂形式支持1vs16的小班课，也支持大班课，大班课最多订阅16位学生的视频流。\\n\\n4. 老师支持所有课堂操作，包括控制学生音视频流静音关闭开启等、拖动学生上下台、发送奖杯、计时器、答题器、播放/切换课件、播放动画、允许学生操作课件、允许玩游戏等等。\\n\\n5. 学生端支持全部操作和组件的展示，支持部分组件的交互如答题器、玩游戏课件等等。\\n\\n6. 课件支持cocos课件、答题课件、其他h5课件、图片、ppt、word/pdf文档、音频课件、视频课件。\\n\\n7. 监课端为web端，可以支持查看课堂，具有全部的操作权限。\\n\\n### 我的职责\\n\\n1. 负责Android学生端、Windows学生端/教师端的开发工作。\\n\\n2. 负责三方音视频云服务的技术选型和技术对接工作。\\n\\n3. 项目中重难点技术方案的设计：\\n\\n    - 复杂交互组件答题器的设计。\\n    - 发奖杯逻辑设计。\\n    - 游戏课件交互规范。\\n    - 游戏课件交互蒙层设计。\\n    - 性能优化：学生音视频二路流优化。\\n    - 等等。\\n\\n4. 负责开发团队的管理。\\n\\n### 技术实现\\n\\n1. Android端基于Java、MessUi、Retrofit等。\\n\\n2. Windows端基于Qt开发，套课web页面，核心功能为web开发，基于React。\\n\\n3. iOS端基于oc、pod。\\n\\n4. 学生/教师音视频相互订阅、流控制、信令服务使用talkcloud sdk。\\n\\n5. 直播课堂主要使用EventBus接收信令事件，并发送到各个组件。\\n\\n### 截图\\n\\n![学生手机端课表](./banma/xb_course_m.jpg)\\n![学生手机端课堂](./banma/xb_class_m.jpg)\\n![教师端登录页](./banma/xb_login.jpg)\\n![教师端课程计划](./banma/xb_course_plan.jpg)\\n![教师端Windows端课堂](./banma/xb_class_windows.jpg)\\n![教师端画笔工具](./banma/xb_wb.jpg)\",\"n\":0.127}}},{\"i\":24,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"DV试验上位机\\\"\\ncover: lixiang/dveol_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"理想汽车DV试验上位机\\\"\\ndatePublished: \\\"2021-10-14 17:57:09\\\"\\ndateModified: \\\"2021-10-14 17:57:09\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - Electron\\n  - Node.js\\n  - Vue3\\n  - ElementUI\\n  - 前端\\n  - Windows端\\n  - 跨平台\\n  - Vite\\n---\\n\\nDV试验上位机是用于车机设备运行硬件测试的windows端应用。试验台通过mesh网络搜索车机设备，对车机设备上的硬件组件测试项进行串联/并联测试。\\n\\n---\\n\\n### 技术点\\n\\n1. 桌面端使用electron、Node.js实现跨平台开发。支持windows、linux、mac。\\n\\n2. 使用electron-forge打包应用程序。\\n\\n3. ui层使用vue3、vite、element-ui开发，打包静态应用后放入www目录。\\n\\n4. 遵循electron最新[process sandbox规则](https://www.electronjs.org/docs/latest/tutorial/sandbox)，防止安全性问题。ui与node层通过IPC通信。*（ui层无法访问node.js的api，preload.js暴露对象到ui层window，preload.js通过IpcRender与IpcMain进行通信）*\\n\\n5. 上位机通过limesh搜寻、连接、操作设备。\\n\\n6. node层通过crashReporter、log4j采集本地cpu、memory日志做性能分析。\\n\\n7. ui层使用el-table实现表格布局形式的测试界面。\\n\\n8. ui层使用html2canvas实现定期截屏测试项状态。\\n\\n### 截图\\n\\n![连接设备](./lixiang/dveol_home.jpg)\\n![测试项测试](./lixiang/dveol_test.jpg)\",\"n\":0.164}}},{\"i\":25,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"electron-template\\\"\\ncover: images/electron-template-cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"electron启动脚手架\\\"\\ndatePublished: \\\"2021-12-01 09:03:56\\\"\\ndateModified: \\\"2021-12-01 09:03:56\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Node.js\\n  - Electron\\n  - 脚手架\\n  - 开源\\n  - Vue3\\n  - Vite\\n  - 跨平台\\n---\\n\\n使用electron开发桌面端应用的启动模版。这个项目包含了桌面端代码和web端代码，其中桌面端有两个窗口，web端包含两个页面。\\n\\ngitee仓库：https://gitee.com/missmess/electron-template\\n\\n---\\n\\n## 已包含功能\\n\\n### 桌面端\\n\\n- 已包含基础菜单配置：`src/core/appMenu`\\n- 使用windowManager管理窗口，清晰易用，易配置：`src/WindowManifest`\\n- 默认包含主窗口和一个设置窗口，满足80%的桌面端场景。\\n- 支持webUI的本地/远程渲染模式，一键配置：`forge.config.js`\\n- 默认启用沙盒模式，保护程序安全。\\n- 已封装常用原生api，并导出到web端。\\n\\n### web端\\n\\n- 默认包含一个Vue3 + Element Plus的web项目\\n- 包含了一个首页和一个设置页的基础ui\\n- 已封装底层原生api，web端可直接引入调用：`@/src/NativeService`\\n\\n## 代码结构\\n\\nlibs - 存放三方js库\\n\\npkg - 打包相关icon资源等\\n\\nsrc - 桌面端主要代码\\n\\nwebapps - 存放webUI项目，可以有多个\\n\\nwww - 打包后的webUI代码，程序会加载这个目录下的html\\n\\nforge.config.js - [forge的配置文件，包括打包、编译插件等](https://www.electronforge.io/)\\n\\n## 如何使用\\n\\n### 调试\\n\\n1. 安装npm包。\\n\\n```shell\\n# 桌面端安装npm包\\nyarn\\n# web端安装npm包\\ncd webapps/vue3-webapp && yarn\\n```\\n\\n2. 确保`forge.config.js`中，启用的是远程渲染模式\\n\\n```javascript\\nmodule.exports = {\\n  envConfig: {\\n    localRender: false,\\n    ...\\n  },\\n  ...\\n}\\n```\\n\\n3. 启动webUI。\\n\\n```shell\\nyarn webDev\\n```\\n\\n4. 打开应用窗口\\n\\n```shell\\nyarn start\\n```\\n\\n### 打包\\n\\n1. 确保`forge.config.js`中，启用的是本地渲染模式\\n\\n```javascript\\nmodule.exports = {\\n  envConfig: {\\n    localRender: true,\\n    ...\\n  },\\n  ...\\n}\\n```\\n\\n2. 打包webUI到`/www`目录。\\n\\n```shell\\nyarn webBuild\\n```\\n\\n3. 打包应用程序。（在mac上运行命令打包mac、在windows上运行命令打包windows）\\n\\n```shell\\nyarn make\\n```\\n\\n## 其他说明\\n\\n1. 如果不想把webUI打包到桌面应用中，或者UI频繁更新不想每次都打包。可以直接启用远程渲染模式，并修改baseUrl为自己的webUI访问地址。\\n\\n> 注意这种方式不适合离线应用或者对FCP要求高的，因为远程渲染依赖网络，需要下载资源的时间。常规应用最好是离线加载，实现一键更新功能。\\n\\n2. 注意主进程和渲染进程是隔离的，主进程和渲染进程通信使用`ipcMain`和`ipcRender`。`preload`脚本运行在渲染进程，并可以访问`Node.js`api。\\n\\n## 截图\\n\\n![首页](./images/electron-template.jpg)\",\"n\":0.103}}},{\"i\":26,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"函数计算平台\\\"\\ncover: lixiang/faas_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"理想汽车函数计算/边缘计算平台\\\"\\ndatePublished: \\\"2022-01-30 11:22:01\\\"\\ndateModified: \\\"2022-01-30 11:22:01\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - Antd\\n  - Node.js\\n  - Vite\\n---\\n\\n函数计算平台的目标用户是车机系统研发人员，通过faas可实现远程在车机执行任意代码。函数计算平台包含**车机faas引擎**和**faas管理平台**。**车机faa引擎务**运行在车机系统中，用于通过mesh网络连接云端、下载和更新函数、运行函数进行边缘计算等。**faas管理平台**运行在云端，用于编辑函数代码、配置函数运行规则、通过mesh网络下发到车机faas引擎等。\\n\\n> faas服务为原limesh六大服务（uploader、downloader、configurator、vss、job、topic）外的第7个服务。\\n\\n---\\n\\n### faas管理平台功能\\n\\n1. 函数管理。包含函数列表crud、函数运行环境和规则编辑、函数代码编辑、函数在线测试、查看运行日志、函数版本管理、函数历史代码对比、函数运行监控、函数全量/批量下发、函数手动触发等。\\n\\n2. 函数操作记录。\\n\\n3. faas引擎版本管理、车机引擎信息查询等。\\n\\n### 车机faas引擎功能\\n\\n1. 引擎支持通过车机热更新服务更新、重启。\\n\\n2. 通过veh-job，获取函数、更新函数代码和函数规则，并将函数注册到引擎中。\\n\\n3. 根据函数规则或veh-job的主动通知，运行函数。\\n\\n4. 引擎提供基础原生能力供函数调用（如读写车机其他服务信号数据、读写车机本地数据库等，根据业务需求不断开放）。\\n\\n5. 引擎负责函数的性能监控并上报数据到云端。\\n\\n### 我的职责\\n\\n1. 负责管理平台的搭建，架构，开发工作。\\n\\n2. 负责faas引擎的部分功能开发。\\n\\n### 技术特点\\n\\n1. 函数平台基于React、vite、Ant-Design开发。\\n\\n2. 函数编辑使用monaco实现。基于不同语言提供语法高亮、错误提示、和原生api语法提示等。\\n\\n3. 函数代码测试使用websocket对接server端，实时展示测试日志。\\n\\n4. 函数代码比对使用monaco DiffEditor。\\n\\n5. 监控数据图表显示使用echarts。\\n\\n6. faas引擎使用Node.js开发。\\n\\n### 截图\\n\\n![函数在线编辑](./lixiang/faas_code.jpg)\",\"n\":0.152}}},{\"i\":27,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"FaceRecognition【在框识别】\\\"\\ncover: images/facerecog_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"学生人脸在框识别\\\"\\ndatePublished: \\\"2020-10-09 17:05:11\\\"\\ndateModified: \\\"2020-10-09 17:05:11\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Android端\\n  - kotlin\\n  - AI\\n  - 库\\n  - 图像处理\\n---\\n\\n识别图片中是否包含正面面对屏幕的人脸。\\n\\n### 技术实现\\n\\n1. kotlin开发android library\\n\\n2. opencv处理图片，转矩阵/转换颜色空间等\\n\\n3. mtcnn模型pnet、rnet、onet依次预测，nms后处理\\n\\n4. 返回结果boxes\\n\\n5. 利用aspectj插桩对模型推理做耗时检测及优化\\n\\n### 如何使用\\n\\n在app module中引入库\\n\\n```\\n// app下build.gradle\\nimplementation project(\\\":facerecognition\\\")\\n```\\n\\n初始化`MtcnnFaceDetector`，传入context、config、callback三个参数\\n\\n```kotlin\\nlateinit var mtcnn: MtcnnFaceDetector\\n...\\nmtcnn = MtcnnFaceDetector(this, MtcnnFaceDetector.Config(\\n    assets2File(\\\"pnet_1106.pt\\\"),\\n    assets2File(\\\"rnet_1106.pt\\\"),\\n    assets2File(\\\"onet_1106.pt\\\"),\\n    0.6f, 0.7f, 0.7f, 20\\n), object : MtcnnFaceDetector.Callback {\\n    override fun p(boxes: Vector<Box>) {\\n    }\\n\\n    override fun r(boxes: Vector<Box>) {\\n    }\\n\\n    override fun o(boxes: Vector<Box>) {\\n    }\\n})\\n```\\n\\n执行预测\\n\\n```kotlin\\nval boxes = mtcnn.detectFace(imgRes)\\n```\",\"n\":0.12}}},{\"i\":28,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"智能练习小程序\\\"\\ncover: xes/mini_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"智能练习小程序\\\"\\ndatePublished: \\\"2018-12-27 08:33:21\\\"\\ndateModified: \\\"2018-12-27 08:33:21\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 小程序\\n---\\n\\n云学习智能练习小程序（阿来爱做题）。是学生在线做题，提交作业，老师在线判题反馈，分析做题情况的小程序。\\n\\n### 技术点\\n\\n1. 使用原生微信小程序语言开发。\\n\\n2. 复杂点是小程序canvas上绘图，贴图，画笔，以及天然的原生组件层级bug。\\n\\n3. 使用wxs在渲染层执行运算，减少与逻辑层通信。\\n\\n### 截图\\n\\n![选角色](./xes/mini_choose.jpg)\",\"n\":0.243}}},{\"i\":29,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"一文详解前端工程化基础架构\\\"\\ncover: ../static/assets/fe_infra.jpeg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"详细介绍完整的前端工程化建设所包含的工具、模块、框架、库\\\"\\ndatePublished: \\\"2023-01-10 22:20:40\\\"\\ndateModified: \\\"2023-01-10 22:20:40\\\"\\nslug: \\\"fe-infra\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 前端\\n  - 架构\\n  - 微前端\\n  - 低代码\\n  - 模块联邦\\n  - 组件化\\n---\\n\\n在前端应用开发的整个生命周期过程中，离不开许许多多的框架、库、模块和工具。正是有了这一系列的基础设施，才能大大滴提升程序员们的开发效率、代码质量和可维护性。我们把这一系列基础设施，统一规划为`前端工程化`的范畴。在这里，我将按照生命周期的顺序详细介绍一下前端工程化的各个流程及其内容：\\n\\n<details>\\n<summary style=\\\"margin: 16px 0; color: var(--color-primary)\\\">本文目录</summary>\\n\\n- [版本控制和代码托管](#版本控制和代码托管)\\n- [包管理仓库](#包管理仓库)\\n- [多包管理工具](#多包管理工具)\\n- [构建工具](#构建工具)\\n- [渐进式开发框架](#渐进式开发框架)\\n- [UI组件库](#ui组件库)\\n- [项目启动脚手架](#项目启动脚手架)\\n- [模块化和组件化](#模块化和组件化)\\n- [从微前端到微模块](#从微前端到微模块)\\n- [mock和API管理](#mock和-api管理)\\n- [低代码](#低代码)\\n- [响应式设计](#响应式设计)\\n- [代码规范和静态检查](#代码规范和静态检查)\\n- [自动化测试](#自动化测试)\\n- [性能检测和优化](#性能检测和优化)\\n- [CI/CD](#ci-cd)\\n- [生产部署](#生产部署)\\n- [错误监控](#错误监控)\\n\\n</details>\\n\\n### 版本控制和代码托管\\n\\n版本控制和代码托管是实现开发的基石。目前公司内部最常用的组合是`git + gitlab`，而开源或个人首选的组合是`git + github`。\\n\\n版本控制需要提前定义好`分支规范` + `commit message规范`。`分支规范`是指使用的分支模型。比如常用的`master/develop/feature/hotfix`模型，或者支持多环境的`main/test/ontest/pre`模型。\\n\\n`commit规范`是针对代码提交的规范，包括commit频次、粒度、message的规范控制。\\n\\n> gitlab是开源代码管理工具，如果公司为了安全性可以考虑部署gitlab到自有服务器上，参考[gitlab安装帮助](https://about.gitlab.com/install/)。\\n\\n### 包管理仓库\\n\\n最流行最常用的公有仓库是[npm](https://www.npmjs.com/)。\\n\\n> 往往很多公司都希望搭建自己私有的npm仓库。目前很成熟的开源方案是[cnpmcore](https://github.com/cnpm/cnpmcore)，可以直接部署到自己公司的服务器上。\\n\\n### 多包管理工具\\n\\n公司中型以上的业务，或者一些基础框架，工具库等，都不会只有一个package。所以就存在了多个package之间，相互依赖的情况出现。这时候各个模块之间的依赖管理、调试等都会出现一些挑战。多包管理分为两种方式：`multirepo`和`monorepo`。\\n\\n**multirepo**\\n\\n`multirepo`就是将每个模块都单独放在自己的仓库内。独立管理、开发、测试、发布。最常见的方式就是`git+npm`，通过npm安装依赖的包，每个包都使用git管理。如果希望调试它的子依赖库的变更，那么可以通过`npm link`的方式将本地的子依赖库链接到主仓库上。\\n\\n另一个方案就是`git submodule`，由git提供。多个库之间仍然是独立管理的。但是通过`git submodule`将多个子仓库嵌入到主仓库中。可以直接在主仓库中查看各个子模块的代码，可以快速更新子模块。\\n\\n**monorepo**\\n\\n`monorepo`（单仓库）就是将多个模块都放在一个代码仓库里，使用同一个版本控制工具管理。它可以在一个仓库管理多个库，但是如果仓库越来越大，也可能导致编译性能下降。\\n\\n常用的一个方案是[Lerna](https://lerna.js.org/)，它是一个monorepo的管理工具。可以统一或分别管理多个包的版本和依赖。可以通过依赖提升和共享依赖来减少多包之间相同的依赖安装和更新（减少磁盘空间占用）。\\n\\n具体需要使用`multirepo`还是`monorepo`，需要根据实际情况来选择。一般来看，`monorepo`适用于那些多包之间依赖关系比较复杂和紧密的项目，比如基础库（li-mesh的node包仓库，非常多的包，且联系紧密，依赖复杂）。对于那些模块比较独立的项目，那可能选择`multirepo`会更合适。\\n\\n### 构建工具\\n\\n构建工具是前端工程化的核心，它能自动化的处理前端应用开发过程中比较繁琐但又常见的任务。*包括但不限于图片优化、代码压缩、css兼容、代码分包、treeshake、打包编译、dev服务、环境变量。*\\n\\n常见的构建工具有：[Webpack](https://www.webpackjs.com/concepts/)、[Vite](https://cn.vitejs.dev/guide/)。\\n\\n### 渐进式开发框架\\n\\n现在最主流的SPA框架是[React](https://react.dev/)和[Vue](https://cn.vuejs.org/)。\\n\\n当然还有越来越多人使用的SSR应用框架[Next](https://nextjs.org/)和[Nuxt](https://www.nuxtjs.cn/)。\\n\\n构建博客或文档站点的SSG应用框架[Gatsby](https://www.gatsbyjs.com/)、[Hugo](https://gohugo.io/)。\\n\\n基于你的经验和偏好选择合适的开发框架，它们不会局限你的想象力。\\n\\n### UI组件库\\n\\n几乎所有的前端应用都需要用到`组件库`，大型的前端应用几乎都会有自己的组件库。UI组件库就是一系列可以复用和组合的UI组件的合集，它们一起构建出优秀、美观的用户界面。\\n\\n主流的**PC端UI组件库**包含[ElementUI](https://element-plus.org/zh-CN/)、[Ant-Design](https://ant-design.antgroup.com/index-cn)、[MaterialUI](https://mui.com/material-ui/all-components/)。\\n\\n其次，**移动端UI组件库**有[Vant](https://vant-ui.github.io/vant/#/zh-CN/home)、[VUX](https://doc.vux.li/zh-CN/)（常用于微信端页面）。\\n\\n另外，**小程序UI组件库**有[WeUI](https://weui.io/)、[Vant Weapp](https://vant-ui.github.io/vant-weapp/#/home)；**Uniapp UI组件库**有[FirstUI](https://doc.firstui.cn/docs/started.html)、[uView](https://uviewui.com/)。\\n\\nBy the way: css预编译库也是前端必不可少的工具之一，它极大地提升了css开发效率。主流css预编译库有：[Sass](https://www.sass.hk/)、[Less](https://lesscss.cn/)、[UnoCSS](https://unocss.dev/interactive/)、[WindiCss](https://windicss.org/)、[Styled-Components](https://styled-components.com/docs)（比较特殊，它是一个`css-in-js`库）。*你可以脱离UI组件库只使用CSS库，但通常都推荐一起使用提升效率。*\\n\\n> 自建UI组件库，可以clone开源组件库。如[Ant-Design代码库](https://github.com/ant-design/ant-design)，已包含组件源码及基于dumi的组件库网站。我们在开源基础上进行样式重构、新增业务组件等。\\n\\n### 项目启动脚手架\\n\\n选好了构建工具和开发框架，然后就可以从`启动脚手架`开始你的编码生活（你也可以不使用任何启动脚手架，但是仅限于学习，工作中请不要这么做）。常用的开源启动脚手架：\\n\\n- [vite-reactts-antd-redux-starter](https://github.com/missmess/vite-reactts-antd-redux-starter/tree/master)：后台应用的话强烈推荐（是我做的😄），集成了常用的全生态三方库，并且已包含了后台基础页面布局。\\n- [Vue Cli](https://cli.vuejs.org/zh/guide/)：官方出品Vue2 + webpack启动脚手架（已经停止维护）。\\n- [create-vue](https://github.com/vuejs/create-vue)：新版cli工具，基于Vite，支持Vue2/Vue3。包含的[启动模版](https://github.com/vitejs/vite/tree/main/packages/create-vite)也很多。\\n- [CRA](https://create-react-app.dev/docs/getting-started)（create-react-app）：React官方推荐（but作者支持Ukraine）。支持在社区自己找[启动模版](https://www.npmjs.com/search?q=cra-template-*)。通常搭配[craco](https://craco.js.org/docs/getting-started/)\\n- [Umi](https://umijs.org/docs/introduce/introduce)：企业级应用框架，使用React。\\n- [Ice](https://v3.ice.work/docs/guide/about)：与`Umi`比较类似，使用React。\\n- [awesome-vite](https://github.com/vitejs/awesome-vite#templates)：一些Vite的各场景启动模版。\\n- 或者在github找到不错的模版，直接使用[degit](https://github.com/Rich-Harris/degit)工具down下来。\\n\\n> 前端团队可以自己搭建自己的启动脚手架，包括`cli工具`和`脚手架模版`。`cli工具`是为了通过命令行的形式配置`脚手架模版`里的哪些模块放到最终生成的项目中。`cli工具`推荐直接使用node脚本开发。\\n\\n### 模块化和组件化\\n\\n**模块化**\\n\\n模块化开发时，尽量将不同功能拆分成独立的模块和文件。其他模块或文件使用时，通过import（ES6）和require（CommonJs）导入。\\n\\n**组件化**\\n\\n组件化强调的是，使用Vue、React等框架开发时，页面中相对独立的的一部分UI及其对应的逻辑代码，一起作为一个独立组件抽出，以达到代码复用和易维护性的优势。\\n\\n模块化和组件化开发方式，是前端工程化不可或缺的一部分。\\n\\n### 从微前端到微模块\\n\\n**微前端**\\n\\n微前端就是将一个大型应用拆分成一个一个小型的、且可独立运行/调试/发布的前端应用的技术。类似于后端的`微服务`、Android端的`组件化方案`。微前端架构中，各个小型应用（称为`微应用`）是松耦合的，通常会有一个`主应用`和N个`微应用`，相互之间通过框架或者[中间件](/limesh开放平台#技术点)交互。\\n\\n常见的微前端框架有[single-spa](https://single-spa.js.org/docs/getting-started-overview)、[qiankun](https://qiankun.umijs.org/)。qiankun比较成熟，api也比较多。\\n\\n> nextjs官方也有自己的微前端形式：[Multi Zones](https://nextjs.org/docs/pages/building-your-application/deploying/multi-zones)，还没有了解过。\\n\\n**微模块**\\n\\n[Module Federation](https://webpack.js.org/concepts/module-federation/)带来了一个更细粒度的微前端架构形式，在此之前的微前端架构解决了页面级别的独立和共享。MF方案真正的将这种独立和共享做到了模块级别，就像是引入一个js包。不过在现有项目上使用MF方案需要自己去处理一系列问题，包括：\\n1. 需要花些时间处理shared公共依赖；\\n2. 远程模块的版本控制是一个问题，它并不像一个npm包你可以选择升级，也明确知道它的改动。有时候远程模块改动了你可能不知道，运行时才抛出一个异常；\\n3. 依赖模块貌似没发tree-shake，比如依赖了一个lodash，那就得加载整个lodash。\\n4. ...\\n\\n> [hel-micro](https://tencent.github.io/hel/)是以sdk的形式支持MF技术的一个新的方案，官方宣传的特性是**模块联邦 sdk 化、免构建、热更新、工具链无关**。有机会可以试一试。\\n\\n> 截止到2023年1月，调研了一下Vite + React上使用MF方案，虽然有[vite-plugin-federation](https://github.com/originjs/vite-plugin-federation)插件，但实际测试有无法逾越的问题存在。\\n\\n### mock和API管理\\n\\n**mock**\\n\\n`mock`用于开发阶段，后端接口还无法提供数据时，或developer想要检查一下异常数据场景时，可以使用一些mock工具，让自己的业务组件代码只需少量或者无修改就能获取到这些假数据。前端常用的mock手段有以下几种：\\n\\n1. 在代码中mock：代表性的mock库是[mockjs](https://github.com/nuysoft/Mock/wiki/Getting-Started)。可以在项目中直接mock各种接口的返回数据，还能拦截XHR和fetch请求，返回你定义的数据。\\n\\n2. 浏览器插件：[Just Mock](https://just-mock.vercel.app/guide/getting-started.html)是一个chrome插件，可以在访问目标网址时，配置自定义的请求规则，修改response的返回数据。可以一键开启关闭。\\n\\n3. 在线mock网站：[JSONPlaceholder](https://jsonplaceholder.typicode.com/)是一个在线的mock数据网站，可以直接访问预定的接口。缺点是接口比较少，不能自定义。\\n\\n**API管理**\\n\\n`API管理`工具是开发阶段针对后端接口进行维护管理的工具，目标是为了提升前后端协作效率和减少扯皮。不过现在的`API管理工具`往往已经包含了`mock`能力。\\n\\n[Postman](https://www.postman.com/)是老牌的`API管理`软件，支持接口管理、分组、环境变量、调试、mock、脚本测试、共享等等。功能很完善。\\n\\n[Apifox](https://app.apifox.com/)是在线的`API管理`应用，功能和`Postman`对齐。\\n\\n[Swagger](https://swagger.io/)是java可用，优点是从代码注解直接生成。对于java开发者很方便。\\n\\nBTW：`Node.js`的`Express`框架可以用`swagger-jsdoc` + `swagger-ui-express`实现上面`Swagger`的功能。\\n\\n> 公司内部也可以创建自己的API管理平台，功能对标`Apifox`产品。可以附加一些额外的实用功能，比如各接口定义一键导出`typescript`定义文件。*（前端非常重复且耗时的一个工作就是写ts）*\\n\\n### 低代码\\n\\n低代码在前端领域的占比很大（而且只会越来越大），并且由于LLM的不断发展，低代码技术将会发生各种各样的新变革。它能很大程度上提升前端人员的开发效率。\\n\\n详细介绍了一下低代码：[低代码现状调研](/低代码现状调研)。\\n\\n> 比较推荐[Lowcode-Engine低代码平台](https://lowcode-engine.cn/)，实际使用后，完全可以满足商用产品和大型应用的部分重复性页面和简单页面，功能比较强大。但是相对的，配置也会繁琐很多。\\n\\n### 响应式设计\\n\\n一个优秀的前端应用必须能支持在不同屏幕下的页面展示体验。\\n\\n- 媒体查询\\n\\n    从css层处理的。在组件中，根据不同的设备屏幕大小来应用不同的css规则，来达到响应式的目标。\\n\\n- 路由页面组件适配\\n\\n    从逻辑层处理的。根据不同的屏幕大小，同一路由地址，使用不同的组件来渲染。适用于移动端页面和PC端页面相差较大的场景。\\n\\n### 代码规范和静态检查\\n\\n- **代码规范文档**：包括代码风格、‌命名规范等，目的是提高代码的可读性和可维护性。\\n\\n- **使用ESLint**：执行代码静态检查的一个工具，自动检测代码是否符合预设的代码规范。\\n\\n- **使用Prettier**：自动格式化代码，让团队保持一致的代码风格。\\n\\n### 自动化测试\\n\\n**单元测试**\\n\\n单元测试框架用于对组件或模块执行单元测试，确保它们的功能是没有bug的。单元测试可以使用[jest](https://github.com/jestjs/jest)，dom相关状态测试使用[jest-dom](https://github.com/testing-library/jest-dom)、React组件测试使用[@testing-library/react](https://github.com/testing-library/react-testing-library#readme)。\\n\\n**E2E测试**\\n\\n[Cypress](https://github.com/cypress-io/cypress)是一个前端E2E（end-to-end，端到端）测试工具。\\n\\n### 性能检测和优化\\n\\ntoC的应用几乎无法避开性能这个话题。性能不好的网站将会大大降低用户体验。\\n\\n开发阶段：常用的性能检测工具有`chrome devtools`、`lighthouse`、`vue devtools`、`react profiler`等等。\\n\\n生产阶段：[performance API](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance)是浏览器内置的性能数据工具。[web-vitals](https://github.com/GoogleChrome/web-vitals)是基于performance的out-of-box库，可快速获取FCP、LCP、FID、CLS等常用性能指标并上报。\\n\\n**性能优化**\\n\\n性能优化方案是一个复杂的专题，跨域很多个纬度，大致的内容包含：\\n\\n1. 组件懒加载、图片懒加载：\\n\\n    - 只有在需要时才加载组件或图片，减少初始加载时间。\\n    - 使用Intersection Observer API实现懒加载。\\n\\n2. 超长列表使用虚拟列表技术：\\n\\n    - 对于超长列表，使用虚拟列表技术（如React Virtualized）只渲染可见区域的元素，减少DOM节点数量。\\n\\n3. 合并资源减少HTTP请求次数：\\n\\n    - 将多个CSS、JavaScript文件合并为一个文件，减少HTTP请求次数。\\n    - 使用工具如Webpack进行资源打包。\\n\\n4. 代码minify和gzip压缩：\\n\\n    - 使用工具如UglifyJS、Terser对JavaScript代码进行minify，减少文件大小。\\n    - 在服务器端配置gzip压缩，减少传输文件的大小。\\n\\n5. 图像优化：\\n\\n    - 使用现代图像格式如WebP，减少图像文件大小。\\n    - 使用图像压缩工具如TinyPNG。\\n\\n6. 缓存优化：\\n\\n    - 常用数据缓存到本地（如LocalStorage、IndexedDB），减少请求消耗。\\n    - 配置HTTP缓存（Cache-Control和Expires），减少重复请求。\\n\\n7. 使用CDN：\\n\\n    - 将静态资源存储到CDN，利用CDN的分布式节点加速资源加载。\\n\\n8. Service Worker：\\n\\n    - 使用Service Worker实现接口缓存和离线支持，提高应用的可靠性和性能。\\n\\n9. 服务器端渲染（SSR）和静态站点生成（SSG）：\\n\\n    - 使用SSR和SSG技术提升首屏渲染速度，减少白屏时间。\\n\\n10. HTTP/2和HTTP/3：\\n\\n    - 使用HTTP/2或HTTP/3协议，利用多路复用、头部压缩等特性提高传输效率。\\n\\n11. 减少重排和重绘：\\n\\n    - 优化CSS和JavaScript，减少不必要的DOM操作，避免频繁的重排和重绘。\\n\\n12. 异步加载和预加载：\\n\\n    - 使用async和defer属性异步加载JavaScript文件。\\n    - 使用`<link rel=\\\"preload\\\">`预加载关键资源。\\n\\n13. [Vue性能优化实践](https://cn.vuejs.org/guide/best-practices/performance.html)。\\n\\n14. [React性能优化指导](https://legacy.reactjs.org/docs/optimizing-performance.html)。\\n\\n> 通常一个大型项目内部，可以自己制作一个lightweight、用于线上的性能监控工具。监控一系列性能数据，并及时上报到`Sentry`。\\n\\n### CI/CD\\n\\nCI/CD即持续集成/持续部署。通过CI/CD工作流，能自动化的将开发人员提交的代码，进行编译、构建、检查、测试等环节，测试通过后自动部署到测试或生产环境中。\\n\\n通过开源工具[Travis-CI](https://www.travis-ci.com/)、[Jenkins](https://www.jenkins.io/)能方便实现CI/CD工作流。\\n\\n现在主流的代码托管仓库也都已经支持了CI/CD工作流。包括`github`、`gitee`、`gitlab`。\\n\\n### 生产部署\\n\\n前端应用最终是需要部署到服务器上，并且提供域名才能访问的。可以通过CI/CD或者手动部署。\\n\\n传统方式是公司购买自己的真实服务器，再通过内网部署应用到服务器上。目前大部分公司的主流方案是采用云服务器，即购买云服务厂商的服务器资源。再通过工具部署。\\n\\n对于个人网站或H5应用来说，部署的方案就更多一些。可以自己购买云服务器、购买带宽、安装nginx、安装jenkins、配置域名、配置https等等。\\n\\n此外，腾讯云提供的[云开发](https://cloud.tencent.com/document/product/876)服务可以更快速的完成前后端开发到部署上线，不需要买服务器和域名，以及处理一系列复杂的运维操作\\n\\n如果是静态站点，可以直接购买对象存储服务，将网站托管到对象存储服务里，并配置访问地址。市面上有很多免费的托管平台，比如[Netlify](https://app.netlify.com/)、[Github Pages](https://pages.github.com/)。\\n\\n> 很多公司会有自己的云资源管理平台。管理私有云、公有云资源。包括云主机、云存储、云数据库、域名服务等等。方便员工在线申请/编辑自己的应用所需要的云资源。\\n\\n### 错误监控\\n\\n错误监控就是收集应用在线上运行时发生的错误和异常。开源的错误监控工具有[Sentry](https://sentry.io/)。\\n\\n`Sentry`分为web界面和sdk。`Sentry`支持的sdk非常丰富，不仅仅支持前端技术栈。通常一个项目组或一个公司需要一个Sentry服务即可。web端界面可通过`docker`等部署到服务器上。\\n\\n### Ending\\n\\n前端工程化是一个复杂、重要、并且不断进化的技术课题，目的就是提升开发效率、提高质量和加强团队合作效率。随着技术的变迁、环境的变化，它包含的内容可能会发生翻天覆地的变化。我们要做的就是与时俱进，不断学习。\\n\",\"n\":0.073}}},{\"i\":30,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"智能练习小游戏\\\"\\ncover: xes/minigame_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"智能练习小游戏\\\"\\ndatePublished: \\\"2019-01-03 10:34:47\\\"\\ndateModified: \\\"2019-01-03 10:34:47\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 小游戏\\n  - 游戏\\n---\\n\\n智能练习小游戏（计算鸡大作战）。小一年级数学计算益智类小游戏。\\n通过选择正确答案让计算鸡飞得更高。\\n\\n### 技术点\\n\\n1. 原生微信小游戏开发。\\n\\n2. spine实现计算鸡的骨骼动画。\\n\\n3. 纯js实现游戏背景、云彩、主角等元素每一帧动画的计算。\\n\\n### 截图\\n\\n![首页](./xes/minigame_home.jpg)\",\"n\":0.229}}},{\"i\":31,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"Limesh开放平台\\\"\\ncover: lixiang/limesh_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"理想汽车Limesh开发者开放平台\\\"\\ndatePublished: \\\"2022-01-09 15:39:54\\\"\\ndateModified: \\\"2022-01-09 15:39:54\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - 微前端\\n  - 架构\\n  - Vite\\n---\\n\\nLi-Mesh开放平台的目标用户是使用Li-Mesh的开发者，在开放平台注册自己的应用后。可以在自己的应用授权范围内，接入Li-Mesh，使用该应用去设置Li-Mesh六大服务的资源、调用六大服务的能力、查询服务数据和操作记录等等。\\n\\n---\\n\\n### 我的职责\\n\\n1. 开放平台的架构设计、框架搭建，开发。\\n\\n2. 开放平台分开发者平台和管理员后台。\\n\\n3. 对接开发者平台和管理员后台的需求，并开发上线。\\n\\n### 技术点\\n\\n1. 和[车云服务系统](/车云服务系统)使用相同的架构设计。项目基于[vite-reactts-starter](/vite-reactts-starter)脚手架开发，基于qiankun实现微前端。\\n\\n2. 使用licar相同的样式规范。\\n\\n3. 使用redux在多个模块之间实现数据共享。\\n\\n4. 主应用和微应用、微应用和微应用之间的redux状态共享。使用了我自己开发的**appshare中间件**：即在任何一个应用中使用`useSharedState`获取的`state`，它是响应任何来源（包括当前应用，也包括其他应用）的变更的。同理，`setState`也是会触发其他应用的state变更。\\n\\n### 截图\\n\\n![开放平台首页](./lixiang/limesh_home.jpg)\\n![VSS path管理](./lixiang/limesh_vss.jpg)\",\"n\":0.18}}},{\"i\":32,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"车云服务系统\\\"\\ncover: lixiang/licar_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"理想汽车车辆云端管理平台\\\"\\ndatePublished: \\\"2021-10-21 09:00:03\\\"\\ndateModified: \\\"2021-10-21 09:00:03\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - 微前端\\n  - 架构\\n  - 后端\\n  - Node.js\\n  - 低代码\\n  - Vite\\n  - Koa\\n---\\n\\n车云服务系统（li-car）是车辆云端业务管理平台，包含车辆管理、车机应用配置管理、车控、分组管理、信号管理等几个大模块。产品目标是方便业务人员和开发人员在云端处理车辆相关的业务。\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n1. crud管理车型、车辆、根据车机号(vin)查询车辆。\\n\\n2. 车机应用管理，低代码形式编辑/发布车机应用配置，追溯历史版本，查看操作记录。\\n\\n3. 车辆分组、车辆信号管理。\\n\\n4. 远程车控、车云工具箱、审计。\\n\\n5. 车辆告警、行程、远程拍照。\\n\\n6. 平台菜单配置管理。\\n\\n7. 权限：角色菜单权限、角色数据权限管理。\\n\\n### 我的职责\\n\\n1. 车云服务系统web端架构设计，框架搭建。\\n\\n2. 业务需求对接、前端开发。\\n\\n3. 车云服务平台server端接口开发。（菜单、按钮、权限、服务转发等）\\n\\n### 技术实现\\n\\n1. 车云服务系统为微前端架构，分为veh-cloud（主应用）、licar-micro（子应用，车辆相关业务）、common-config（子应用，应用配置中心）。使用qiankun、[vite-qiankun-plugin](/vite-plugin-qiankun)实现。\\n\\n2. 主应用基于[vite-reactts-starter](/vite-reactts-starter)开发，包含基础外壳（顶部栏+菜单栏+内容区）。\\n\\n3. 路由菜单通过接口动态配置和获取，菜单路由页支持**内部组件、内部组件string path、ifame页、外链、子应用路径**\\n\\n    ```typescript\\n    export type RouteMenu = {\\n      name: string; // 名称，展示到菜单、面包屑位置\\n      path: string; // 路径，可填入http(s)链接或相对路径，支持动态路由和url参数。\\n      component?: React.ComponentType | 'iframeView' | 'mircroAppView' | 'externalUrl' | string; // 组件/iframeView/mircroAppView/externalUrl\\n      icon?: ReactNode | string;\\n      desc?: string; // 菜单描述\\n      routes?: RouteMenu[];\\n      hideInMenu?: boolean;\\n      meta?: SupportMetas; // 额外信息，用于路由页面控制父级样式\\n      scope?: string; // 该路由需要权限\\n      remark?: string; // 备注信息\\n    };\\n    ```\\n\\n4. 主应用通过idaas实现全局登录token获取、根据scope菜单显隐；子应用也通过idaas获取token，根据权限scope控制操作权限。\\n\\n5. 子应用只包含业务页面，可独立运行，支持嵌入其他系统中。\\n\\n6. 应用配置中心采用低代码形式，使用[FormRender](https://xrender.fun/form-render)实现拖拽式生成jsonSchema，方便不同业务方自己生成自己的配置表单。\\n\\n7. 应用配置中心也支持代码式配置jsonSchema。代码编辑器使用monaco。\\n\\n8. 车云服务平台server使用Node.js、Koa2开发。数据库使用mysql。\\n\\n9. 车云服务平台通过apollo服务获取网站配置。\\n\\n### 截图\\n\\n![首页](./lixiang/licar_home.jpg)\\n![车型管理](./lixiang/licar_model.jpg)\",\"n\":0.096}}},{\"i\":33,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"灵境低代码平台\\\"\\ncover: lixiang/lingjing_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"理想汽车一站式低代码创建/发布平台\\\"\\ndatePublished: \\\"2022-08-01 17:56:33\\\"\\ndateModified: \\\"2022-08-01 17:56:33\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - 后端\\n  - Node.js\\n  - Koa\\n  - 低代码\\n---\\n\\n灵境低代码平台，是理想汽车前端低代码化一站式创建/发布平台。\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [仓库介绍](#仓库介绍)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n- 根据业务在应用中心创建自己的应用，以应用纬度管理项目。每个人只能管理自己的应用。\\n\\n- 在应用详情创建页面，创建后可进入低代码编辑页，拖动+配置+代码结合生成页面。\\n\\n- 低代码编辑页现已支持Ant-Design、ProComponents、Fusion的组件，可迅速搭建常见的管理后台页面。\\n\\n- 生成的页面可随时通过预览链接预览。页面发布后即生成正式链接，支持dev和prod两个环境，可用于生产使用。\\n\\n- 低代码页面中目前支持多环境变量、IDaas全局登录状态、公共代码等功能，不断增加新功能...\\n\\n- 支持将常用的组件及其子节点（组件树）保存为一个【区块】。将某个页面保存为【页面模版】。保存后可在【模版区块中心】查看，其他人也可直接使用。\\n\\n- 支持为某一个应用添加协作者。\\n\\n### 仓库介绍\\n\\n- 【lingjing-center】：灵境低代码平台的web ui项目。\\n\\n- 【lingjing-core】：低代码编辑页（`src/page/index`）、开发预览（`src/page/preview`）、测试环境访问（`src/page/dev`）、线上环境访问（`src/page/prod`）\\n\\n- 【lingjing-server】：低代码平台的server端项目。包含用户登录认证、权限、应用模块、页面模块、模版和区块模块等。\\n\\n- 【lowcode-engine】：低代码引擎源码。\\n\\n- 【lowcode-materials】：低代码物料库。目前包含antd、antd-pro、fusion的物料库。符合cfe-ui规范，部分组件进行优化，更易于使用。\\n\\n### 我的职责\\n\\n1. 参与低代码技术前期调研。\\n\\n2. 负责低代码平台部分业务模块的开发（web + server）。\\n\\n3. 参与部分低代码物料的开发、使用、测试。\\n\\n4. 参与低代码编辑页、预览、线上渲染页开发和优化。\\n\\n### 技术实现\\n\\n1. 底层框架基于[lowcode-engine](https://lowcode-engine.cn/)。\\n\\n2. web ui使用react、antd。\\n\\n3. server端使用egg.js、egg-redis、mysql数据库。\\n\\n### 截图\\n\\n![首页](./lixiang/lingjing_home.jpg)\\n![应用详情](./lixiang/lingjing_app_detail.jpg)\\n![模块区块中心](./lixiang/lingjing_materials.jpg)\\n![低代码编辑页](./lixiang/lingjing_editor.jpg)\",\"n\":0.134}}},{\"i\":34,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"低代码现状调研\\\"\\ncover: images/default_img7.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"低代码的技术调研\\\"\\ndatePublished: \\\"2022-10-10 22:07:49\\\"\\ndateModified: \\\"2022-10-10 22:07:49\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 低代码\\n---\\n\\n> 🎯 在一个崇高的目标支持下，不停地工作，即使慢，也一定会获得成功。 —— 爱因斯坦\\n\\n### LowCode\\n    \\n低代码通常指aPaaS产品。aPaaS理解为PaaS的一种子形式。aPaaS的全称是application Platform as a Service，即应用程序平台即服务。  “aPaaS是基于PaaS（平台即服务）的一种解决方案”。\\n\\n![](./lowcode/apaas.jpg)\\n\\n| 名称 | 简介 | 代表产品 |\\n| ---- | ---- | ----|\\n| IaaS | 基于云的服务，按需付费，用于存储，网络和虚拟化等服务 | AWS，阿里云，腾讯云，华为云 |\\n| PaaS | Internet上可用的硬件和软件工具 | Microsoft Azure，百度BAE、新浪SAE、京东云擎JAE |\\n| SaaS | 可通过互联网通过第三方获得的软件 | 钉钉，企业微信，飞书 |\\n| aPaaS | PaaS的一种子形式 nocode/lowcode/ 可扩展性 云服务 | 简道云、明道云、氚云伙伴云 OutSystems Redmine，Jira，Odoo，Smartsheet, Airtable Zoho Creator |\\n\\nPaaS 和aPaas都可以完成软件的开发和部署，都支持云端访问。而两者的差异主要体现在用户人群和使用环境不一样。\\n\\n| 名称 | 区别 |\\n| ---- | ---- |\\n| PaaS | PaaS包含所有平台级别的服务，**需要技术人员在本地完成应用程序的开发和数据提供**，然后部署到PaaS平台上，再分发给用户使用。 |\\n| aPaaS | APaaS是PaaS的一种子形式，在APaaS模式下，**非技术人员**可以直接在**云端完成**应用程序的搭建、部署、使用、更新和管理。 |\\n\\n### 低代码行业现状\\n\\n> [艾瑞产业研究洞察-艾瑞咨询](https://www.iresearch.com.cn/Detail/report?id=3745&isfree=1)\\n\\n##### 企业应用场景\\n\\n![](./lowcode/changjing.jpg)\\n\\n##### 各企业的场景覆盖率\\n\\n![](./lowcode/fugailv.jpg)\\n\\n##### 近期融资情况\\n\\n艾瑞咨询预测：中国LCAP（低代码开发平台）市场**预计2025年达到131亿，未来5年复合增速为52.6%**。\\n\\n![](./lowcode/rongzi.jpg)\\n\\n![](./lowcode/changshang.jpg)\\n\\n### 低代码技术分类\\n\\n##### D2C\\n\\n即设计稿转代码（Desgin to Code）。输入设计稿，经过一系列算法，最终输出代码。\\n\\n![](./lowcode/d2c.jpg)\\n\\n代表技术：\\n- 蚂蚁 [imgcook](https://www.imgcook.com/)\\n- 京东 [deco](http://deco-preview.jd.com)\\n- [CodeFun](https://code.fun/)\\n\\n##### 表单/表格/图表\\n\\n代表技术：\\n- 阿里 [x-render](https://xrender.fun/)\\n\\n    用JsonSchema描述页面，并在页面中使用sdk渲染。FormRender支持表单设计、表单渲染；TableRender支持表格渲染；ChartRender支持图表渲染。\\n\\n- [form-generator](https://jakhuang.github.io/form-generator/#/)\\n\\n    Element UI表单设计及代码生成器。通过拖拽组件生成基于Element-UI的代码。\\n\\n- 阿里 [formilyjs](https://designable-antd.formilyjs.org/)\\n\\n    Formily表单设计器是基于[designable](https://github.com/alibaba/designable)而开发的扩展包，它在继承了 designable 的基础能力上，提供了 Formily 基础表单的搭建和配置能力。支持Ant Design和FussionUI。\\n\\n##### 前端页面搭建\\n\\n代表技术：\\n- [阿里低代码引擎](https://lowcode-engine.cn/docV2/intro)\\n\\n    一套面向扩展设计的企业级低代码技术体系。\\n\\n- [百度amis](https://aisuda.bce.baidu.com/amis/zh-CN/docs/index)\\n\\n    强大的前端低代码框架，不受前端技术更新影响通过 JSON 配置就能生成各种页面。\\n\\n- [brick-design](https://brick-design.github.io/brick-design/)\\n\\n    全场景流式布局，可视化拖拽、随意嵌套组合、实时渲染、实时辅助线展示、支持逻辑渲染。\\n\\n##### 全栈低代码\\n\\n代表技术：\\n- [JeecgBoot](http://www.jeecg.com/)\\n\\n    企业级低代码平台，可在页面创建表单，自动生成数据库表，增删改查页面等；也可生成代码并手动部署。\\n    ![](./lowcode/jeecg.jpg)\\n\\n    > [jeecg-boot低代码平台调研](https://li.feishu.cn/docs/doccnMIlbbG0i7RxoxNnmkXL0Be)\\n\\n- [ELADMIN](https://eladmin.vip/)\\n\\n    B端管理后台项目框架。集成了通用前后端技术的框架，并自带了管理后台常用的通用功能模块。并支持代码生成的功能。\\n\\n##### 数据库转电子表格\\n\\n代表技术：\\n- [NocoDB](https://github.com/nocodb/nocodb)\\n\\n    可以将 MySQL、PostgreSQL、SQL Server、SQLite 或 MariaDB等关系数据库转换为智能电子表格。\\n\\n    ![](./lowcode/nocodb1.jpg)\\n    ![](./lowcode/nocodb2.jpg)\",\"n\":0.085}}},{\"i\":35,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"MessUi\\\"\\ncover: images/messui_cover.png\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"Messui是一个高效的android平台页面框架\\\"\\ndatePublished: \\\"2017-03-17 14:33:20\\\"\\ndateModified: \\\"2017-03-17 14:33:20\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - UI框架\\n  - 开源\\n---\\n\\nMessUi是一个高效的android平台页面框架。\\n\\ngithub仓库：https://github.com/missmess/Messui\\n\\n---\\n\\n### 如何使用\\n\\n1. build.gradle添加以下依赖：\\n\\n    ```java\\n    implementation 'com.missmess.messui:messui:1.0.2'\\n    ```\\n2. Activity继承CoreActivity，并实现抽象方法：\\n\\n    ![](./messui/implements.jpg)\\n\\n### 有哪些功能？\\n\\n1. **默认包含最常见的Android页面布局。**\\n\\n    框架包含了Android上最常见的页面布局结构：*状态栏+标题栏+内容区*。\\n\\n    - 状态栏可修改任意颜色、融入背景、隐藏。\\n\\n    - 标题栏默认包含左侧返回+文字、居中标题、右侧按钮区。可任意定制。\\n\\n    - 内容区已默认包含加载中、加载失败、实际内容（加载成功）、下拉刷新、上拉加载。\\n\\n    ![DEMO](./messui/main.jpg)\\n\\n2. **链式调用，一秒设置页面元素**\\n\\n    通过BuilderKit链式调用的方式，轻松设置页面布局结构。\\n\\n    `kit.tb`为标题栏builder，控制标题栏；`kit.sb`为系统布局builder，控制状态栏和底部导航栏；`kit.lb`为loading builder，控制加载中、加载失败/成功；`kit.rb`为下拉刷新builder，控制下拉刷新和上拉加载。\\n\\n    `xx.enable()`代表启用该布局，启用后方可链式调用页面元素设置。\\n\\n    ```java\\n    // 继承框架的CoreActivity\\n    public class MainActivity extends CoreActivity<TitleBuilderRaw, LoadViewBuilderRaw, RefreshBuilderRaw> {\\n\\n        @Override\\n        protected int getLayoutResId() {\\n            // 只需要在layout定义加载成功的布局，并返回\\n            return R.layout.activity_main;\\n        }\\n\\n        @Override\\n        public void buildLayout(BuilderKit<TitleBuilderRaw, LoadViewBuilderRaw, RefreshBuilderRaw, SystemUIBuilderRaw> kit) {\\n            // 通过BuilderKit设置页面布局，链式调用\\n            kit.tb.enable().title(\\\"您好啊，开发者\\\").bgColor(Color.GRAY)\\n                    .navigateText(\\\"饭回\\\")\\n                    .navigateTextColor(Color.GREEN)\\n                    .titleColor(Color.BLACK);\\n            kit.lb.enable().loadingTip(\\\"😊 稍等一下哦\\\");\\n            kit.rb.enable().enableRefresh(new Runnable() {\\n                @Override\\n                public void run() {\\n                    ((SwipeRefreshLayout) getRefreshLayout()).setRefreshing(false);\\n                }\\n            });\\n            kit.sb.enable().statusBarColor(Color.BLACK).navigationBarColor(Color.RED);\\n        }\\n    }\\n    ```\\n\\n3. **支持Activity和fragment**\\n\\n    同时支持activity和fragment，只需要集成`CoreActivity`、`CoreFragment`即可使用。\\n\\n4. **还不满足需求？可自定义主题**\\n\\n    框架本身包含很丰富的设置项，但是如果还是不满足需求，也支持自定义。\\n\\n    ```java\\n    // 布局代理抽象为LayoutDelegate接口，默认布局使用的是DefaultLayoutDelegate\\n    // 可自己继承LayoutDelegate接口实现新的布局\\n    @Override\\n    protected LayoutDelegate createLayoutDelegate() {\\n        return new DefaultLayoutDelegate(this);\\n    }\\n    ```\\n\\n    继承LayoutDelegate接口实现即可。\\n\\n    并且如果只想替换其中某一部分（比如只换标题栏），也支持。实现接口时，其他部分仍使用Default实现即可。\\n\\n    ![内置布局factory](./messui/default_view.jpg)\",\"n\":0.092}}},{\"i\":36,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"秒聊\\\"\\ncover: miaoliao/cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"秒聊是附近陌生人交友APP\\\"\\ndatePublished: \\\"2023-12-29 10:07:49\\\"\\ndateModified: \\\"2023-12-29 10:07:49\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - Android端\\n  - Uniapp\\n  - 跨平台\\n---\\n\\n**秒聊**主打附近陌生人聊天交友。秒聊牵线能为你智能推荐最匹配你的异性，同城交友秒连接。\\n\\nAPP下载：http://miaoliao.siyisea.com/appdl/index.html\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n**附近异性秒连接**\\n\\n  秒聊智能推荐附近你可能感兴趣的异性。秒聊小助手为你搭桥牵线。\\n\\n**真人交友**\\n\\n  秒聊推荐用户进行真人认证，通过认证才能获得优先推荐和积分奖励。\\n\\n**与TA互动**\\n\\n  看到喜欢的异性，可以和TA私聊，点赞/评论动态，发送礼物，发送喜欢。到达一定的亲密度，还能解锁语音/视频通话。\\n\\n**赢积分，可提现**\\n\\n  及时回复异性的搭讪，或者接听追求者的语音/视频通话，可以获得积分奖励，积分可提现。做任务也能获得丰富的积分奖励。\\n\\n**邀请好友**\\n\\n  邀请立得奖励，并且获得持续的积分返现。\\n\\n### 我的职责\\n\\n1. 负责秒聊APP的产品功能设计。\\n\\n2. 负责秒聊APP的风格、UI、交互设计。\\n\\n3. 秒聊APP开发，跨平台。\\n\\n4. 技术方案设计，im通信协议和全局弹窗规范。\\n\\n### 技术实现\\n\\n1. 使用uniapp开发app，支持Android、iOS。H5支持预览（很多功能无法正常使用）。\\n\\n2. 基础ui使用uview，主要页面为vue页面，复杂页面使用nvue开发。\\n\\n3. im聊天sdk使用wildfire uniapp sdk。\\n\\n4. 推送使用unipush。\\n\\n5. 一键登录使用aliyun号码认证sdk。\\n\\n6. 动画部分使用lottie，礼物特效使用svga。\\n\\n7. 部分页面使用webview加载h5页面。\\n\\n8. 秒聊已经做了很极致的性能优化，可惜uniapp能优化的空间很有限。\\n\\n   - 逻辑层与渲染层分离，导致通信有一定成本。实际测试css动画要比uni-transition，在低端机上流畅的多。\\n\\n   - Native.js虽然很强大，可以任意调用原生类和方法，无奈加载很慢。低端机无法使用，所以只能使用原生插件或uts插件，但是仍然有一定加载耗时。\\n\\n   - 在onLoad中执行耗时操作，直接导致白屏时间很长。\\n\\n   - vue的watch监听，使用immediate: true，会卡渲染。\\n\\n   - 等等等...\\n\\n### 截图\\n\\n![启动页](./miaoliao/splash.jpg)\\n![登录](./miaoliao/login.jpg)\\n![首页](./miaoliao/home.jpg)\\n![动态广场](./miaoliao/posts.jpg)\\n![我的](./miaoliao/mine.jpg)\\n![聊天列表](./miaoliao/messages.jpg)\\n![聊天](./miaoliao/chat.jpg)\\n![用户详情](./miaoliao/user.jpg)\\n![积分提现](./miaoliao/jifeng.jpg)\\n![编辑信息](./miaoliao/edit-profile.jpg)\",\"n\":0.135}}},{\"i\":37,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"秒聊-H5页\\\"\\ncover: miaoliao-h5/cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"秒聊H5页包含微信分享、微信邀请、app下载、帮助与问答、在线客服等页面\\\"\\ndatePublished: \\\"2023-12-20 13:18:20\\\"\\ndateModified: \\\"2023-12-20 13:18:20\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - Vue3\\n  - Vant\\n  - Vite\\n---\\n\\n秒聊-H5页是开发秒聊H5页面的项目，包含微信分享、微信邀请、app下载、帮助与问答、在线客服、H5活动等页面。\\n\\n访问地址：http://miaoliao.siyisea.com/share-for-user?id=i2gqmws2k&share_userid=82gqmws2k&from_client=android\\n\\n查看：[《秒聊》](/秒聊)\\n\\n---\\n\\n### 截图\\n\\n![分享用户](./miaoliao-h5/share.jpg)\\n![帮助中心](./miaoliao-h5/help.jpg)\\n![反馈](./miaoliao-h5/feedback.jpg)\\n![APP下载](./miaoliao-h5/download.jpg)\\n![星座控](./miaoliao-h5/constellation.jpg)\",\"n\":0.229}}},{\"i\":38,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"min-ruoyi\\\"\\ncover: min-ruoyi/cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"ruoyi-vue优化后的最简版本，可以作为常用后台的脚手架\\\"\\ndatePublished: \\\"2023-01-04 20:09:19\\\"\\ndateModified: \\\"2023-01-04 20:09:19\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - 前端\\n  - Vue2\\n  - 脚手架\\n  - 开源\\n  - 低代码\\n---\\n\\nmin-ruoyi是将ruoyi-vue优化后的最简版本，可以作为ruoyi后台管理项目的启动脚手架\\n\\ngitee仓库：https://gitee.com/missmess/min-ruoyi-vue2-ui-starter\\n\\n---\\n\\n### 有什么变化？\\n\\n官方的ruoyi-vue，包含了太多的测试页面和测试数据，并且样式有很多不合理、不好看的地方。\\n\\n*这个最简版本就是解决了这些问题*\\n\\n### 如何使用\\n\\n直接clone项目，对接RuoYi的server address后，即可使用。\\n\",\"n\":0.209}}},{\"i\":39,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"云流-Nocodb应用\\\"\\ncover: nocodb/table-view.jpg\\ncoverAlt: \\\"多维表格模块\\\"\\ndescription: \\\"Nocodb为云流提供数据展示能力\\\"\\ndatePublished: \\\"2023-04-10 13:35:12\\\"\\ndateModified: \\\"2023-04-10 13:35:12\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - Vue3\\n  - Nuxt\\n  - Antd\\n  - 后端\\n  - Node.js\\n  - Express\\n  - Vite\\n---\\n\\n**云流-Nocodb应用**是类似于Airtable、飞书多维表格的数据生产力产品。\\n\\n访问地址：http://114.55.92.229:8080/dashboard/#/\\n\\n可以独立连接数据库使用，此时的Nocodb作为纯多维表格去使用。\\n\\n也可以嵌入到[云流](/云流)中，此时除了可以作为多维表格使用，创建的表格还可以当作流程表单中的数据关联。\\n\\n参考：[nocodb v0.100.2](https://github.com/nocodb/nocodb)。\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n1. **多维表格**\\n\\n    涵盖主流多维表格大部分功能，包括：\\n\\n    - 常用表格组件：文本、单选、多选、日期、时间、手机、邮箱、链接、上传附件、图片、货币、百分比、小数等30+\\n    - 高级组件：数据关联、公式、汇总、JSON、数据库、查找等\\n    - 排序、筛选、隐藏字段、表格内数据查询\\n    - 支持表格、卡片、画廊、看板视图展示数据\\n    - 支持快速导入xlsx、csv等常见文档\\n    - 表格可添加评论\\n\\n2. **6种角色权限**\\n\\n  超级管理员、项目管理员、所有者、编辑者、评论者、查看者\\n\\n3. **组件可自定义**\\n\\n  支持新增组件，修改组件\\n\\n4. **AI扩展**\\n\\n  可以添加AI扩展，来对表格数据进行分析、修改、插入列等处理操作。\\n\\n  ![AI扩展](./nocodb/aiextension.jpg)\\n\\n5. **连接外部数据源**\\n  - 能连接外部数据库创建项目\\n  ![连接外部数据库](./nocodb/external.jpg)\\n  - 可以导入外部数据到表格\\n  ![导入外部数据](./nocodb/import.jpg)\\n\\n### 我的职责\\n\\n1. 产品UI调整。\\n\\n2. nocodb GUI研发、功能扩展。\\n\\n3. nocodb server端修改、扩展。\\n\\n### 技术实现\\n\\n1. GUI使用Nuxt、ant-design-vue、windicss开发。\\n\\n2. server端使用express开发。\\n\\n3. db部分使用knex抹平各数据库之间的差异。\\n\\n### 截图\\n\\n![登录](./nocodb/login.jpg)\\n![项目](./nocodb/project.jpg)\\n![表格](./nocodb/table-view.jpg)\",\"n\":0.118}}},{\"i\":40,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"procomponents-template\\\"\\ncover: lixiang/procomponents_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"ProComponents封装的低代码脚手架\\\"\\ndatePublished: \\\"2021-12-02 10:50:54\\\"\\ndateModified: \\\"2021-12-02 10:50:54\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - 前端\\n  - React\\n  - 脚手架\\n  - 开源\\n  - 低代码\\n  - Vite\\n---\\n\\n使用ProComponents封装的带页面模版的低代码脚手架。方便**后台开发人员**或**不熟悉React开发语言的开发者**，能自己轻松搭建常见后台的crud列表页及详情页。\\n\\ngitee仓库：https://gitee.com/missmess/pro-components-template.git\\n\\n---\\n\\n### 为什么是ProComponents\\n\\nProComponents提供了更高级的业务组件，覆盖中后台应用很大程度上的页面开发需求。比起Ant Design的组件，需要开发的工作量骤减。将写代码的工作转变为写json配置的工作。很适合做过开发但是不会React的程序员快速搭建高质量的页面。\\n\\n### 主要功能\\n\\n1. 使用ProLayout搭建顶层页面，包含*左侧可伸缩菜单栏+顶部标题栏+内容区*。\\n\\n2. 支持左侧菜单配置，在menus.tsx中修改即可。\\n\\n3. 支持面包屑。\\n\\n4. 自带骨架屏。过渡效果优秀。\\n\\n5. 默认template已包含crud列表页、和支持新增、编辑、详情展示的页面。需要新增页面时只需要拷贝整个目录再修改其中的代码。\\n\\n### 技术点\\n\\n1. 基于vite、React开发。\\n\\n2. 使用ProComponents开发页面。\\n\\n### 使用指南\\n\\n新增某个新业务的crud功能时，按照以下几个步骤即可：\\n\\n1. 在`src/menus.tsx`，增加路由的配置。\\n\\n2. 在`src/mapping.tsx`指定路由和组件的映射关系。\\n\\n3. 拷贝实例的`src/pages/car/sale`目录，生成新的业务目录。\\n\\n4. 新目录下的`index.tsx`为列表页，修改`columns`中的json数据，想要在表格中展示接口的什么字端，配置到`title`和`dataIndex`中。\\n\\n    ```javascript\\n    // 示例\\n    {\\n      title: \\\"书籍名称\\\",\\n      dataIndex: \\\"bookName\\\"\\n    }\\n    ```\\n\\n5. 修改查询接口、删除接口地址，修改跳转详情页的路由地址。\\n\\n6. 新目录下的`detail/index.tsx`为新增/编辑/详情页一体。修改查询详情接口、新增、编辑接口的地址。\\n\\n### 截图\\n\\n![主界面](./lixiang/procomponents_home.jpg)\",\"n\":0.14}}},{\"i\":41,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"麒小佑（小程序+后台）\\\"\\ncover: qixiaoyou/cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"在线小儿推拿穴方生成小程序\\\"\\ndatePublished: \\\"2023-12-17 11:21:43\\\"\\ndateModified: \\\"2023-12-17 11:21:43\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 小程序\\n  - 前端\\n  - Vue3\\n  - ElementUI\\n  - Vite\\n---\\n\\n在线小儿推拿穴方生成、诊疗小程序。\\n\\n<video src=\\\"./qixiaoyou/video.MP4\\\" width=\\\"250\\\" autoplay muted controls />\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [小程序截图](#小程序截图)\\n- [管理后台截图](#管理后台截图)\\n\\n### 主要功能\\n\\n1. 交互为AI助手对话形式。\\n\\n2. 根据病征智能生成穴方。\\n\\n3. 生成诊疗记录，可回访修改。\\n\\n4. 推拿师认证、申请。\\n\\n5. 【后台】管理推拿师、管理认证申请\\n\\n6. 【后台】管理穴方、管理病征\\n\\n### 我的职责\\n\\n1. 小程序UI设计。\\n\\n2. 小程序开发。\\n\\n3. 管理后台开发。\\n\\n### 技术实现\\n\\n1. 小程序使用原生开发。\\n\\n2. UI使用pixso设计。\\n\\n3. 助手对话过程为模拟对话，并非真实对话。抽象为aiSimulator驱动对话流程。\\n\\n4. 使用wxs优化wxml中的复杂计算。\\n\\n5. 后台基于[min-ruoyi](./min-ruoyi-2023-01.md)脚手架开发。\\n\\n### 小程序截图\\n\\n![](./qixiaoyou/login.jpg)\\n![](./qixiaoyou/chat.jpeg)\\n![](./qixiaoyou/create.jpeg)\\n![](./qixiaoyou/end.jpeg)\\n![](./qixiaoyou/mine.jpeg)\\n![](./qixiaoyou/verify.jpg)\\n\\n### 管理后台截图\\n\\n![](./qixiaoyou/login2.jpg)\\n![](./qixiaoyou/dashboard.jpg)\",\"n\":0.14}}},{\"i\":42,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"React Fiber架构总览\\\"\\ncover: ../static/assets/react-fiber.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"介绍React16带来的全新fiber架构，它的设计总览\\\"\\ndatePublished: \\\"2023-02-09 11:20:41\\\"\\ndateModified: \\\"2023-02-09 11:20:41\\\"\\nslug: \\\"react-fiber-struct\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 前端\\n  - React\\n  - 架构\\n  - 造轮子\\n---\\n\\n众所周知，React团队耗时2年多在React16发布了全新重构版本的Fiber架构，替代了原来的`Stack Recociler + Renderer`的架构组合。重构的主要升级目标就是，将老架构的**同步更新**，替换为**异步可中断的更新**模式，并由此带来了一系列新特性。本文会从总体的角度讲一下整个Fiber架构的工作流程。\\n\\n### 老架构\\n\\n在了解新架构之前，先来看看在此之前的老架构是什么样的，存在什么问题。React15的架构可以分为：\\n\\n- Reconciler（协调器）：负责对虚拟DOM使用Diff算法找出发生变化的组件\\n- Renderer（渲染器）：负责根据组件的变化更新渲染到页面上\\n\\n> 老React的具体渲染流程可以看[我之前的文章](/vue-react-render)\\n\\n简单来说，**Reconciler**会在每次渲染流程中：\\n\\n1. 生成内部组件实例。函数组件或类组件调用render方法，将JSX转化为虚拟DOM。\\n2. 新生成的虚拟DOM与上次的的进行对比。\\n3. 找到可以复用的不用重新创建DOM，将变化通过**Renderer**渲染到页面上。\\n4. 找不到可复用的，通过**Renderer**操作页面DOM。\\n5. 对children递归处理，重复以上步骤。\\n\\n而**Renderer**则会去操作DOM节点的移动、更新、删除，这个过程是同步的。即**Reconciler**与**Renderer**是交替工作的，**Reconciler**发现变化就通知**Renderer**立即去渲染。直到整个渲染流程结束。\\n\\n> *React支持跨平台，主要体现在可以针对不同的平台有不同的Renderer*。我们最熟悉的是Renderer是[ReactDOM](https://www.npmjs.com/package/react-dom)，除此之外，还有大名鼎鼎的[React Native](https://www.npmjs.com/package/react-native)。\\n\\n**老架构的缺点**\\n\\n递归协调工作一旦开始，就无法结束，必须等待协调过程结束。如果节点太多，处理耗时太长（超过了16ms），则可能会导致页面出现掉帧、卡顿。\\n\\n### 新架构\\n\\n新架构不再使用内部组件来处理虚拟DOM的diff，而改为使用Fiber节点。每个Fiber节点既是一个独立工作单元，也是一个树节点，与其他Fiber节点共同组成Fiber树，同时也记录着动态的数据和状态。Fiber节点可以认为和每一个JSX节点一一对应。新架构下，不再是同步的实时更新，而是异步的可中断更新。\\n\\n新Fiber架构的设计分为：\\n\\n- Reconciler（协调器）：负责对Fiber节点进行对比，找出其中的变化\\n- Renderer（渲染器）：负责根据组件的变化更新渲染到页面上\\n- Scheduler（调度器）：调度任务的优先级，对更新任务的时间切片\\n\\n其中Fiber树还用到了“双缓存”的技术。\\n\\n**双缓存Fiber树**\\n\\n双缓存Fiber树就是React中存在两棵Fiber树，一棵是当前渲染在屏幕上的，叫**current**，另一棵是在内存中正在构建操作的，叫**workInProgess**。一旦构建完成，原来的current丢弃，current指向workInProgress，即完成了Fiber树的替换。\\n\\n在这样的架构模式下，工作模式变成了：\\n\\n1. Scheduler接收到更新，判断优先级，通知Reconciler开始工作。\\n\\n2. Reconciler进入render阶段。开始构建workInProgress树。进入workLoop（工作循环）。\\n\\n3. 对每一个工作单元（Fiber）进行beginWork（创建Fiber，diff和标记变化）。beginWork结束后，执行completeWork（创建DOM，children Append等）。\\n\\n4. 每完成一个工作单元，通过Scheduler判断是否要中断render阶段。\\n\\n5. render阶段结束后，进入commit阶段。开始对发生变化的节点提交DOM操作。\\n\\n6. 完成后，将current树指向workInProgress树。\\n\\n接下来就具体讲一下每个工作步骤。\\n\\n### 触发更新\\n\\n这些方法会触发一次渲染更新流程：`ReactDOM.render`、`this.setState`、`this.forceUpdate`、`useState`、`useReducer`等。每个更新具有不同的优先级。根据优先级的不同，会触发一次同步更新或异步调度的更新。\\n\\n同步更新执行后或者异步更新调度执行后，会进入render阶段。代码类似于：\\n\\n```javascript\\nfunction performSyncWorkOnRoot(root) {\\n  // render阶段\\n  renderRootSync(root);\\n  // commit阶段\\n  commitRoot(root);\\n}\\n```\\n\\n### render阶段\\n\\nrender阶段从`FiberRoot`开始，创建第一个`workInProgress`。然后进入workLoop（工作循环）。针对每一个workInProgress工作单元，都对其执行`beginWork`和`completeWork`。类似于下面这段代码：\\n\\n```javascript\\nfunction workLoop(root) {\\n  let workInProgress = createWorkInProgress(root);\\n  // 循环工作循环\\n  while (workInProgress != null) {\\n    let unitOfWork = workInProgress;\\n\\n    beginWork(unitOfWork);\\n\\n    if (unitOfWork.child !== null && !shouldYield()) {\\n      workInProgress = unitOfWork.child;\\n      continue;\\n    }\\n\\n    let completedWork = unitOfWork;\\n\\n    do {\\n      completeWork(completedWork)\\n\\n      const returnFiber = completedWork.return;\\n      const siblingFiber = completedWork.sibling;\\n      if (siblingFiber != null) {\\n        workInProgress = siblingFiber;\\n        break;\\n      }\\n\\n      completedWork = returnFiber;\\n      workInProgress = completedWork;\\n    } while (completedWork != null);\\n  }\\n}\\n```\\n\\n在工作循环中，会挨个处理每一个fiber节点，对每个fiber节点都会执行一次`beginWork`和`completeWork`，但是它们的执行时机不同。`beginWork`会以深度优先的方式，往子孙树从上往下执行。而`completeWork`是在每一个节点及其子孙都执行完`beginWork`后，往祖先树从下往上执行。\\n\\n*另外，工作循环是可中断和恢复的，即如果上面的`shouldYield()`返回true，那么`render阶段`就退出了。等待下次重新启动渲染流程，由于记录了workInProgress，所以可以恢复。React中的异步可中断更新就是中断的render阶段。*\\n\\n> 工作循环的具体设计思路，后续会补充一篇文章单独讲解。\\n\\n#### beginWork\\n\\n`beginWork`是协调器里最重要的一个方法。它是从上往下执行的，我们从`FiberRoot`开始只有一个新fiber节点，即第一个workInProgress，执行`beginWork`的目的是为了构建完整的workInProgress树。可以猜到`beginWork`的主要功能就是对比新旧fiber，协调出新的children fiber并链接到workInProgress上。具体步骤为：\\n\\n1. 判断workInProgress是否可以复用旧的fiber，可以复用（props和context都未变化），则克隆children fiber并挂到workInProgress树。跳过2、3步。\\n\\n2. 如果不可复用，则重新执行渲染函数（类组件或函数组件）获取newChildren或从props.children获取（Host组件）。\\n\\n3. 获取到newChildren后，和旧的fiber链表进行协调。协调过程就是diff，并标记变化（effectTag，后续根据这个判断如何变更DOM）到新fiber上。\\n\\n4. beginWork完成，返回child作为下一个工作单元。如果没有child，则进入`completeWork`。\\n\\n#### completeWork\\n\\n`completeWork`是在当前workInProgress fiber的子孙全部协调结束后执行的。它可以执行一些收尾工作。例如对于`HostComponent`，它执行了：\\n\\n1. 如果是update时（即存在旧fiber-current），处理变化的props，存储到`workInProgress.updateQueue`（会在commit阶段渲染到页面上）。\\n\\n2. 如果是mount时，为当前fiber创建对应的DOM节点。并将children的DOM节点插入进来。\\n\\n其他类型的组件处理的工作并不相同。到这里`completeWork`工作就结束了。\\n\\n#### effectList串联\\n\\n之前我们提到`beginWork`里会在fiber上标记变化，即effectTag。后续`commit`阶段需要用于变更DOM。为了方便后续该操作，React在`completeWork`完成后，额外执行了一个串联effectList的工作。\\n\\neffectList挂载在fiber上，其实就是一个单向链表，以`fiber.firstEffect`为第一个，`fiber.lastEffect`为最后一个，前一个的`nextEffect`指向后一个。\\n\\n1. 每个fiber判断自己是否有effectTag，如果有，把自己串到父fiber的effectList最后。\\n\\n2. 和`completeWork`一样，往祖先级从下往上执行，所以最终`rootFiber`上的effectList就是整棵树全部的effect了。\\n\\n### commit阶段\\n\\n`render阶段`结束后，直接进入`commit阶段`。顾名思义，就是将`render阶段`发生的effect，在该阶段提交到页面上。注意，不同于`render阶段`可以中断。`commit阶段`是同步执行的，不可中断。\\n\\nReact将`commit阶段`又分为三个小阶段。\\n\\n#### before mutation阶段\\n\\n`before mutation`是在执行具体的DOM操作之前。在这个阶段可以做一些准备工作。包括：\\n\\n1. 处理渲染/删除节点的focus/blur状态。\\n\\n2. 调用`getSnapshotBeforeUpdate`。（commit阶段是同步的所以该方法不会多次调用，`UNSAFE_componentWillReceiveProps`在render阶段被调用所以不安全）。\\n\\n3. 异步调度`useEffect`回调函数。\\n\\n它主要通过遍历effectList链表，来对有effect的节点进行这些处理。\\n\\n#### mutation阶段\\n\\n`mutation`是实实在在的执行DOM操作的阶段。\\n\\n它也是遍历effectList链表，然后对不同的effect进行处理，主要包含3种effect：\\n\\n**Placement**\\n\\n代表该fiber所复用的DOM节点需要更换位置。\\n\\n1. 如果有下一个稳定的兄弟DOM，则插入到兄弟DOM之前。这里有三个理解难点：\\n\\n    - 一是为什么要插入到下一个兄弟DOM之前？因为在之前`render阶段`的diff算法原理是遍历newChildren时，总是标记需要右移的fiber。这个fiber的下一个兄弟一定在它右边，所以fiber对应的dom一定在下一个兄弟dom的左边。\\n    \\n    - 二是查找兄弟DOM需要跨层级搜索，因为兄弟fiber不一定有兄弟DOM。兄弟dom可能就是它的sibling，但也有可能在它的父fiber的sibling树下，也有可能在它的sibling树下。\\n\\n    - 三是为什么要找稳定的兄弟？稳定是指没有被Placement标记的。因为如果兄弟被Placement标记了，那它对应的dom一定也会被移动，所以不能直接插入它前面。\\n\\n    （这里的逻辑比较复杂，后续会补充一篇文章，专门讲解一下整个Diff算法和mutation逻辑）\\n\\n2. 如果没有稳定的兄弟DOM，则插入到队尾。这个好理解。\\n\\n**Update**\\n\\n代表该fiber需要更新。对于不同的fiber，需要不同的处理。\\n\\n对于函数组件，执行`useLayoutEffect`的销毁函数。\\n\\n对于Host组件，会将之前`render阶段`-`completeWork`中赋值的`updateQueue`更新到dom上，其实就是更新dom属性。\\n\\n**Deletion**\\n\\n代表该fiber对应的dom需要被移除。当然包括它的子孙fiber节点。\\n\\n该方法主要处理几个操作：\\n\\n1. 递归处理fiber和它的子孙fiber。\\n\\n2. 移除对应的DOM节点。\\n\\n3. 解绑ref。\\n\\n4. 如果是类组件，调用`componentWillUnmount`生命周期。\\n\\n#### layout阶段\\n\\n`layout`阶段，是所有DOM修改完成后才执行的，这时候js代码或者在这个阶段触发的生命周期，都已经可以访问到修改后的DOM了。\\n\\n在这个阶段，也是遍历effectList列表。主要做了三件事：\\n\\n1. 对于有**Update**的fiber，如果是类组件，则触发生命周期componentDidMount或componentDidUpdate。\\n\\n2. 对于有**Update**的fiber，如果是函数组件，则同步执行useLayoutEffect的回调函数、异步调度useEffect的销毁函数与回调函数。\\n\\n3. 绑定ref。\\n\\n至此，layout阶段也完成了。替换一下workInProgress树，那么整个渲染更新流程就结束啦！\\n\\n```javascript\\nroot.current = finishedWork;\\n```\\n\\n### Scheduler调度器\\n\\n接着讲一下`Scheduler`，它在React中是一个独立的包。它的功能是作为任务调度器，用于控制任务执行时机。它主要包含两部分功能：**时间切片**和**优先级调度**。\\n\\n#### 时间切片\\n\\n时间切片的功能很像[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，即在浏览器每一帧中给予一定的时间去处理渲染逻辑，如果时间超出了，则中断渲染，控制权交还给浏览器。从而保持整个界面和交互的流畅。\\n\\n那为什么不直接用`requestIdleCallback`和`requestAnimationFrame`呢？\\n\\n一是`requestIdleCallback`调用时机不确定；\\n\\n二是各个浏览器对`requestIdleCallback`和`requestAnimationFrame`的实现不一样，有兼容性问题；\\n\\n三是React希望能实现更精细的任务优先级控制和执行时间控制。\\n\\nReact的Scheduler基于[MessageChannel](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L228-L234)，如果浏览器不支持`MessageChannel`，则fallback为[setTimeout](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L47-L55)。\\n\\n联想到之前render阶段，在工作循环中，有一个`shouldYield()`方法。这个方法就是Scheduler提供的，用于判断下一个任务是否需要中断执行。\\n\\n它的原理就是在Scheduler中，会为任务执行分配一个时间。如果执行任务的耗时超过了分配的时间，则中断执行。等待到下一个时间切片再重新执行。\\n\\n#### 优先级调度\\n\\nScheduler提供了一个`scheduleCallback`方法，当需要优先级异步调度某个回调函数时，就调用这个方法。在`render阶段`和`commit阶段`，很多地方使用了这个方法来调度，比如渲染入口函数的异步调度、useEffect回调的异步调度等。\\n\\nScheduler设置了5种**优先级**，来控制任务的执行时机，不同的优先级有不同的过期时间。实现原理简单说来就是，Scheduler会将任务放在优先级队列中，队列中的任务按照过期时间排序，最快过期的在最前。每来一个新任务，就根据优先级计算过期时间，然后放入队列中重新排序。最终，取出最快过期的任务立即执行。\\n\\n### Lane模型\\n\\nLane模型是React内部对更新优先级进行协调、合并和执行的一套规则。在整个渲染更新流程中，到处都是它的身影。React将更新根据其优先级被分配到相应的 Lane 中，高优先级的更新会优先处理。\\n\\n使用场景：\\n\\n- 为用户交互事件触发的更新，提供更高优先级，确保该更新能更快渲染到界面上。（原理是React在调用事件处理器之前，事先设置好了优先级，当调用setState等方法时，能获取到该优先级）\\n\\n- 被`useTransition()`包裹的回调中触发的更新，将会降低优先级。从而不影响重要的更新。\\n\\nLane什么时候被生产？\\n\\nLane在触发一个更新请求的时候，React就会为这个请求生产一个lane值。\\n\\nLane怎么被消费？\\n\\nLane会被分配到update对象上，并标记到fiber上。最终会在触发更新流程的函数上被消费。\\n\\n> Lane模型比较复杂，难懂，后续会单独介绍。\\n\",\"n\":0.076}}},{\"i\":43,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"React Fiber架构之工作循环\\\"\\ncover: ../static/assets/react-fiber.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"介绍React16带来的全新fiber架构，其中的WorkLoop\\\"\\ndatePublished: \\\"2023-04-06 19:58:30\\\"\\ndateModified: \\\"2023-04-06 19:58:30\\\"\\nslug: \\\"react-workloop\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 前端\\n  - React\\n  - 架构\\n  - 造轮子\\n---\\n\\n在[React Fiber架构总览](/react-fiber-struct)中我们提到，React16的新Fiber架构，将老架构的**递归同步的更新**，替换为**异步可中断的更新**。这个异步可中断指的就是工作循环的执行中断。\\n\\n本次我们就主要讲一讲：为什么要使用workLoop（工作循环）？它是怎么实现可中断的？为什么之前的老架构不可以中断？\\n\\n带着这些问题，我会用一些简化的代码讲清楚这个知识点。\\n\\n### 老架构的递归工作模型\\n\\n在讲新架构之前，先分析一下老架构是怎么做的。前面也提到了，老架构是通过递归实现的。简化的代码就如同下面：\\n\\n```javascript\\nexport function mountRootTree(root) {\\n    // React.createElement获取到的element转化为内部组件\\n    const rootComponent = new InnerComponent(root);\\n    // 调用内部组件.mount\\n    const node = rootComponent.mount();\\n    // 渲染\\n    callRender(node);\\n}\\n\\nclass InnerComponent {\\n    mount() {\\n        // 从props.children或render()函数获取children elements\\n        const children = getChildren()\\n        // 创建node\\n        const parent = createNode();\\n        // 遍历children，并渲染\\n        children.forEach((child) => {\\n            const childComponent = new InnerComponent(child);\\n            const node = childComponent.mount();\\n            // 渲染\\n            callRender(node, parent);\\n        })\\n        return parent;\\n    }\\n}\\n```\\n\\n可以看到，从根元素开始，每个element创建一个内部组件，然后调用内部组件的`mount()`方法。内部组件的mount()方法里再继续获取children elements，并创建child内部组件，然后递归调用child内部组件的mount()方法...整个组件树的工作就这样完成了。\\n\\n> 以上代码非常简化，只是想说明老架构是如何去递归处理各个节点的。详细分析可见我写的另一篇文章：[渲染流程：Vue vs React](/vue-react-render)\\n\\n从代码可以看出，这种递归的处理方式一旦开始，就要从头执行到结束，无法中断。\\n\\n### 新架构的Fiber工作循环\\n\\n在上面介绍的老架构中，每个element（可以理解为每个jsx节点）都创建了一个内部组件。在新的Fiber架构中，取而代之的是Fiber对象。Fiber对象属性比较多，我们这次就只看它跟组件树构成有关系的属性：\\n\\n```javascript\\nfunction FiberNode(...) {\\n    // ...\\n\\n    this.child = null; // 第一个子节点\\n    this.sibling = null; // 相邻的下一个兄弟节点\\n    this.return = null; // 父节点\\n\\n    // ...\\n}\\n```\\n\\n可以看到，FiberNode有三个属性child、sibling、return。每个属性都链接了另一个fiber节点。由这三个属性构成了整颗fiber组件树。\\n\\n比如如下的一个JSX树结构：\\n```html\\n<App>\\n  <h1>\\n    <div></div>\\n  </h1>\\n  <Detail>\\n    <button></button>\\n  </Detail>\\n</App>\\n```\\n\\n构成的fiber树可以看下图：\\n\\n![fiber树](assets/fiber-node.jpg)\\n\\n有了这么一棵树，React是怎么实现树的遍历并且还可以中断呢。从React reconciler源码中，摘除掉只剩下关键部分，最后workLoop代码如下：\\n\\n```javascript\\nlet workInProgress; // 当前工作节点\\n\\nfunction workLoopConcurrent() {\\n  // 工作循环\\n  while (workInProgress != null && !shouldYield()) {\\n    performUnitOfWork(workInProgress);\\n  }\\n}\\n\\nfunction performUnitOfWork(unitOfWork) {\\n  // 对当前工作单元进行beginWork\\n  let next = beginWork(unitOfWork);\\n\\n  if (next == null) {\\n    // 如果没有下一个，对当前工作单元进行completeUnitOfWork\\n    completeUnitOfWork(unitOfWork);\\n  } else {\\n    // 如果有下一个，进入下一轮循环\\n    workInProgress = next;\\n  }\\n}\\n\\nfunction beginWork(unitOfWork) {\\n  // 模拟beginWork\\n  console.log(`begin work on [${unitOfWork.tag}]`);\\n\\n  // 将自己的child作为下一个工作单元\\n  return unitOfWork.child;\\n}\\n\\nfunction completeUnitOfWork(unitOfWork) {\\n  let completedWork = unitOfWork;\\n  do {\\n    // 模拟completeWork\\n    console.log(`complete work on [${completedWork.tag}]`);\\n\\n    const returnFiber = completedWork.return;\\n    const siblingFiber = completedWork.sibling;\\n    // 如果有兄弟节点，将兄弟节点作为下一个工作单元\\n    if (siblingFiber != null) {\\n      workInProgress = siblingFiber;\\n      return;\\n    }\\n\\n    // 否则，父节点作为completedWork，继续循环\\n    completedWork = returnFiber;\\n    workInProgress = completedWork;\\n  } while (completedWork != null);\\n}\\n\\n// 是否需要中断\\nfunction shouldYield() {\\n  return false;\\n}\\n```\\n\\n代码中保留了源码中的命名。可以看到React使用workInProgress来记录工作进度，同时它也是fiber对象。当workInProgress不为空时while循环，每执行完一个工作，就修改workInProgress指向下一个fiber。\\n\\n执行具体工作时，每一个unitOfWork（工作单元），先执行beginWork*（这里把beginWork的内容去掉了只留下了console，实际上React在此做fiber树构建，children协调工作）*。beginWork做完后，如果有child就把child当作下一个工作单元。如果没有child，说明当前fiber的子树都做完了beginWork。则执行completeWork*（实际上React在此做DOM创建、effectList串联等工作）*。\\n\\ncompleteWork做完后，如果有兄弟节点sibling，则把sibling作为下一个工作单元。如果没有兄弟节点了，说明当前fiber的兄弟也全部做完了beginWork和completeWork。是时候返回父节点，并让父节点做completeWork了。\\n\\n要返回父节点但是不能将父节点作为下一个workInProgress，否则就死循环了。只需要让它走completeWork即可。所以React在这里又套了一个循环，将父节点作为completedWork单元，执行上面所说的逻辑。\\n\\n接下来，我们测试下这个workLoop的执行流程。首先用代码创建上图中示例的fiber树：\\n\\n```javascript\\nfunction createFiber(tag) {\\n  return { tag, return: null, child: null, sibling: null };\\n}\\n\\n// 生成如下结构的fiber树\\n// <App>\\n//   <h1>\\n//     <div></div>\\n//   </h1>\\n//   <Detail>\\n//     <button></button>\\n//   </Detail>\\n// </App>\\nfunction generateFiberTree() {\\n  const app = createFiber(\\\"App\\\");\\n\\n  const h1 = createFiber(\\\"h1\\\");\\n  app.child = h1;\\n  h1.return = app;\\n\\n  const detail = createFiber(\\\"Detail\\\");\\n  h1.sibling = detail;\\n  detail.return = app;\\n\\n  const div = createFiber(\\\"div\\\");\\n  h1.child = div;\\n  div.return = h1;\\n\\n  const button = createFiber(\\\"button\\\");\\n  detail.child = button;\\n  button.return = detail;\\n\\n  return app;\\n}\\n```\\n\\n然后调用workLoop：\\n\\n```javascript\\nlet root = generateFiberTree();\\nworkInProgress = root;\\nworkLoopConcurrent();\\n```\\n\\n查看控制台日志：\\n\\n```shell\\nbegin work on [App]\\nbegin work on [h1]\\nbegin work on [div]\\ncomplete work on [div]\\ncomplete work on [h1]\\nbegin work on [Detail]\\nbegin work on [button]\\ncomplete work on [button]\\ncomplete work on [Detail]\\ncomplete work on [App]\\n```\\n\\n一切OK。看结果它和老架构一样，是自上而下，深度优先的遍历方式，只不过它不是递归实现的，而是通过`while循环+修改fiber工作指针`的形式。发散一下，如果我们要用递归的形式实现又是什么样子？直接上代码：\\n\\n```javascript\\n// 递归工作循环\\nfunction workLoopRecursive(unitOfWork) {\\n  // 模拟beginWork\\n  console.log(`begin work on [${unitOfWork.tag}]`);\\n\\n  if (unitOfWork.child !== null) {\\n    workLoopRecursive(unitOfWork.child);\\n  }\\n\\n  // 模拟completeWork\\n  console.log(`complete work on [${unitOfWork.tag}]`);\\n\\n  if (unitOfWork.sibling !== null) {\\n    workLoopRecursive(unitOfWork.sibling);\\n  }\\n}\\n// 运行测试\\nlet root = generateFiberTree();\\nworkLoopRecursive(root);\\n```\\n\\nLook！递归的代码简单太多了，而且return都不需要了。因为递归自己知道怎么返回！可以运行一下测试，会发现结果和上面的一样。\\n\\n既然递归这么简单，为什么要费这么大劲呢？前面就说到了，因为一旦递归就不可中断。那现在这种形式，又如何实现中断？\\n\\n### 中断执行\\n\\n回到workLoopConcurrent方法里，while的条件里有一个`shouldYield()`方法。React里就是用这个方法实现的可中断，并且由于workInProgress记录了工作进度，下一次就可以恢复工作！\\n\\n我们测试一下， 目前shouldYield方法里，直接`return false`。实际上React会在这里根据下一个更新的优先级，可能在这里`return true`。我们测试的话，就加个count吧，比如我们处理3个节点后，就中断处理。修改shouldYield方法：\\n\\n```javascript\\nlet count = 0;\\n// 是否需要中断\\nfunction shouldYield() {\\n  if (count++ >= 3) {\\n    return true;\\n  }\\n  return false;\\n}\\n```\\n\\n运行测试一下。结果为：\\n\\n```shell\\nbegin work on [App]\\nbegin work on [h1]\\nbegin work on [div]\\ncomplete work on [div]\\ncomplete work on [h1]\\n```\\n\\n可以看到，从根节点开始，执行了三个节点的work后就退出了。可能有同学要问了，为什么completWork执行了，但是只执行了两个？\\n\\n从上面的源码可以看到，completeWork是不中断的，只有beginWork的while循环才判断是否需要中断。所以只要工作单元及其子树的beginWork都做完了，就一定会执行它的completWork。只要没完全做完就不执行。所以App节点，因为它还没有处理完子树的beginWork，所以它的completeWork也就没有执行。从设计角度来说，这也是非常合理的。\\n\\n### 中断后恢复\\n\\n既然能中断，那就要能恢复。当前能在合适的时机下，再恢复工作进度吗？我们再改造一下shouldYield方法和测试代码，模拟一下中断然后立刻恢复：\\n\\n```javascript\\nlet max = 3;\\nlet count = 0;\\n// 是否需要中断\\nfunction shouldYield() {\\n  if (count++ >= max) { //使用max控制中断时机\\n    return true;\\n  }\\n  return false;\\n}\\n\\nlet root = generateFiberTree();\\nworkInProgress = root;\\nworkLoopConcurrent(); // 第一次工作循环\\n\\nconsole.log(\\\"work loop break off\\\\n\\\"); \\n\\n// 将第二次工作的中断次数调高\\nmax = 1000000;\\nconsole.log(\\\"work loop restart\\\")\\nworkLoopConcurrent();\\n```\\n\\n查看输出结果为：\\n\\n```shell\\nbegin work on [App]\\nbegin work on [h1]\\nbegin work on [div]\\ncomplete work on [div]\\ncomplete work on [h1]\\nwork loop break down\\n\\nwork loop restart\\nbegin work on [Detail]\\nbegin work on [button]\\ncomplete work on [button]\\ncomplete work on [Detail]\\ncomplete work on [App]\\n```\\n\\n非常牛x！看来确实实现了在哪里中断，就在哪里恢复，没有漏运行任何一个工作。这样的话，再搭配React16的异步调度器Scheduler，就可以实现渲染过程的中断、恢复，高优先级更新打断前一次更新等各种操作了。\\n\\n> 本文所用到的源码在[codeSandbox上](https://codesandbox.io/p/devbox/xj625g)。\\n\",\"n\":0.046}}},{\"i\":44,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"【造轮子】qiankun详解和手写\\\"\\ncover: ../static/assets/qiankun-cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"介绍一下qiankun解决微前端难题的方法，以及qiankun造轮子\\\"\\ndatePublished: \\\"2022-07-29 22:23:40\\\"\\ndateModified: \\\"2022-07-29 22:23:40\\\"\\nslug: \\\"qiankun-demo\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 前端\\n  - 微前端\\n  - 造轮子\\n---\\n\\n说到微前端，现在最火的方案就是[qiankun](https://qiankun.umijs.org/zh/guide)。qiankun的特点是易用性和完备性很高。说白了就是能很方便、快速的接入，同时bug少，功能强大。\\n\\n- [介绍](#介绍)\\n- [分析qiankun原理](#分析qiankun原理)\\n- [自己造一个qiankun](#自己造一个qiankun)\\n\\n---\\n\\n### 介绍\\n\\n微前端已经火了一段时间了，就不介绍了，直接贴图得了。\\n\\n![](../static/assets/qiankun-intro.jpg)\\n\\n话不多少，本次主要做两件事情：\\n\\n1. 拆解和解析qiankun源码\\n\\n2. 尝试qiankun造轮子\\n\\n### 分析qiankun原理\\n\\n截止现在，有很多大神已经将qiankun剖析得一清二楚。从各个层面去讲的都有，参考资料如下：\\n\\n> [作者介绍qiankun](https://zhuanlan.zhihu.com/p/78362028)<br/>\\n> [介绍Html Entry](https://juejin.cn/post/6885212507837825038)<br/>\\n> [介绍JavaScript沙盒](https://segmentfault.com/a/1190000040224359)<br/>\\n> [介绍CSS沙盒](https://segmentfault.com/a/1190000042018080)<br/>\\n> [清除副作用](https://segmentfault.com/a/1190000039200142#item-4)<br/>\\n> [应用间通信方案](https://segmentfault.com/a/1190000022583716)<br/>\\n\\n参考这么多的文档资料，以及自己阅读源码之后，我对qiankun主要功能的理解大概有这些：\\n\\n#### 基于single-spa\\n\\nqiankun基于[single-spa](https://single-spa.js.org/)，在它的基础上增加了很多功能。`single-spa`是基于`Js Entry`的方案的：需要将整个微应用打包成一个JS文件，包括图片、css等资源（缺点：体积庞大、无法并行加载资源、接入成本高）。而`Html Entry`则由于保留了html，通过html作为入口处理js、css等，天然的规避了这些问题。\\n\\nqiankun使用`single-spa`做了两件事情：\\n\\n- **注册和管理微应用（single-spa内部存储了apps信息）**\\n\\n    qiankun的app注册接口，会调用`single-spa`的`registerApplication`接口，保留它的路由规则和部分字段。`single-spa`的`registerApplication`接口，app参数需要传入一个包含生命周期函数的对象或工厂函数。\\n    \\n    ```javascript\\n    registerApplication({\\n      name: 'app1',\\n      activeWhen: '/app1',\\n      app: () => import(\\\"src/app1/main.js\\\") // 即Js Entry。其中main.js需要导出四个生命周期函数\\n    })\\n    ```\\n\\n    而qiankun由于不使用`Js Entry`，所以在`app()`异步函数里，qiankun不是来导入js文件，而是从`Html Entry`开始：*fetch html文件 => 创建和设置子应用dom => 创建沙盒 => 执行子应用js文件（此时可获取到子应用导出的lifecycles） => 包装lifecycles并返回 *。\\n\\n    > 参考代码：[qiankun调用single-spa注册app](https://github.com/umijs/qiankun/blob/master/src/apis.ts#L73)、[loadApp()里做了什么](https://github.com/umijs/qiankun/blob/master/src/loader.ts#L244)\\n\\n- **根据路由规则切换微应用（触发微应用状态变更，需要自己实现各个状态回调）**\\n\\n    `single-spa`已经实现了hash路由和history路由的监听，然后根据子应用的激活路由规则，来调用对应子应用的生命周期函数。qiankun就拿来直接用，反正最后都会进入前面我们提到的生命周期函数。\\n\\n#### 从Html Entry入手\\n\\n前面提到，qiankun在app()函数里不是导入js而是处理的`Html Entry`。qiankun作者将这一部分封装成了一个独立的库[import-html-entry](https://github.com/kuitos/import-html-entry)。这里面包括的功能有：\\n\\n- **fetch html文件**\\n- **处理html内容转为template字符串**\\n- **获取scripts，包括内部和外部scripts**\\n- **对script进行包装，控制js在指定的window中运行（js沙箱的基础）**\\n- **获取内部和外部样式表**\\n\\n可以看出这个库主要就是从`Html Entry`入手处理template、script和style，都只是处理，并没有执行，执行在qiankun源码中。不再细说，细节可以看它的源码或者其他大牛的解读。\\n\\n#### Js沙箱\\n\\n`Js沙箱`的目的是为了让子应用拥有自己私有的全局环境。防止子应用修改的全局变量影响到主应用或其他子应用。qiankun实现了三种`Js沙箱`：\\n\\n- **快照沙箱 - snapshotSandbox**\\n\\n    [snapshotSandbox](https://github.com/umijs/qiankun/blob/master/src/sandbox/snapshotSandbox.ts)是在不支持Proxy的浏览器环境下才会使用的。原理是在子应用挂载时，备份当前window存入snapshot（同时恢复上一次卸载时最后的状态）；卸载时恢复window为snapshot的状态（同时记录应用变更了哪些状态）。\\n\\n    由于它会遍历window对象，所以性能最差。同时它修改了window对象，所以它无法做到主应用和子应用的隔离，只做到了单个子应用相互之间的隔离，多个子应用同时加载时也不行。\\n\\n- **单例代理沙箱 - legacySandBox**\\n\\n    [legacySandBox](https://github.com/umijs/qiankun/blob/master/src/sandbox/legacy/sandbox.ts)是一个使用Proxy的沙箱。它的原理和快照沙箱一样是记录变更和恢复：创建一个window的proxy（子应用操作的是这个proxy），监听`set()`并收集更新（set仍然会同步window，get直接从window取）。在子应用挂载时，恢复window为上一次卸载时状态；卸载时恢复为挂载前状态。只不过由于使用了代理，它能准确知道哪些变量发生了变化，而不用像快照沙箱那样遍历整个window对象才能知道变化。\\n\\n    所以它的性能会好于快照沙箱，但是它仍然操作的是window全局对象，所以也无法做到主应用和子应用的隔离，多个子应用同时加载也一样有问题。\\n\\n- **多例代理沙箱 - proxySandBox**\\n\\n    [proxySandBox](https://github.com/umijs/qiankun/blob/master/src/sandbox/proxySandbox.ts)也是一个使用Proxy技术的沙箱。只不过它是完全代理了window并替代之。每个子应用都使用的是自己的proxy而不是全局的window。它的原理是创建一个window的proxy。把window的属性都拷贝上去，完全就是一个副本。每个子应用唯一。子应用操作的一直都是这个proxy，所以挂载和卸载都不需要做什么处理。\\n\\n    由于window全局属性太多，处理的异常也非常多，有的函数和变量还必须从原始window获取。所以这部分代码还是很复杂的，作者估计也是做了非常多的bugfix。\\n\\n    好处也是非常明显，主应用window不会被污染，子应用之间也完全隔离，多个子应用同时加载也互不影响。\\n\\n> 其中代理沙箱提供了proxy，子应用必须要让自己的js代码运行在这个proxy全局变量下（比如window、self、top、document、location等等）。这一部分是`import-html-entry`插件在[处理javascript脚本](https://github.com/kuitos/import-html-entry/blob/master/src/index.js#L70)时实现的。说白了就是`eval + function + with`让全局变量都从proxy中查询，并越过了严格模式的安全性错误。\\n\\n#### Css隔离\\n\\n`Css隔离`的目的是为了让子应用的Css与主应用或其他子应用的隔离开，防止相互影响。qiankun有三类隔离方式：\\n\\n- **默认方式**\\n\\n    qiankun的默认处理是将子应用的内部样式表、外部样式表、还有`css-in-js`技术在运行时创建的样式表，拦截并创建到子应用自己的dom树下，卸载时也一并移除。如果不做这个拦截处理，那子应用的样式表将会出现在根节点`<head>`标签下，`Shadom DOM`模式开启后子应用就找不到这些样式了。\\n    \\n    查看源码中函数调用关系：`[src/loader.ts].loadApp` => `[src/sandbox/index].createSandboxContainer` => `[src/sandbox/patchers/index].patchAtMounting`，查看[patchersInSandbox方法](https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/index.ts#L29)。对于`快照沙箱`和`单例代理沙箱`，使用[forLooseSandbox](https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/dynamicAppend/forLooseSandbox.ts)，对于`多例代理沙箱`，使用[forStrictSandbox](https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/dynamicAppend/forStrictSandbox.ts)。细节看源码即可。\\n\\n    默认方式不需要手动开启，它能保证单例场景子应用之间的样式隔离，但是无法保证主应用和子应用，及多实例时子应用之间的样式隔离。\\n\\n- **Shadom DOM**\\n\\n    qiankun支持使用`Shadom DOM`实现`严格样式隔离`，它会在子应用dom根节点创建`Shadow DOM`，就能确保子应用和主应用，子应用之间的样式污染问题。但是它并不是完美方案。缺点就是一些弹窗需要挂载到`document.body`下，这是就跳出了`Shadow DOM`边界，弹窗样式也就无法起作用了。\\n\\n    通过```start({ sandbox: { strictStyleIsolation: true } })```启用。\\n\\n- **样式转换**\\n\\n    qiankun会对子应用添加的样式改写，在子应用的根部dom节点增加一个`data-qiankun`属性，并对子应用的所有样式规则，添加一个`div[data-qiankun=\\\"xxx\\\"]`的属性选择器，这样子来保证只有子应用的dom树下，才能生效这些样式。能保证主应用和子应用，子应用之间的样式隔离。\\n\\n    通过```start({ sandbox: { experimentalStyleIsolation: true } })```启用。\\n\\n- **其他**\\n\\n    非qiankun框架提供。在项目中我们可以有其他确保样式隔离的方案：唯一的css命名前缀、css modules、CSS-in-js。\\n\\n#### 清除副作用\\n\\n子应用使用`window.addEventListener`或者`setInterval`等全局api时，如果子应用卸载时不移除掉，则会对其他应用带来副作用。\\n\\n代码是在`patchers`.[patchAtMounting](https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/index.ts#L22)方法中。调用`patchInterval`和`patchWindowListener`来清除副作用的。`patch`方法内部，拦截了原生的方法，每次调用时记录下来。`patch`方法返回`free()`函数，用于在子应用卸载时，[清除副作用](https://github.com/umijs/qiankun/blob/master/src/sandbox/index.ts#L105)。\\n\\n#### 通信方案\\n\\n- **官方Actions方案**\\n\\n官方是事件监听的形式，监听全局状态的变更。主应用初始化状态，通过`mount(props)`生命周期下发到子应用。子应用可以监听和set。\\n\\n实现原理是主应用负责初始化和存储全局states，提供接口到子应用，子应用添加listener，主应用管理listeners。在任意应用调用setState接口时，都触发listener回调。\\n\\n- **SharedState方案**\\n\\n更常见的情况是，项目中已经集成了状态管理库`Redux`、`Zustand`或其他。这时候就可以使用官方Actions方案当作桥梁，打通主应用、子应用的状态数据同步。并且子应用在独立运行的时候仍然使用自身的状态管理库获取数据，在嵌入主应用时，使用全局状态数据。主应用或子应用使用全局状态时，只需要使用一个hooks：\\n\\n```typescript\\n// 获取和设置全局状态，响应式\\nconst [app, setApp] = useSharedState('AppInfo');\\n```\\n\\n实现原理就是主应用和子应用都可以创建自己的`SharedState`，即中间层，在这里去实现针对不同状态管理库的状态获取、设置和监听。子应用如果是在qiankun环境，则从主应用获取`SharedState`重载掉自己本地的。然后再提供一个Hooks Api。\\n\\n```typescript\\n/**\\n * 操作某一个共享状态的Hooks API。\\n * 使用方法类似于React.useState，返回[state, setter]。\\n */\\nexport function useSharedState<K extends keyof SharedState>(stateName: K): readonly [StateTypeOf<SharedState[K]>, (d: StateTypeOf<SharedState[K]>) => void] {\\n  const so: SharedState[K] = state[stateName];\\n  // 使用useState，让其转为响应式的状态\\n  const [d, setD] = useState(so.get());\\n  // 监听主应用状态变化，并setState\\n  useEffect(() => {\\n    return so.subscribe(setD); // 组件销毁时，停止监听\\n  }, [so]);\\n  // 有共享状态时\\n  return [d, so.set] as const;\\n}\\n```\\n\\n这里写得比较简单。有时间我再单独出一期方案详解。\\n\\n### 自己造一个qiankun\\n\\n**qiankun原理介绍就这些，下面我们开始正题！自己模仿造一个qiankun轮子出来，抛开健壮性不谈，至少能用！**\\n\\n#### 项目结构\\n\\n保持qiankun的功能模块设计，特拆分几个文件如下：\\n\\n```shell\\n- qiankun.ts            # qiankun的主功能\\n- single-spa.ts         # 类似于single-spa的功能\\n- import-html-entry.ts  # 类似于import-html-entry的功能\\n- sandbox               # 存放沙箱\\n  - index.ts            # 沙箱容器，控制沙箱创建、加载、卸载\\n  - LegacySandbox.ts    # 单例代理沙箱\\n  - ProxySandbox.ts     # 多例代理沙箱\\n  - SnapshotSandbox.ts  # 快照沙箱\\n- patchers              # 存放副作用补丁\\n  - intervals.ts        # intervals副作用补丁\\n  - listeners.ts        # listeners副作用补丁\\n- globalState.ts        # 全局state状态\\n```\\n\\n#### single-spa.ts\\n\\n功能：管理注册应用、根据路由切换应用。写完后代码如下：\\n\\n```typescript\\nexport function registerApplication(appConfig: AppConfig) {\\n  _apps.push({\\n    status: AppStatus.NOT_LOADED,\\n    ...appConfig,\\n  });\\n}\\n\\nlet isStarted = false;\\n\\nexport function start() {\\n  if (isStarted) return;\\n\\n  isStarted = true;\\n  reroute();\\n}\\n\\nlet _prevRoute: string, _nextRoute: string;\\n\\nfunction reroute() {\\n  const tryFetchActiveApp = async (pathname: string) => {\\n    _prevRoute = _nextRoute;\\n    _nextRoute = pathname;\\n    const prevApp = _apps.find((app) => _prevRoute?.startsWith(app.activeWhen));\\n    // find the active app\\n    const activeApp = _apps.find((app) => pathname.startsWith(app.activeWhen));\\n    // if the previous app is the same as the active app, do nothing\\n    if (prevApp && activeApp && prevApp.name === activeApp.name) return;\\n\\n    // unmount the previous app\\n    if (prevApp) {\\n      if (prevApp.status === AppStatus.MOUNTED)\\n        prevApp.status = AppStatus.NOT_LOADED;\\n        callOrArrayCall(prevApp.unmount, {});\\n    }\\n    // fetch the active app\\n    if (activeApp) {\\n      if (activeApp?.status === AppStatus.NOT_LOADED) {\\n        activeApp.status = AppStatus.MOUNTING;\\n        activeApp.app().then((lifeCycles) => {\\n          Object.assign(activeApp, lifeCycles);\\n          activeApp.status = AppStatus.MOUNTED;\\n          callOrArrayCall(activeApp.bootstrap, {});\\n          callOrArrayCall(activeApp.mount, {});\\n        });\\n      } else {\\n        callOrArrayCall(activeApp.bootstrap, {});\\n        callOrArrayCall(activeApp.mount, {});\\n      }\\n    }\\n  };\\n\\n  function callOrArrayCall<ExtraProps extends any>(\\n    func: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>> | undefined,\\n    props: any\\n  ) {\\n    if (Array.isArray(func)) {\\n      func.forEach((fn) => fn(props));\\n    } else {\\n      func?.(props);\\n    }\\n  }\\n\\n  // history.forward() or history.back() or history.go()\\n  window.addEventListener(\\\"popstate\\\", () => {\\n    tryFetchActiveApp(window.location.pathname);\\n  });\\n\\n  window.history.pushState = new Proxy(window.history.pushState, {\\n    apply(target, thisArg, args) {\\n      const pathname = args[2];\\n      tryFetchActiveApp(pathname);\\n      // @ts-ignore\\n      return target.apply(thisArg, args);\\n    },\\n  });\\n\\n  window.history.replaceState = new Proxy(window.history.replaceState, {\\n    apply(target, thisArg, args) {\\n      const pathname = args[2];\\n      tryFetchActiveApp(pathname);\\n      // @ts-ignore\\n      return target.apply(thisArg, args);\\n    },\\n  });\\n\\n  // 首次加载\\n  setTimeout(() => {\\n    tryFetchActiveApp(window.location.pathname);\\n  }, 400);\\n}\\n```\\n\\n#### import-html-entry.ts\\n\\n主要功能：导入html，加载css和javascript。写完后代码如下：\\n\\n```typescript\\nexport async function importEntry(entry: string) {\\n  return importHtml(entry);\\n}\\n\\nasync function importHtml(entry: string) {\\n  // fetch html entry of app\\n  const response = await fetch(entry);\\n  const text = await response.text();\\n  const html = document.createElement(\\\"div\\\");\\n  html.innerHTML = text;\\n\\n  // script will not be executed when html is appended to the DOM\\n  // so we need to create script elements and append them to the DOM\\n  const scripts = html.querySelectorAll(\\\"script\\\");\\n  const scriptContents = await fetchScript(entry, ...scripts);\\n\\n  return {\\n    template: html,\\n    execScripts: (proxy: Window) => {\\n      scriptContents.forEach((scriptContent) => {\\n        const code = getExecutableScript(\\n          scriptContent.src,\\n          scriptContent.code,\\n          { proxy }\\n        );\\n        evalCode(scriptContent.src, code);\\n      });\\n    },\\n  };\\n}\\n\\nasync function fetchScript(prefix: string, ...scripts: HTMLScriptElement[]) {\\n  let scriptContents: { code: string; src: string }[] = [];\\n  for (let i = 0; i < scripts.length; i++) {\\n    const script = scripts[i];\\n    if (script.textContent) {\\n      scriptContents.push({ code: script.textContent, src: \\\"\\\" });\\n      continue;\\n    }\\n    let src = script.attributes.getNamedItem(\\\"src\\\")?.value;\\n    if (!src) continue;\\n    if (\\n      !src.startsWith(\\\"http\\\") &&\\n      !src.startsWith(\\\"//\\\") &&\\n      !src.startsWith(\\\"https\\\")\\n    ) {\\n      src = prefix + \\\"/\\\" + src;\\n    }\\n    const response = await fetch(src);\\n    let scriptContent = await response.text();\\n    scriptContents.push({ code: scriptContent, src });\\n  }\\n\\n  return scriptContents;\\n}\\n\\nfunction getExecutableScript(\\n  scriptSrc: String,\\n  scriptText: string,\\n  opts: { proxy: Window }\\n) {\\n  const { proxy } = opts;\\n\\n  const sourceUrl = `//# sourceURL=${scriptSrc}\\\\n`;\\n\\n  const globalWindow = (0, eval)(\\\"window\\\");\\n  globalWindow.proxy = proxy;\\n  return `;(function(window, self, globalThis){with(window){;${scriptText}\\\\n}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\\n}\\n\\nconst evalCache: Record<string, any> = {};\\n\\nexport function evalCode(scriptSrc: string, code: string) {\\n  const key = scriptSrc;\\n  if (!evalCache[key]) {\\n    const functionWrappedCode = `(function(){${code}})`;\\n    evalCache[key] = (0, eval)(functionWrappedCode);\\n  }\\n  const evalFunc = evalCache[key];\\n  evalFunc.call(window);\\n}\\n```\\n\\n#### sandbox/index.ts\\n\\n主要功能：创建沙箱容器，初始化、加载和卸载沙箱，清除副作用。写完后代码如下：\\n\\n```typescript\\nimport { Freer, patchSideEffects } from \\\"../patchers\\\";\\nimport LegacySandbox from \\\"./js/LegacySandbox\\\";\\nimport ProxySandbox from \\\"./js/ProxySandbox\\\";\\nimport SnapshotSandbox from \\\"./js/SnapshotSandbox\\\";\\n\\nexport type SandBox = {\\n  /** 沙箱的名字 */\\n  name: string;\\n  /** 沙箱导出的代理实体 */\\n  proxy: WindowProxy;\\n  /** 沙箱是否在运行中 */\\n  sandboxRunning: boolean;\\n  /** latest set property */\\n  latestSetProp?: PropertyKey | null;\\n  /** 启动沙箱 */\\n  active: () => void;\\n  /** 关闭沙箱 */\\n  inactive: () => void;\\n};\\n\\nexport function createSandboxContainer(\\n  appName: string,\\n  globalContext: Window,\\n  proxy: boolean = true,\\n  multi: boolean = true\\n) {\\n  let sandbox: SandBox;\\n  if (proxy) {\\n    sandbox = multi\\n      ? new ProxySandbox(appName, globalContext)\\n      : new LegacySandbox(appName, globalContext);\\n  } else {\\n    sandbox = new SnapshotSandbox(appName);\\n  }\\n\\n  let mountingFreers: Freer[] = [];\\n\\n  return {\\n    instance: sandbox,\\n    mount() {\\n      // 1. 启动/恢复沙箱\\n      sandbox.active();\\n\\n      // 2. 开启全局变量补丁\\n      mountingFreers = patchSideEffects(sandbox.proxy);\\n    },\\n\\n    unmount() {\\n      // 1. 释放全局变量补丁\\n      mountingFreers.forEach((free) => free());\\n\\n      // 2. 关闭沙箱\\n      sandbox.inactive();\\n    },\\n  };\\n}\\n```\\n\\n#### sandbox/SnapshotSandbox.ts\\n\\n主要功能：快照沙箱。写完后代码如下：\\n\\n```typescript\\nimport { SandBox } from \\\"..\\\";\\n\\nfunction iter(\\n  obj: typeof window | Record<any, any>,\\n  callbackFn: (prop: any) => void\\n) {\\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\\n  for (const prop in obj) {\\n    // patch for clearInterval for compatible reason, see #1490\\n    if (obj.hasOwnProperty(prop) || prop === \\\"clearInterval\\\") {\\n      callbackFn(prop);\\n    }\\n  }\\n}\\n\\nexport default class SnapshotSandbox implements SandBox {\\n  name: string;\\n  proxy: WindowProxy;\\n  sandboxRunning: boolean;\\n\\n  private windowSnapshot!: Window;\\n\\n  private modifyPropsMap: Record<any, any> = {};\\n\\n  private deletePropsSet: Set<any> = new Set();\\n\\n  constructor(name: string) {\\n    this.name = name;\\n    this.proxy = window;\\n    this.sandboxRunning = false;\\n  }\\n\\n  active() {\\n    this.windowSnapshot = {} as Window;\\n\\n    // 保存当前window到快照\\n    iter(window, (prop) => {\\n      this.windowSnapshot[prop] = window[prop];\\n    });\\n\\n    // 恢复上次的变更\\n    Object.keys(this.modifyPropsMap).forEach((p: any) => {\\n      window[p] = this.modifyPropsMap[p];\\n    });\\n\\n    // 删除上次删除的属性\\n    this.deletePropsSet.forEach((p: any) => {\\n      delete window[p];\\n    });\\n\\n    // active\\n    this.sandboxRunning = true;\\n  }\\n\\n  inactive() {\\n    this.modifyPropsMap = {};\\n    this.deletePropsSet.clear();\\n\\n    iter(window, (prop) => {\\n      // 记录变更的属性到modifyPropsMap\\n      if (window[prop] !== this.windowSnapshot[prop]) {\\n        this.modifyPropsMap[prop] = window[prop];\\n        // 恢复回去\\n        window[prop] = this.windowSnapshot[prop];\\n      }\\n\\n      delete this.windowSnapshot[prop];\\n    });\\n\\n    iter(this.windowSnapshot, (prop) => {\\n      // 记录删除的属性到deletePropsSet\\n      if (!window.hasOwnProperty(prop)) {\\n        this.deletePropsSet.add(prop);\\n\\n        window[prop] = this.windowSnapshot[prop];\\n      }\\n    });\\n\\n    // inactive\\n    this.sandboxRunning = false;\\n  }\\n}\\n```\\n\\n#### sandbox/LegacySandbox.ts\\n\\n主要功能：单例代理沙箱。写完后代码如下：\\n\\n```typescript\\nimport { SandBox } from \\\"..\\\";\\n\\nconst callableFnCacheMap = new WeakMap();\\nconst boundedMap = new WeakMap<CallableFunction, boolean>();\\nconst fnRegexCheckCacheMap = new WeakMap<any | FunctionConstructor, boolean>();\\n\\nfunction isCallable(fn: any) {\\n  if (callableFnCacheMap.has(fn)) {\\n    return true;\\n  }\\n  const naughtySafari =\\n    typeof document.all === \\\"function\\\" && typeof document.all === \\\"undefined\\\";\\n  const callable = naughtySafari\\n    ? typeof fn === \\\"function\\\" && typeof fn !== \\\"undefined\\\"\\n    : typeof fn === \\\"function\\\";\\n  if (callable) {\\n    callableFnCacheMap.set(fn, callable);\\n  }\\n  return callable;\\n}\\n\\nfunction isBoundedFunction(fn: CallableFunction) {\\n  if (boundedMap.has(fn)) {\\n    return boundedMap.get(fn);\\n  }\\n  /*\\n   indexOf is faster than startsWith\\n   see https://jsperf.com/string-startswith/72\\n   */\\n  const bounded =\\n    fn.name.indexOf(\\\"bound \\\") === 0 && !fn.hasOwnProperty(\\\"prototype\\\");\\n  boundedMap.set(fn, bounded);\\n  return bounded;\\n}\\n\\nexport function isConstructable(fn: () => any | FunctionConstructor) {\\n  // prototype methods might be changed while code running, so we need check it every time\\n  const hasPrototypeMethods =\\n    fn.prototype &&\\n    fn.prototype.constructor === fn &&\\n    Object.getOwnPropertyNames(fn.prototype).length > 1;\\n\\n  if (hasPrototypeMethods) return true;\\n\\n  if (fnRegexCheckCacheMap.has(fn)) {\\n    return fnRegexCheckCacheMap.get(fn);\\n  }\\n\\n  /*\\n    1. 有 prototype 并且 prototype 上有定义一系列非 constructor 属性\\n    2. 函数名大写开头\\n    3. class 函数\\n    满足其一则可认定为构造函数\\n   */\\n  let constructable = hasPrototypeMethods;\\n  if (!constructable) {\\n    // fn.toString has a significant performance overhead, if hasPrototypeMethods check not passed, we will check the function string with regex\\n    const fnString = fn.toString();\\n    const constructableFunctionRegex = /^function\\\\b\\\\s[A-Z].*/;\\n    const classRegex = /^class\\\\b/;\\n    constructable =\\n      constructableFunctionRegex.test(fnString) || classRegex.test(fnString);\\n  }\\n\\n  fnRegexCheckCacheMap.set(fn, constructable);\\n  return constructable;\\n}\\n\\nexport function getTargetValue(target: any, value: any) {\\n  /*\\n    仅绑定 isCallable && !isBoundedFunction && !isConstructable 的函数对象，如 window.console、window.atob 这类。目前没有完美的检测方式，这里通过 prototype 中是否还有可枚举的拓展方法的方式来判断\\n    @warning 这里不要随意替换成别的判断方式，因为可能触发一些 edge case（比如在 lodash.isFunction 在 iframe 上下文中可能由于调用了 top window 对象触发的安全异常）\\n   */\\n  if (\\n    isCallable(value) &&\\n    !isBoundedFunction(value) &&\\n    !isConstructable(value)\\n  ) {\\n    const boundValue = Function.prototype.bind.call(value, target);\\n    for (const key in value) {\\n      boundValue[key] = value[key];\\n    }\\n    if (\\n      value.hasOwnProperty(\\\"prototype\\\") &&\\n      !boundValue.hasOwnProperty(\\\"prototype\\\")\\n    ) {\\n      Object.defineProperty(boundValue, \\\"prototype\\\", {\\n        value: value.prototype,\\n        enumerable: false,\\n        writable: true,\\n      });\\n    }\\n\\n    return boundValue;\\n  }\\n\\n  return value;\\n}\\n\\nexport default class LegacySandbox implements SandBox {\\n  name: string;\\n  proxy: WindowProxy;\\n  sandboxRunning = true;\\n\\n  globalContext: Window;\\n  // 新增的属性\\n  addedPropsMapInSandbox = new Map();\\n  // 修改的属性\\n  modifiedPropsOriginalValueMap = new Map();\\n  // 始终记录的最新值\\n  currentUpdatedPropsValueMap = new Map();\\n\\n  constructor(name: string, global: WindowProxy) {\\n    this.name = name;\\n\\n    this.globalContext = global;\\n    const rawWindow = global as any;\\n    const fakeWindow = Object.create(null);\\n\\n    const {\\n      addedPropsMapInSandbox,\\n      modifiedPropsOriginalValueMap,\\n      currentUpdatedPropsValueMap,\\n    } = this;\\n\\n    const proxy = new Proxy(fakeWindow, {\\n      set: (_, p, value) => {\\n        if (this.sandboxRunning) {\\n          if (!rawWindow.hasOwnProperty(p)) {\\n            // 这是新增的属性，记录下来，用于inactive时删除\\n            addedPropsMapInSandbox.set(p, value);\\n          } else if (!modifiedPropsOriginalValueMap.has(p)) {\\n            // 这个属性被修改了，记录原始值，方便inactive时恢复window\\n            const originalVal = rawWindow[p];\\n            modifiedPropsOriginalValueMap.set(p, originalVal);\\n          }\\n\\n          // 总是记录最新的值，方便active时同步到真实window\\n          currentUpdatedPropsValueMap.set(p, value);\\n\\n          rawWindow[p] = value;\\n        }\\n\\n        return true;\\n      },\\n\\n      get(_: Window, p: PropertyKey): any {\\n        // avoid who using window.window or window.self to escape the sandbox environment to touch the really window\\n        // or use window.top to check if an iframe context\\n        // see https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L13\\n        if (p === \\\"top\\\" || p === \\\"parent\\\" || p === \\\"window\\\" || p === \\\"self\\\") {\\n          return proxy;\\n        }\\n\\n        const value = (rawWindow as any)[p];\\n        return getTargetValue(rawWindow, value);\\n      },\\n\\n      has(_, p) {\\n        //返回boolean\\n        return p in rawWindow;\\n      },\\n\\n      getOwnPropertyDescriptor(_, p) {\\n        const descriptor = Object.getOwnPropertyDescriptor(rawWindow, p);\\n        // 如果属性不作为目标对象的自身属性存在，则不能将其设置为不可配置\\n        if (descriptor && !descriptor.configurable) {\\n          descriptor.configurable = true;\\n        }\\n        return descriptor;\\n      },\\n    });\\n\\n    this.proxy = proxy;\\n  }\\n\\n  active() {\\n    if (!this.sandboxRunning) {\\n      this.currentUpdatedPropsValueMap.forEach((value, key) =>\\n        this.setWindowProp(key, value)\\n      );\\n    }\\n    // active\\n    this.sandboxRunning = true;\\n  }\\n\\n  inactive() {\\n    this.modifiedPropsOriginalValueMap.forEach((value, key) =>\\n      this.setWindowProp(key, value)\\n    );\\n    this.addedPropsMapInSandbox.forEach((_, key) =>\\n      this.setWindowProp(key, undefined, true)\\n    );\\n\\n    // inactive\\n    this.sandboxRunning = false;\\n  }\\n\\n  private setWindowProp(prop: PropertyKey, value: any, toDelete?: boolean) {\\n    if (value === undefined && toDelete) {\\n      delete (this.globalContext as any)[prop];\\n    } else {\\n      (this.globalContext as any)[prop] = value;\\n    }\\n  }\\n}\\n```\\n\\n#### sandbox/ProxySandbox.ts\\n\\n主要功能：代理沙箱。写完后代码如下：\\n\\n```typescript\\nimport { without } from \\\"lodash\\\";\\n\\nimport { SandBox } from \\\"..\\\";\\nimport { getTargetValue } from \\\"./LegacySandbox\\\";\\nimport { array2TruthyObject, nativeGlobal } from \\\"../../common\\\";\\nimport { globalsInBrowser, globalsInES2015 } from \\\"../../globals\\\";\\n\\nconst frozenPropertyCacheMap = new WeakMap<any, Record<PropertyKey, boolean>>();\\n\\nexport function isPropertyFrozen(target: any, p?: PropertyKey): boolean {\\n  if (!target || !p) {\\n    return false;\\n  }\\n\\n  const targetPropertiesFromCache = frozenPropertyCacheMap.get(target) || {};\\n\\n  if (targetPropertiesFromCache[p]) {\\n    return targetPropertiesFromCache[p];\\n  }\\n\\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(target, p);\\n  const frozen = Boolean(\\n    propertyDescriptor &&\\n      propertyDescriptor.configurable === false &&\\n      (propertyDescriptor.writable === false ||\\n        (propertyDescriptor.get && !propertyDescriptor.set))\\n  );\\n\\n  targetPropertiesFromCache[p] = frozen;\\n  frozenPropertyCacheMap.set(target, targetPropertiesFromCache);\\n\\n  return frozen;\\n}\\n\\n// these globals should be recorded while accessing every time\\nconst accessingSpiedGlobals = [\\\"document\\\", \\\"top\\\", \\\"parent\\\", \\\"eval\\\"];\\nconst overwrittenGlobals = [\\\"window\\\", \\\"self\\\", \\\"globalThis\\\", \\\"hasOwnProperty\\\"];\\nexport const cachedGlobals = Array.from(\\n  new Set(\\n    without(\\n      globalsInES2015.concat(overwrittenGlobals).concat(\\\"requestAnimationFrame\\\"),\\n      ...accessingSpiedGlobals\\n    )\\n  )\\n);\\n\\nconst unscopables = array2TruthyObject(\\n  without(cachedGlobals, ...accessingSpiedGlobals.concat(overwrittenGlobals))\\n);\\n\\nconst useNativeWindowForBindingsProps = new Map<PropertyKey, boolean>([\\n  ['fetch', true],\\n  ['mockDomAPIInBlackList', process.env.NODE_ENV === 'test'],\\n]);\\n\\nconst cachedGlobalsInBrowser = array2TruthyObject(\\n  globalsInBrowser.concat(process.env.NODE_ENV === 'test' ? ['mockNativeWindowFunction'] : []),\\n);\\n\\nfunction isNativeGlobalProp(prop: string): boolean {\\n  return prop in cachedGlobalsInBrowser;\\n}\\n\\nconst globalVariableWhiteList: string[] = [\\n  // FIXME System.js used a indirect call with eval, which would make it scope escape to global\\n  // To make System.js works well, we write it back to global window temporary\\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/evaluate.js#L106\\n  \\\"System\\\",\\n\\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/instantiate.js#L357\\n  \\\"__cjsWrapper\\\",\\n];\\n\\n// 创建一个假的window对象，将window的属性拷贝到这个对象上。\\n// 后续对window的操作，都通过这个假的window对象进行。不影响真实的window对象。\\nfunction createFakeWindow(globalContext: Window, speedy: boolean) {\\n  // map always has the fastest performance in has checked scenario\\n  // see https://jsperf.com/array-indexof-vs-set-has/23\\n  const propertiesWithGetter = new Map<PropertyKey, boolean>();\\n  const fakeWindow = {} as any;\\n\\n  /*\\n   copy the non-configurable property of global to fakeWindow\\n   see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor\\n   > A property cannot be reported as non-configurable, if it does not exist as an own property of the target object or if it exists as a configurable own property of the target object.\\n   */\\n  Object.getOwnPropertyNames(globalContext)\\n    .filter((p) => {\\n      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\\n      return !descriptor?.configurable;\\n    })\\n    .forEach((p) => {\\n      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\\n      if (descriptor) {\\n        const hasGetter = Object.prototype.hasOwnProperty.call(\\n          descriptor,\\n          \\\"get\\\"\\n        );\\n\\n        /*\\n         make top/self/window property configurable and writable, otherwise it will cause TypeError while get trap return.\\n         see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get\\n         > The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable data property.\\n         */\\n        if (\\n          p === \\\"top\\\" ||\\n          p === \\\"parent\\\" ||\\n          p === \\\"self\\\" ||\\n          p === \\\"window\\\" ||\\n          // window.document is overwriting in speedy mode\\n          (p === \\\"document\\\" && speedy)\\n        ) {\\n          descriptor.configurable = true;\\n          /*\\n           The descriptor of window.window/window.top/window.self in Safari/FF are accessor descriptors, we need to avoid adding a data descriptor while it was\\n           Example:\\n            Safari/FF: Object.getOwnPropertyDescriptor(window, 'top') -> {get: function, set: undefined, enumerable: true, configurable: false}\\n            Chrome: Object.getOwnPropertyDescriptor(window, 'top') -> {value: Window, writable: false, enumerable: true, configurable: false}\\n           */\\n          if (!hasGetter) {\\n            descriptor.writable = true;\\n          }\\n        }\\n\\n        if (hasGetter) propertiesWithGetter.set(p, true);\\n\\n        // freeze the descriptor to avoid being modified by zone.js\\n        // see https://github.com/angular/zone.js/blob/a5fe09b0fac27ac5df1fa746042f96f05ccb6a00/lib/browser/define-property.ts#L71\\n        Object.defineProperty(fakeWindow, p, Object.freeze(descriptor));\\n      }\\n    });\\n\\n  return {\\n    fakeWindow,\\n    propertiesWithGetter,\\n  };\\n}\\n\\nexport default class ProxySandbox implements SandBox {\\n  name: string;\\n  proxy: WindowProxy;\\n  private document = document;\\n  globalContext: Window;\\n  sandboxRunning = true;\\n\\n  globalWhitelistPrevDescriptor: {\\n    [p in (typeof globalVariableWhiteList)[number]]:\\n      | PropertyDescriptor\\n      | undefined;\\n  } = {};\\n\\n  constructor(name: string, global: WindowProxy) {\\n    this.name = name;\\n    const globalContext = global;\\n    this.globalContext = globalContext;\\n\\n    const { fakeWindow, propertiesWithGetter } = createFakeWindow(global, true);\\n    const proxy = new Proxy(fakeWindow, {\\n      set: (target, p, value) => {\\n        if (this.sandboxRunning) {\\n          if (\\n            typeof p === \\\"string\\\" &&\\n            globalVariableWhiteList.indexOf(p) !== -1\\n          ) {\\n            this.globalWhitelistPrevDescriptor[p] =\\n              Object.getOwnPropertyDescriptor(globalContext, p);\\n            // @ts-ignore\\n            globalContext[p] = value;\\n          } else {\\n            // We must keep its description while the property existed in globalContext before\\n            if (!target.hasOwnProperty(p) && globalContext.hasOwnProperty(p)) {\\n              const descriptor = Object.getOwnPropertyDescriptor(\\n                globalContext,\\n                p\\n              );\\n              const { writable, configurable, enumerable, set } = descriptor!;\\n              // only writable property can be overwritten\\n              // here we ignored accessor descriptor of globalContext as it makes no sense to trigger its logic(which might make sandbox escaping instead)\\n              // we force to set value by data descriptor\\n              if (writable || set) {\\n                Object.defineProperty(target, p, {\\n                  configurable,\\n                  enumerable,\\n                  writable: true,\\n                  value,\\n                });\\n              }\\n            } else {\\n              target[p] = value;\\n            }\\n          }\\n        }\\n        return true;\\n      },\\n\\n      get: (target, p) => {\\n        if (p === Symbol.unscopables) return unscopables;\\n        // avoid who using window.window or window.self to escape the sandbox environment to touch the real window\\n        // see https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L13\\n        if (p === \\\"window\\\" || p === \\\"self\\\") {\\n          return proxy;\\n        }\\n\\n        // hijack globalWindow accessing with globalThis keyword\\n        if (p === \\\"globalThis\\\") {\\n          return proxy;\\n        }\\n\\n        if (p === \\\"top\\\" || p === \\\"parent\\\") {\\n          // if your master app in an iframe context, allow these props escape the sandbox\\n          if (globalContext === globalContext.parent) {\\n            return proxy;\\n          }\\n          return (globalContext as any)[p];\\n        }\\n\\n        // proxy.hasOwnProperty would invoke getter firstly, then its value represented as globalContext.hasOwnProperty\\n        if (p === \\\"hasOwnProperty\\\") {\\n          return hasOwnProperty;\\n        }\\n\\n        if (p === \\\"document\\\") {\\n          return this.document;\\n        }\\n\\n        if (p === \\\"eval\\\") {\\n          return eval;\\n        }\\n\\n        if (p === \\\"string\\\" && globalVariableWhiteList.indexOf(p) !== -1) {\\n          // @ts-ignore\\n          return globalContext[p];\\n        }\\n\\n        const actualTarget = propertiesWithGetter.has(p)\\n          ? globalContext\\n          : p in target\\n          ? target\\n          : globalContext;\\n        const value = actualTarget[p];\\n\\n        // frozen value should return directly, see https://github.com/umijs/qiankun/issues/2015\\n        if (isPropertyFrozen(actualTarget, p)) {\\n          return value;\\n        }\\n\\n        // non-native property return directly to avoid rebind\\n        if (\\n          !isNativeGlobalProp(p as string) &&\\n          !useNativeWindowForBindingsProps.has(p)\\n        ) {\\n          return value;\\n        }\\n\\n        /* Some dom api must be bound to native window, otherwise it would cause exception like 'TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation'\\n           See this code:\\n             const proxy = new Proxy(window, {});\\n             // in nest sandbox fetch will be bind to proxy rather than window in master\\n             const proxyFetch = fetch.bind(proxy);\\n             proxyFetch('https://qiankun.com');\\n        */\\n        const boundTarget = useNativeWindowForBindingsProps.get(p)\\n          ? nativeGlobal\\n          : globalContext;\\n        return getTargetValue(boundTarget, value);\\n      },\\n\\n      has(target: any, p: string | number | symbol): boolean {\\n        // property in cachedGlobalObjects must return true to avoid escape from get trap\\n        return p in target || p in globalContext;\\n      },\\n\\n      deleteProperty: (target: any, p: string | number | symbol): boolean => {\\n        if (target.hasOwnProperty(p)) {\\n          delete target[p];\\n\\n          return true;\\n        }\\n\\n        return true;\\n      },\\n    });\\n\\n    this.proxy = proxy;\\n\\n    function hasOwnProperty(this: any, key: PropertyKey): boolean {\\n      // calling from hasOwnProperty.call(obj, key)\\n      if (this !== proxy && this !== null && typeof this === \\\"object\\\") {\\n        return Object.prototype.hasOwnProperty.call(this, key);\\n      }\\n\\n      return (\\n        fakeWindow.hasOwnProperty(key) || globalContext.hasOwnProperty(key)\\n      );\\n    }\\n  }\\n\\n  active() {\\n    // active\\n    this.sandboxRunning = true;\\n  }\\n\\n  inactive() {\\n    // inactive\\n    this.sandboxRunning = false;\\n  }\\n}\\n```\\n\\n#### patchers/index.ts\\n\\n主要功能：执行patcher清除副作用。写完后代码如下：\\n\\n```typescript\\nimport patchIntervals from \\\"./intervals\\\";\\nimport patchListeners from \\\"./listeners\\\";\\n\\nexport type Freer = () => void;\\n\\nexport type Patcher = (global: WindowProxy) => Freer;\\n\\nexport function patchSideEffects(global: WindowProxy) {\\n  const patchers: Patcher[] = [patchIntervals, patchListeners];\\n\\n  return patchers.map((patch) => patch(global));\\n}\\n```\\n\\n#### patchers/intervals.ts\\n\\n主要功能：清除setInterval副作用。写完后代码如下：\\n\\n```typescript\\nimport { Patcher } from \\\".\\\";\\n\\nconst rawSetInterval = global.setInterval;\\nconst rawClearInterval = global.clearInterval;\\n\\nconst patch: Patcher = (global) => {\\n  let intervals: number[] = [];\\n\\n  global.setInterval = (handler: Function, timeout: number, ...args: any[]) => {\\n    const intervalId = rawSetInterval(handler, timeout, ...args);\\n    intervals.push(intervalId);\\n    return intervalId;\\n  };\\n\\n  global.clearInterval = (intervalId: number) => {\\n    rawClearInterval(intervalId);\\n    intervals = intervals.filter((id) => id !== intervalId);\\n  };\\n\\n  return function free() {\\n    intervals.forEach((id) => rawClearInterval(id));\\n    intervals = [];\\n    global.setInterval = rawSetInterval;\\n    global.clearInterval = rawClearInterval;\\n  };\\n};\\n\\nexport default patch;\\n```\\n\\n#### patchers/listeners.ts\\n\\n主要功能：清除addListener副作用。写完后代码如下：\\n\\n```typescript\\nimport { Patcher } from \\\".\\\";\\n\\nconst rawAddListener = global.addEventListener;\\nconst rawRemoveListener = global.removeEventListener;\\n\\nconst patch: Patcher = (global) => {\\n  let listeners: Map<string, EventListenerOrEventListenerObject[]> = new Map();\\n\\n  global.addEventListener = (\\n    type: string,\\n    listener: EventListenerOrEventListenerObject,\\n    options?: boolean | AddEventListenerOptions\\n  ) => {\\n    rawAddListener(type, listener, options);\\n    if (!listeners.has(type)) {\\n      listeners.set(type, []);\\n    }\\n    listeners.get(type)!.push(listener);\\n  };\\n\\n  global.removeEventListener = (type: string, listener: EventListenerOrEventListenerObject) => {\\n    rawRemoveListener(type, listener);\\n    if (listeners.has(type)) {\\n      listeners.set(\\n        type,\\n        listeners.get(type)!.filter((l) => l !== listener)\\n      );\\n    }\\n  }\\n\\n  return function free() {\\n    listeners.forEach((ls, type) => {\\n      ls.forEach((listener) => {\\n        rawRemoveListener(type, listener);\\n      });\\n    });\\n    listeners.clear();\\n    global.addEventListener = rawAddListener;\\n    global.removeEventListener = rawRemoveListener;\\n  };\\n};\\n\\nexport default patch;\\n```\\n\\n#### globalState.ts\\n\\n主要功能：全局状态通信。写完后代码如下：\\n\\n```typescript\\nimport { cloneDeep } from \\\"lodash\\\";\\n\\ndeclare type State = Record<string, any>;\\ndeclare type Listener = (state: State, prev: State) => void;\\n\\nlet globalState: State = {};\\nlet listenerMap: Record<string, Listener> = {};\\n\\nfunction emit(state: State) {\\n  for (let key in listenerMap) {\\n    listenerMap[key](state, cloneDeep(globalState));\\n  }\\n}\\n\\nexport function initGlobalState(state: State = {}) {\\n  globalState = cloneDeep(state);\\n\\n  return getAppStateActions(`main-app`);\\n}\\n\\nexport function getAppStateActions(id: string) {\\n  return {\\n    onGlobalStateChange: (callback: Listener, fireImmediately?: boolean) => {\\n      listenerMap[id] = callback;\\n      if (fireImmediately) {\\n        callback(cloneDeep(globalState), {});\\n      }\\n    },\\n    offGlobalStateChange: () => {\\n      delete listenerMap[id];\\n    },\\n    setGlobalState: (state: State) => {\\n      state = cloneDeep(state);\\n      console.log(`[fake qiankun]global state set: ${JSON.stringify(state)}`);\\n      let changedKeys: string[] = [];\\n      for (let key in state) {\\n        if (globalState[key] !== state[key]) {\\n          changedKeys.push(key);\\n        }\\n      }\\n      if (changedKeys.length > 0) {\\n        emit(state);\\n      }\\n    },\\n  };\\n}\\n```\\n\\n#### qiankun.ts\\n\\n最后就是`qiankun.ts`，它是一个全局协调者的角色，组装各个模块的功能，暴露接口供用户调用。\\n\\n主要功能：提供外部接口，内部使用`single-spa.ts`和`import-html-entry`，创建沙盘，管理全局状态，加载app。写完后代码如下：\\n\\n```typescript\\nimport { registerApplication, start as startSingleSpa } from \\\"./single-spa\\\";\\nimport { importEntry } from \\\"./import-html-entry\\\";\\nimport { createSandboxContainer } from \\\"./sandbox\\\";\\nimport { getAppStateActions } from \\\"./globalState\\\";\\nexport { initGlobalState } from \\\"./globalState\\\"\\n\\nexport type AppConfig = {\\n  name: string;\\n  entry: string;\\n  container: string;\\n  activeRule: string;\\n};\\n\\nexport function registerMicroApps(apps: AppConfig[]) {\\n  apps.forEach((app) => {\\n    registerApplication({\\n      name: app.name,\\n      activeWhen: app.activeRule,\\n      app: async () => {\\n        return loadApp(app);\\n      },\\n    });\\n  });\\n}\\n\\ndeclare type FrameworkConfiguration = {\\n  proxy?: boolean;\\n  multi?: boolean;\\n  style?: boolean | { strict?: boolean; experiment?: boolean };\\n};\\nlet frameworkConfiguration: FrameworkConfiguration = {};\\n\\nexport function start(opts: FrameworkConfiguration) {\\n  frameworkConfiguration = opts;\\n  startSingleSpa();\\n}\\n\\nasync function loadApp(app: AppConfig) {\\n  const parent = document.querySelector(app.container);\\n  if (!parent) throw new Error(\\\"container not found\\\");\\n  parent.innerHTML = \\\"\\\";\\n\\n  const { template, execScripts } = await importEntry(app.entry);\\n\\n  const isStrictStyle =\\n    typeof frameworkConfiguration.style === \\\"object\\\" &&\\n    !!frameworkConfiguration.style.strict;\\n\\n  const isScopedStyle =\\n    typeof frameworkConfiguration.style === \\\"object\\\" &&\\n    !isStrictStyle &&\\n    !!frameworkConfiguration.style.experiment;\\n\\n  console.log(\\n    `[fake qiankun] ${\\n      isScopedStyle ? \\\"scoped\\\" : isStrictStyle ? \\\"strict\\\" : \\\"none\\\"\\n    } style isolation applied`\\n  );\\n\\n  const appWrapperElement = createElement(\\n    template,\\n    isStrictStyle,\\n    isScopedStyle\\n  );\\n\\n  parent.appendChild(appWrapperElement);\\n\\n  let global: Window = window;\\n\\n  // sandbox\\n  const sandboxContainer = createSandboxContainer(\\n    app.name,\\n    global,\\n    frameworkConfiguration.proxy,\\n    frameworkConfiguration.multi\\n  );\\n\\n  global = sandboxContainer.instance.proxy;\\n\\n  beforeLoad(global, app.entry);\\n\\n  execScripts(global);\\n\\n  // @ts-ignore\\n  const scriptExports = global[app.name];\\n\\n  const { bootstrap, mount, unmount } = scriptExports;\\n\\n  const appContainer = appWrapperElement.shadowRoot || appWrapperElement;\\n\\n  const stateActions = getAppStateActions(app.name);\\n\\n  return {\\n    bootstrap,\\n    mount: [\\n      sandboxContainer.mount,\\n      async () => mount({ name: app.name, container: appContainer, ...stateActions }),\\n      () => console.log(`[fake qiankun] app mounted: 【${app.name}】`),\\n    ],\\n    unmount: [\\n      () => beforeUnmountAddOns(global),\\n      async () => unmount({ name: app.name, container: appContainer }),\\n      sandboxContainer.unmount,\\n      () => console.log(`[fake qiankun] app unmounted: 【${app.name}】`),\\n    ],\\n  };\\n}\\n\\nfunction beforeLoad(global: any, publicPath = \\\"/\\\") {\\n  global.__POWERED_BY_QIANKUN__ = true;\\n  global.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ = publicPath;\\n}\\n\\nfunction beforeUnmountAddOns(global: any) {\\n  delete global.__POWERED_BY_QIANKUN__;\\n  delete global.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\\n}\\n\\n/** 创建app wrapper元素 */\\nfunction createElement(\\n  appElement: HTMLElement,\\n  strictStyle: boolean,\\n  scopedStyle: boolean\\n) {\\n  if (strictStyle) {\\n    const { innerHTML } = appElement;\\n    appElement.innerHTML = \\\"\\\";\\n\\n    const shadow = appElement.attachShadow({ mode: \\\"open\\\" });\\n\\n    shadow.innerHTML = innerHTML;\\n  }\\n\\n  if (scopedStyle) {\\n    const attr = appElement.getAttribute(\\\"data-qiankun\\\");\\n    if (!attr) {\\n      appElement.setAttribute(\\\"data-qiankun\\\", \\\"appid\\\");\\n    }\\n\\n    const styleNodes = appElement.querySelectorAll(\\\"style\\\") || [];\\n    styleNodes.forEach((stylesheetElement: HTMLStyleElement) => {\\n      // css.process(appElement!, stylesheetElement, \\\"appid\\\");\\n    });\\n  }\\n\\n  return appElement;\\n}\\n```\\n\\n测试用例和贴图就先不加了，有时间补上。\",\"n\":0.017}}},{\"i\":45,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"社交百科\\\"\\ncover: sjbk/cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"答题得奖励，奖励可提现\\\"\\ndatePublished: \\\"2022-12-03 21:11:05\\\"\\ndateModified: \\\"2022-12-03 21:11:05\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 跨平台\\n  - Flutter\\n  - dart\\n  - Android端\\n  - iOS端\\n---\\n\\n社交百科是一个知识答题类的网赚app。\\n\\n### 主要功能\\n\\n- 回答社交领域相关的问题，答对得金币奖励，答错无奖励。连对奖励更多。\\n\\n- 看广告得金币，保持连对数据。\\n\\n- 到达一定金币数量可以提现。\\n\\n- 可以邀请好友，好友收益也可以返利。\\n\\n- 包含开屏、插屏、激励视频广告。\\n\\n### 我的职责\\n\\n1. 负责对标同类型产品设计功能。\\n\\n2. 负责UI设计。\\n\\n3. 负责flutter应用开发。\\n\\n4. 负责广告sdk的接入、对接广告位。\\n\\n### 技术实现\\n\\n1. 项目使用flutter开发，支持android和ios。\\n\\n2. 请求框架使用dio。\\n\\n3. 应用更新使用ota_update。\\n\\n4. h5页面使用webview_flutter加载。\\n\\n5. 接口请求的request、response数据均加密，使用encrypt、crypto库实现。\\n\\n6. 使用Provider实现全局状态管理和UI更新。\\n\\n### 截图\\n\\n![知识答题](./sjbk/question.jpg)\\n![收益](./sjbk/benefit.jpg)\\n![我的](./sjbk/mine.jpg)\",\"n\":0.16}}},{\"i\":46,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"SwipeLoadView\\\"\\ncover: images/slv_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"SwipeLoadView支持为任意下拉刷新组件+ListView/RecyclerView/GridView/ExpandableListView的组合，增加上拉加载更多功能\\\"\\ndatePublished: \\\"2016-02-22 08:55:59\\\"\\ndateModified: \\\"2016-02-22 08:55:59\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - UI组件\\n  - 开源\\n---\\n\\nSwipeLoadView支持为**任意下拉刷新组件**（如SwipeRefreshLayout、SmartRefreshLayout）+ **ListView/RecyclerView/GridView/ExpandableListView**的组合，增加上拉加载更多功能。\\n\\ngithub仓库：https://github.com/missmess/swipeloadview\\n\\n> 原SwipeLoadView已经改名为LoadMoreHelper，支持更多刷新控件。\\n\\nLoadMoreHelper可以为任意下拉刷新控件，多种滚动布局(RecyclerView, ListView, GridView, ExpandableListView等)\\n增加上拉加载功能，可以作为下拉刷新库的加载功能补充。\\n  \\n---\\n\\n  * [主要功能介绍](#主要功能介绍)\\n  * [如何添加到项目中](#如何添加到项目中)\\n  * [如何使用](#如何使用)\\n  * [示例代码](#示例代码)\\n\\n---\\n\\n### 主要功能介绍\\n\\n* 默认支持为ListView、RecyclerView、GridView、ExpandableListView等内容组件增加pull load功能，其它控件可自行实现接口来添加支持。\\n* load more包含上拉加载、加载中、加载失败、没有更多的功能。可以实现接口来完全自定义您想要的布局。\\n* 理论上支持添加任意下拉刷新库的关联，关联后可以解决refresh和load状态的一些处理和冲突等。\\n* 默认实现了一套完整的功能，包含SwipeRefreshLayout+(ListView, RecyclerView, GridView, ExpandableListView)+DefaultLoadMoreView。\\n* 其它想要自定义的话，实现IRefreshLayoutHandler或ILoadViewHandler或ILoadMoreView（看你自己想自定义那些部分），并在构造LoadMoreHelper时传入即可。\\n\\n---\\n\\n### 如何添加到项目中\\n\\n本library已经支持maven。Android Studio用户，只需要在项目的build.gradle中添加该depandencies：\\n\\n```\\ncompile 'com.missmess.swipeloadview:loadmorehelper:2.1.1'\\n```\\n\\n**从2.1.1版本开始，去除了LoadMoreHelper.setAdapter方法，使用时只需要自己去调用各个setAdapter方法即可。使用起来更方便了。**\\n\\n---\\n\\n### 如何使用\\n\\n调用非常简单，只需要几句代码即可实现为你的refresh view添加加载更多的功能。\\n\\n  用法如下：\\n```java\\n// new a LoadMoreHelper\\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, listView);\\n// set refresh and load listener\\nloadViewHelper.setOnRefreshLoadListener(new SwipeLoadViewHelper.OnRefreshLoadListener() {\\n    @Override\\n    public void onRefresh() {\\n        // do your refresh OP\\n    }\\n\\n    @Override\\n    public void onLoad() {\\n        // do your load more OP\\n    }\\n});\\n```\\n但是不要忘记在你的刷新或加载更多操作结束后，通知LoadMoreHelper。\\n```java\\n    // refresh OP finished，notify LoadMoreHelper\\n    loadViewHelper.completeRefresh();\\n    // load more OP finished，notify LoadMoreHelper\\n    loadViewHelper.completeLoadmore();\\n```\\n---\\n\\n### 示例代码\\n###### 0、默认增加对SwipeRefreshLayout刷新库的支持\\n```java\\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, listView);\\n```\\n\\n如果需要自己指定特定的刷新库，可以实现对应的IRefreshLayoutHandler。并在构造LoadMoreHelper时，传入。以\\nSmartRefreshLayout为例：\\n```java\\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(smartRefreshLayout, new IRefreshLayoutHandler<SmartRefreshLayout>() {\\n\\t\\t@Override\\n\\t\\tpublic void handleSetRefreshListener(SmartRefreshLayout view, final Runnable runnable) {\\n\\t\\t\\tview.setOnRefreshListener(new OnRefreshListener() {\\n\\t\\t\\t\\t@Override\\n\\t\\t\\t\\tpublic void onRefresh(RefreshLayout refreshLayout) {\\n\\t\\t\\t\\t\\trunnable.run();\\n\\t\\t\\t\\t}\\n\\t\\t\\t});\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void refresh(SmartRefreshLayout view) {\\n\\t\\t\\tview.autoRefresh();\\n\\t\\t}\\n\\t\\t@Override\\n\\t\\tpublic void finishRefresh(SmartRefreshLayout view) {\\n\\t\\t\\tview.finishRefresh();\\n\\t\\t}\\n\\t}, recyclerView);\\n```\\n\\n###### 1、为不同的refresh view添加pull load支持\\n\\n可以为ListView、RecyclerView、GridView、ExpandableListView添加支持。仅需要为这些不同的refresh view添加对应的泛型，和adapter即可。\\n\\n* ListView\\n```java\\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, listView);\\n```\\n\\n* RecyclerView\\n```java\\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, recyclerView);\\n```\\n\\n* GridView\\n\\n    需要使用`GridViewWithHeaderAndFooter`替代GridView。\\n```java\\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, gridView);\\n```\\n\\n* ExpandableListView\\n```java\\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, expandableListView);\\n```\\n\\n###### 2、通知LoadMoreHelper，没有更多数据了\\n\\n  没有更多数据时，需要调用setHasMoreData方法告知LoadMoreHelper。\\n```java\\nif (nomoredata) { //没有更多数据了\\n    loadViewHelper.setHasMoreData(false);\\n}\\n```\\n\\n###### 3、设置自定义加载失败信息\\n\\n  加载失败时，可以自定义显示错误信息\\n```java\\nloadViewHelper.setLoadMoreError(\\\"connect failed, click to retry\\\");\\n```\\n\\n###### 4、自定义loadview\\n\\n  可以完全自定义LoadView的布局，通过实现ILoadViewFactory：\\n```java\\npublic class MyLoadFactory implements ILoadViewFactory {\\n    @Override\\n    public ILoadMoreView madeLoadMoreView() {\\n        return new MyLoadMoreView();\\n    }\\n\\n    /**\\n     * custom load more view\\n     */\\n    class MyLoadMoreView implements ILoadMoreView {\\n        private RadioButton normal;\\n        private RadioButton loading;\\n        private RadioButton nodata;\\n        private RadioButton error;\\n\\n        @Override\\n        public View create(LayoutInflater inflater, View.OnClickListener onClickLoadMoreListener) {\\n            View view = inflater.inflate(R.layout.view_custom_load, null);\\n            normal = (RadioButton) view.findViewById(R.id.radioButton1);\\n            loading = (RadioButton) view.findViewById(R.id.radioButton2);\\n            nodata = (RadioButton) view.findViewById(R.id.radioButton3);\\n            error = (RadioButton) view.findViewById(R.id.radioButton4);\\n\\n            return view;\\n        }\\n\\n        @Override\\n        public void showNormal() {\\n            normal.setChecked(true);\\n        }\\n\\n        @Override\\n        public void showNomore() {\\n            nodata.setChecked(true);\\n        }\\n\\n        @Override\\n        public void showLoading() {\\n            loading.setChecked(true);\\n        }\\n\\n        @Override\\n        public void showFail(CharSequence e) {\\n            // 错误信息通过e.getMessage()来获取\\n            error.setText(e);\\n            error.setChecked(true);\\n        }\\n    }\\n}\\n```\\n并在new LoadMoreHelper时，传参：\\n```java\\n    LoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, listView, new MyLoadFactory());\\n```\\n\\n---\\n\\n### 截图\\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc1.jpg)\\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc2.jpg)\\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc3.jpg)\\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc4.jpg)\\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc5.jpg)\\n\",\"n\":0.059}}},{\"i\":47,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"【uniapp】开发遇到的那些巨坑\\\"\\ncover: images/default_img3.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"开发uniapp过程中遇到的巨坑\\\"\\ndatePublished: \\\"2024-03-08 11:09:02\\\"\\ndateModified: \\\"2024-03-08 11:09:02\\\"\\nslug: uniapp-bugs\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - Uniapp\\n  - 跨平台\\n  - 踩坑\\n---\\n\\n### uniapp开发遇到的一些坑的合集\\n\\n>（有的是bug，有的是设计不合理，有的是表现在意料之外）\\n\\n##### 1. vue和nvue页面之间并不是完全共享数据。\\n\\n即使在同一个项目下，vue和nvue也不是数据互通的。原因是**vue和nvue分别有自己独立的js引擎，内存并不共享**。\\n\\n**比如以下情形：**\\n\\n- Vue.prototype\\n\\t\\n\\t仅支持vue，nvue下无法获取，为undefined。所以main.js里全局注册的组件、filter、directive等，都无法在nvue中使用。\\n\\t\\n- 导入js模块\\n\\t\\n\\t比如：`import store from '@/store/index'`，直接取store.state，nvue中为null。\\n\\n\\t再如：`import abc from '@/abc.js'`，`abc`为一个global的变量，vue页面设置abc=3。打开nvue页面取abc仍为初始值。\\n\\t\\n\\t因为两个js引擎，分别导入了js模块，数据并不共享。\\n\\t\\n- globalThis全局变量（uniapp里不应该使用globalThis来设置和获取全局变量）\\n\\n\\tmain.js或app.vue或某vue里增加了globalThis上的变量，nvue页面都无法获取到\\n\\n**vue和nvue共享数据的方法:**\\n\\n- 使用vuex的方法mapState、mapAction等获取状态。\\n\\t\\n\\t它们在vue和nvue里是互通的，因为uniapp对vuex特殊处理了。\\n\\n- 使用App.vue实例下的数据。官方说`getApp().globalData`是共享的，实际测试类似于getApp().abc也共享。\\n\\n\\t原理就是App在vue和nvue下相互拷贝，任何变化都会在两边触发。\\n\\n- 使用本地存储，如storage、sqlite等。\\n\\n- uni下的变量。文档没有，但实际测试，uni下的数据如uni.abc，也可以在vue和nvue共享\\n\\n这几种方法是uniapp单独处理好了，所以可以共享。\\n\\n**参考文档：**\\n\\n[vue和nvue共享数据](https://uniapp.dcloud.net.cn/tutorial/nvue-api.html#sharevar)\\n\\n[uniapp全局变量的几种方式](https://ask.dcloud.net.cn/article/35021)\\n\\n##### 2. uni.navigateBack是关闭栈顶页，并非关闭调用页。\\n\\n对比人家Android，调用acitivty.finish()，想关掉哪个就关掉哪个。一定不会关错页面。\\n\\nuniapp中以下的情况很容易出现bug：\\n\\n- 在调用navigateBack前，打开了一个新页面，会导致新打开的页面被关闭。比如下面的代码：\\n\\n```javascript\\n...\\n// 提交数据\\napiServer.post(URL.submitQA).then((res) => {\\n\\t// 判断是否打开新页面\\n\\tshouldOpenGuide(res)\\n\\t// 关闭当前页\\n\\tuni.navigateBack()\\n})\\n...\\nfunction shouldOpenGuide(res) {\\n\\t// 如果接口告诉我需要打开guide页面，我就去打开\\n\\tif (res.openGuide) {\\n\\t\\tuni.navigateTo(\\\"/pages/guide/guide\\\");\\n\\t}\\n}\\n```\\n\\n看着代码没有任何问题，期望先打开新页面再关掉当前页面。但实际是错误的效果。\\n\\n- 同一时间调用几次navigateBack，就往前关闭几个页面。\\n\\n```javascript\\n...\\n// 这里的代码会往前关闭3个页面\\nuni.navigateBack()\\nuni.navigateBack()\\nuni.navigateBack()\\n...\\n```\\n\\n- 无法实现非栈顶页面关闭，如A=>B=>C=>D，想在D页面关闭B页面实现不了。\\n\\n我试了n种方法（记在了qingchat/common/navigateCompat里），但**目前看没办法保证在哪个页面调用navigateBack，就关闭哪个页面**，所以必须自己控制页面栈顺序是否正确\\n\\n##### 3. uni.showToast只能在当前页未销毁时显示\\n\\n很常见的一种情况，showToast和navigateBack挨着写，你会发现toast一闪即逝。（底层上，toast的view展示在了当前页面的webview上，当前页一关，view随着webview全部销毁）\\n```javascript\\n// 提交数据\\napiServer.post(URL.submitQA).then((res) => {\\n\\t// 判断是否打开新页面\\n\\tshowToast({ title: \\\"数据提交成功\\\" })\\n\\t// 关闭当前页\\n\\tuni.navigateBack()\\n})\\n```\\n\\n解决办法：a. navigateBack套上setTimeout，显示完toast再关闭（有点傻的方法）；b. 在app上使用plus.nativeUI.toast代替uni.showToast，它不依赖于当前页，非app上保持原样（参考qingchat/common/toastCompat）。\\n\\n##### 4. uni.redirectTo无动画直接闪现新页面，体验很差。\\n\\n不用redirectTo，替代方案为先navigateBack再navigateTo。\\n\\t\\n不过这个方案对于background为透明的页面（比如全局弹窗），这样做会导致上上页面在回退栈中消失了（这百分百是uniapp的bug）。\\n\\n解决办法：navigateBack({ animationType: 'none' })，再navigateTo，就可以正常跳转（搞不懂，反正这样就是好使了）。\\n\\t\\n#### 5. nvue页面关闭，js引擎也会一同销毁\\n\\nvue页面不是这样的，vue页面js引擎在整个应用生命周期都存活。（我不知道纯nvue项目下表现会不会不一样）\\n\\t\\nnvue的js引擎销毁，会导致：\\t\\n- nvue导入的js模块中的变量，每次页面打开都重置。\\n- nvue页面调用plus.NativeObj.View显示原生悬浮窗。nvue页面一旦关闭，悬浮窗就无法响应点击和触摸。\\n- setTimeout、setInterval在nvue页面关闭后就不会再执行，所以上面的悬浮窗也不能通过timer自动关。\\n\\t\\n原因是：从nvue页面显示出来的原生悬浮窗，js执行使用的是nvue的js引擎。页面一关，引擎一销毁就gg。\\n\\n解决办法：将悬浮窗的show方法，移入到App.vue中。nvue页面通过getApp().show来显示悬浮窗，这样悬浮窗就是在vue的js引擎中打开的，跟nvue无关了。\\n\\n#### 6. v-for列表渲染时，偶现列表数据变化后，列表里的组件template中获取到的props为undefined\\n\\n条件：a. 列表渲染；b. 列表渲染的节点下有子组件；c. 往子组件传了props；d. 列表数据发生变化时。\\n\\n现象：子组件js中打印的props是正确数据；但template中获取到的props为undefined（也偶现展示的是列表前一个item的）。即：控制台看着是对的，手机上显示的是undefined（WTF，活久见）\\n\\n```html\\n<!-- 父组件 -->\\n<template>\\n...\\n\\t<view v-for=\\\"item in listdata\\\" :key=\\\"item.id\\\">\\n\\t\\t<!-- 子组件 -->\\n\\t\\t<ChildComp :item=\\\"item\\\" />\\n\\t</view>\\n...\\n</template>\\n<script>\\nimport OriginalData from \\\"../def_data\\\";\\n...\\n\\tdata() {\\n\\t\\treturn {\\n\\t\\t\\tlistdata: OriginalData,\\n\\t\\t}\\n\\t}\\n...\\n\\tonFetchData(data) {\\n\\t\\t// 列表数据发生变化\\n\\t\\tthis.listdata = data;\\n\\t}\\n...\\n</script>\\n```\\n```html\\n<!-- 子组件 ChildComp -->\\n<template>\\n...\\n\\t<view class=\\\"child-container\\\">\\n\\t\\t<!-- 取props里的data，有时候会变成undefined -->\\n\\t\\t<text>{{ item.data }}</text>\\n\\t</view>\\n...\\n</template>\\n<script>\\n...\\n\\tprops: [\\\"item\\\"],\\n\\tmounted() {\\n\\t\\t// js中获取到的props一直是正常的\\n\\t\\tconsole.log(this.item)\\n\\t}\\n...\\n</script>\\n```\\n\\n跟设置key没有关系，这种基础的我早试过了。我猜测原因是：**uniapp渲染层和逻辑层是分开的。列表成功渲染一次后，当数据发生了变化，出于某某bug，某个子组件逻辑层props是正确的，但没有将这个正确的数据发送到渲染层）**\\n\\n目前秒聊的聊天消息列表出现过这个问题，通过setTimeout，延迟执行messageList更新就解决了，奇怪的很。\\n\\n秒聊首页列表、会话列表也出现了这个问题（出现概率很高）。v-for不放在view上，直接放在子组件上```<ChildComp v-for=\\\"item in listdata\\\" :key=\\\"item.id\\\" />```，或者不抽子组件，直接在```<view v-for...>{/*写ui*/}</view>```里面写ui，就不存在子组件的通信问题了。\\n\\n##### 7. uni-transition组件设置:show=true，列表渲染时偶而无法显示出来\\n\\t\\n解决办法：用属性控制```<uni-transition :show=\\\"show\\\" />```，在页面mounted生命周期里设置this.show=true，就能正常。\\n\\n原因未知。猜测是uni-transition组件open()方法中，setTimeout不知什么原因未执行，目前看只有列表渲染下的uni-transition才出现。\\n\\t\\n##### 8. onLoad中有耗时操作，导致页面打开时白屏很久\\n\\n😊 我以为的：渲染层和逻辑层分离，逻辑层耗时操作不卡渲染。\\n\\n😭 实际的：onLoad里的耗时操作，耗时多久，页面就白屏多久。\\n\\n文档提到了[生命周期](https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle)，不详细，我测试的情况补充一下：onLoad是页面加载后调用（对应到原生为webview已创建完成），然后调用onShow（此时webview开始加载template），接着调vue的生命周期，created、mounted等相继被调用。首次渲染完成调用onReady。\\n\\t\\n所以在onLoad、onShow中不要执行耗时的js操作，否则会推迟webview开始渲染的时机，看起来就是白屏。耗时操作放到mounted、onReady里面，此时webview渲染和js耗时并行，互不影响。\\n\\n> 题外话：\\n如果界面依赖接口的数据返回（最常见的比如列表的展示）。如果在onReady里做耗时操作，虽然不影响页面渲染，但是它阻塞了接口的promise微任务。导致的结果就是列表一直显示空的，等到耗时操作完成，promise才处理，数据才发送到渲染层，列表才显示出来。\\n\\t\\n##### 9. uniapp与app通信的js方法很耗时\\n\\n所以需要注意不能放在onLoad、onShow中，防止白屏。目前知道的有：\\n\\n- 使用Native.js的Api，如plus.android.runtimeMainActivity，plus.android.importClass。如果原生中的这个类特别大，比如Activity，首次导入很慢（低端机1s以上），再次调用不会。\\n\\t\\n- 野火sdk的wfcClient.connect方法耗时贼长（低端机1s以上）。connect方法调用原生的sdk提供的api，不知道原生是如何实现的。\\n\\t\\n- 调用原生插件或uts插件的方法，首次执行时较慢（低端机约200ms）。如：秒聊message页导入uts插件[qingchat-common]，首次调用该插件任意方法返回比较慢，后续就很快。\\n\\n[🔗 Native.js性能优化](https://uniapp.dcloud.net.cn/tutorial/native-js.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)\\n\\n[🔗 unapp性能优化专题](https://uniapp.dcloud.net.cn/tutorial/performance.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98)\\n\\n##### 10. vue的监听器中，耗时操作也可能白屏。\\n\\n在watch中如果使用了immediate: true，则监听函数handler也会在onLoad或onShow时机之间触发。此时，如果handler中有耗时操作，也会看到很长时间的白屏。\\n\\n##### 11. 能全靠css做动画就靠css，js去触发也容易被阻塞\\n\\n在低端机上，仅仅是设置data（如this.showAnim = true）的方法，由于逻辑层与渲染层通信，也有点慢（可能延迟50ms左右）。\\n\\n所以uni-transition、uni.createAnimation这种需要js去操作动画的，比起纯css动画要慢。同时js容易被耗时方法阻塞，如果被阻塞了，动画播放会滞后。\\n\",\"n\":0.085}}},{\"i\":48,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"【uniapp】与原生通信的几种方式\\\"\\ncover: images/default_img4.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"介绍uniapp中哪些与原生交互的方式\\\"\\ndatePublished: \\\"2024-03-23 14:33:10\\\"\\ndateModified: \\\"2024-03-23 14:33:10\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - Uniapp\\n  - 跨平台\\n---\\n\\nuniapp开发APP时，除了要写出优美、流畅的页面外，经常还需要调用原生的底层能力来实现各种功能。\\n\\n列举了一下，大概这几种：\\n\\n#### 1. uni.** API\\n\\n[🔗 uniapp api文档](https://uniapp.dcloud.net.cn/api/)\\n\\nuniapp官方提供的api，已经抹平了各个平台的差异，均使用统一的接口。基本上常用的基础功能都在uni.**下能找到。比如本地存储、网络请求、路由跳转等。\\n\\nuni API属于是比较稳定的了，执行速度快，优化好（要注意的是，有部分接口是特属于某些平台的）。\\n\\n缺点是**接口中规中矩**，能满足70～80%的需求，有很多情况下就会发现不够用。\\n\\n#### 2. plus.** API\\n\\n[🔗 h5+ api文档](https://www.html5plus.org/doc/)\\n\\nuniapp默认已经集成好了H5plus，直接可以使用plus下的api。\\n\\nplus API功能很全面，接口使用起来也会复杂一些了，比如手机文件管理，uni接口就是uni.saveFile或uni.getSavedFileInfo，连存储到哪里都不能选，就是方便但不灵活。而plus就能自己操作存储位置，拷贝、删除、查找文件等。\\n\\n> 能理解为什么uni不灵活，因为它要抹平全平台差异，导致的结果就是按照全部平台里的下限来支持。\\n\\nplus的api能满足几乎90%以上的需求了，使用NativeObj能绘制任意原生view，再配上很丰富的原生模块。*我猜uni API很多接口在实现的时候，涉及到app端也是直接调用plus API，其他端再适配一下就好了。*\\n\\n缺点也有，**只支持app**，如果你想同时支持h5，那就自己写代码吧。并且，**接口虽丰富，但并不代表易用**。比如NativeObj绘制view的过程堪比canvas手动绘图。\\n\\n#### 3. Native.js\\n\\n[🔗 Native.js api文档](https://www.html5plus.org/doc/zh_cn/android.html)\\n\\nNative.js(NJS)也包装在H5+ runtime里面。这玩意更强大一点，可以通过js语法来任意的调用原生的接口。在Android上是js直接调用java，在iOS上是js直接调用object-c。\\n\\n它的方法也就几个，不过因为是直接导入和操作原生的类和对象，所以实际能实现几乎全部的原生的功能了。\\n![Native.js API](./uniapp/nativejs.jpg)\\n\\n原理：\\n\\n- NJS与原生通过javascriptInterface通信。\\n- NJS获取到原生传过来的类、对象和基本数据类型，都映射成NJS预设好的类型。从而让js层调用。\\n- NJS调用导入类，到达原生层，用反射获取Class。\\n- NJS调用类的方法、属性、new。在原生层也是反射去执行。\\n\\n缺点：\\n\\n看了原理就知道缺点很多：首先就是**通信成本很高**，比如当前页面的activity实例，这个实例很大，传输到js层并转换，耗时很久（实测低端机至少1秒）。不过NJS对传输过的对象有缓存，所以就要自己控制好各个对象首次传输的时机（说白了就是这几秒肯定是要耗的，就看你耗在哪里）。\\n\\n其次，本身原生开发，反射就是比较耗时的操作，基本就是能不用就不用。**NJS实现的功能如果靠反射，复杂功能的耗时不敢想**。\\n\\n再之，NJS也需要了解原生知识才能开发。\\n\\n#### 4. 原生语言插件\\n\\n原生语言插件，就不用详细说了。Android端自己写好原生代码，然后打包成aar；iOS端也是写好原生打包framework。打包产物放到uniapp/nativeplugins里面就可以当成原生插件`uni.requireNativePlugin(***)`引入并使用。\\n\\n缺点：**必须要原生开发环境，原生代码开发**。\\n\\n\\n#### 5. uts原生插件\\n\\n[我写的uts的介绍](/【uniapp】页面开发方式及原理#4-uts)\\n\\n使用uts语言去开发原生代码，就像是个语法糖，使用统一的类似ts的语言，最后生成的是原生代码。\\n\\n优点是对ts熟悉的前端人员很友好，至少不用为了语法发愁。也不用去准备原生开发环境，使用开发工具，再打包等。\\n\\n缺点是**仍然需要了解原生知识，不然没法开发**。\\n\\n对比NJS，性能肯定提升一大截，因为最后的产物仍然是原生插件；写法呢，也比NJS简单不少；能实现的功能也更多一些，能写UI组件。NJS想写个原生view出来可不容易啊。\\n\\n对比原生语言插件，开发方便太多了。\\n\",\"n\":0.152}}},{\"i\":49,\"$\":{\"0\":{\"v\":\"---\\ntitle: 【uniapp】页面开发方式介绍及原理\\ndescription: 介绍什么是uniapp的vue、nvue、uvue、uts开发，以及原理\\ndatePublished: 2024-03-19 15:18:22\\ndateModified: 2024-03-19 15:18:22\\ncover: images/default_img2.jpg\\ncoverAlt: 封面\\nslug: uniapp-vue-nvue-uvue-uts\\ncategory: 经验总结\\ntags:\\n  - Uniapp\\n  - 跨平台\\n---\\n***（以下内容主要考虑app跨平台，小程序、快应用不考虑）***\\n\\nuniapp可以轻松开发一个跨平台应用。很多人只是知道它可以开发，但是不知道其实uniapp支持多种跨平台开发的方式。每一种方式都有一定的优缺点，同时也反映出来uniapp团队在跨平台技术方案上的不断改进和尝试。\\n\\n下面我们来详细的分析一下每一种开发方式：\\n\\n#### 1. vue页面\\n\\nvue页面是使用vue的语法开发的页面，和web开发没区别，只不过global增加了uni、plus等的api方便调用原生能力。可以使用vue2语法和vue3语法。在app上，vue页面逻辑层和视图层是分离的（微信小程序等很多小程序技术都类似），在编译过程uniapp将视图层代码和逻辑层的代码分开了。vue2语法使用基于webpack的编译器，vue3语法使用基于vite的编译器（uniapp对编译器做了很多调整）。\\n\\n**渲染层**使用webview渲染。（Android上默认使用系统的webview，但是各手机webview有一定兼容差异性，可以使用腾讯x5引擎代替。iOS默认用WKWebview）。\\n\\n**逻辑层**使用一个`jscore`（iOS）/`v8`（Android）的js引擎。执行标准js代码，但是没有浏览器专用的window、document等api。可以用uni、plus等api。\\n\\n> 逻辑层和渲染层分离主要是为了逻辑层的复杂运算不卡渲染层。但是缺点也比较明显，每次通信都有耗时，所以类似于监听scroll并计算位置，再定位元素这种非常频繁通信的操作就不能做。\\n\\n可能还有其他优化，但不管怎么样，**uniapp的vue页面明显要比纯H5套壳的APP性能要高很多，至少窗口动画，页面渲染很流畅。**不是很复杂的页面的话，基本vue页面已经能满足条件。\\n\\n#### 2. nvue页面\\n\\nnvue页面是`native vue`。nvue也是逻辑层和渲染层分离的，所以上面的通信问题nvue也存在。只不过nvue的渲染层是使用基于weex的渲染器，可以将由vue编写的ui模版最终在运行时渲染为原生组件。\\n\\n> uniapp的渲染层基于weex渲染器，在它的基础上修改了一些bug，并扩展了一些排版能力。参考[nvue介绍](https://uniapp.dcloud.net.cn/tutorial/nvue-outline.html#nvue%E4%BB%8B%E7%BB%8D)\\n\\n简单理解就是仍然使用前端技术栈，vue作为语法糖，编译时通过改进的compiler将vue编译为js代码。在运行时由逻辑层生成虚拟DOM，并将虚拟DOM通过`JsBridge`发送到原生来绘制为原生组件\\n\\n```html\\n<!-- 比如以下template -->\\n<view style=\\\"display: flex; flex-direction: column; height: 300px;\\\">\\n    <text style=\\\"color: red;\\\">Hello</text>\\n    <text style=\\\"color: black; flex: 1;\\\">Leon</text>\\n</view>\\n\\n<!-- 渲染到Android就是 -->\\n<LinearLayout\\n    android:layout_width=\\\"match_parent\\\"\\n    android:layout_height=\\\"300px\\\"\\n    android:gravity=\\\"vertical\\\" >\\n\\n    <TextView\\n        android:layout_width=\\\"wrap_content\\\"\\n        android:layout_height=\\\"wrap_content\\\"\\n        android:color=\\\"#ff0000\\\"\\n        android:text=\\\"Hello\\\" />\\n\\n    <TextView\\n        android:layout_width=\\\"wrap_content\\\"\\n        android:layout_height=\\\"wrap_content\\\"\\n        android:layout_weight=\\\"1\\\"\\n        android:color=\\\"#000000\\\"\\n        android:text=\\\"Leon\\\" />\\n</LinearLayout>\\n```\\n\\n这么一看，weex处理了非常多的繁杂的组件对应，属性对应，属性计算/转换等等工作👍。不是很难但确实很烦。所以nvue支持的能力有限（几乎不可能在app上支持全部的css属性），比如nvue只能使用flex布局。不过到目前为止[nvue支持的组件和属性](https://uniapp.dcloud.net.cn/tutorial/nvue-css.html)已经很多了，基本能满足使用。\\n\\nnvue的逻辑层也是基于jscore/v8的引擎。逻辑层响应式数据变更，利用JsBridge通信驱动渲染层原生组件UI变更。\\n\\nnvue可以和vue混合去开发一个app，也可以纯nvue、或者纯vue开发app。**注意：混合开发时，它们的js引擎实例是分开的，独立的**。\\n\\nnvue对比vue：\\n\\n* nvue在滚动和长列表上的性能明显优于vue。nvue最终还是使用原生组件比如ScrollView、RecyclerView来渲染的，体验就是原生的体验。布局复用布局销毁都非常快。\\n* nvue使用canvas绘图组件，不太行。官方说性能不如vue。\\n* nvue页面初始化很快，相比之下，vue初始化慢不少，所以vue页面的启动页等待时间挺久的。\\n* nvue写起来复杂很多。需要按照原生的习惯和风格写，但是写的又是css代码，好多属性也不支持。对于原生开发和css开发都有一定的学习成本。\\n* nvue有一些不支持的特性，比如不支持Vue的全局组件、过滤器、指令等。\\n\\nnvue比vue渲染性能要好不少，**因为UI换成了原生组件**。但是js层仍有很大优化空间。\\n\\n#### 3. uvue\\n\\nuvue跟vue/nvue是分开的技术栈了，也不再叫uniapp开发，改叫uniapp x开发。所以uvue跟vue/nvue不能混用。并且uniapp x只支持web、android、ios三个平台。\\n\\nuvue最终是会被编译为原生代码的，Android编译为`kotlin`、ios编译为`swift`、web编译为`js`。\\n\\n**所以本质上uvue就是类vue写法的原生应用**。通过编译器将uvue语法转为最后的原生语法。包括uts编译器和uvue编译器。uvue编译器是基于vite扩展开发的。\\n\\n* template里写入组件树，只能用uview可以用的组件。（最终编译为原生组件）\\n* script仅支持[uts语法](#4-uts)。（最终编译为原生代码）\\n* style的是web css的子集，和nvue支持的css差不太多。可用css、less、scss语法。（最终也是作为原生组件的属性）\\n\\nuvue和vue开发方式差不多，但是最终都转为原生的代码了。uvue对比之前的跨平台方案，不存在逻辑层和渲染层分离的问题，通信也没有任何压力。uvue对比flutter这样的自渲染方案，不会存在原生组件和自渲染组件的融合问题。[uvue渲染](https://doc.dcloud.net.cn/uni-app-x/#_2-uvue%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E)。\\n\\n看起来uvue是最完美的方案了。**不过目前组件和api不全，css的bug还有uts的bug暂时不明了**。有待优化。\\n\\n> 按我的理解，uvue编译器类似于vite，负责处理SFC并打包。支持treeshaking、解析SFC、css预编译等。最终转为uts代码。uvue底层使用一个重写的类似于vue的uts库。也实现了响应式系统和虚拟DOM。所有uts代码准备完毕后，交给uts编译器。uts编译器转译uts代码为原生代码，再调用kotlin编译器、swift编译器编译原生代码为字节码。\\n\\n#### 4. uts\\n\\n[uts](https://doc.dcloud.net.cn/uni-app-x/uts/)仅是一门语言，带类型的语言，语法类似于ts。但实际上它不仅仅只作为uvue的逻辑层语言，uts还可以独立去开发原生插件和原生UI组件，并且插件和UI组件能同时支持所有端（前提是你自己适配了）。\\n\\n三种开发场景的不同：\\n\\n| 区别       | uvue中           | 开发插件          | 开发UI组件             |\\n| -------- | --------------- | ------------- | ------------------ |\\n| **文件后缀** | .uvue           | .uts          | .vue               |\\n| **区分平台** | 条件编译语法          | 平台目录下         | 平台目录下              |\\n| **可用平台** | web、Android、iOS | 全平台           | 全平台（app下不支持vue）    |\\n| **组织方式** | vue2选项式/vue3组合式 | export导出方法    | index.vue中书写vue2语法 |\\n| **产物**   | 原生页面            | 原生插件，import导入 | 原生view             |\\n\\nuts能编译成原生的代码。所以它相当于换了一种形式写原生代码。同时也能看到，要支持写原生代码，再加上需要类型，在Andoid端它把Android源码的类都做了对应的一份type定义（我很好奇Android源码上百万个类，method、field更是不计其数，uniapp团队能全部整理出来吗？还是通过class批量生成的？）\\n\\n```javascript\\n// uts开发插件示例：\\n// 导入了android的类\\nimport NotificationManagerCompat from 'androidx.core.app.NotificationManagerCompat';\\n// 检查是否有通知权限\\nexport const isNotificationEnabledSync : IsNotificationEnabledSync = function () : boolean {\\n\\tconst context = UTSAndroid.getAppContext()\\n\\tif (context != null) {\\n\\t\\tconst res = NotificationManagerCompat.from(context).areNotificationsEnabled()\\n\\t\\treturn res\\n\\t} else {\\n\\t\\treturn false\\n\\t}\\n}\\n```\\n\\n![androidx通知管理器类型定义](./uniapp/notificationmgr.jpg)\\n\\n（可能是错误的）uts编译过程：*（下面包含一些我的个人理解和猜测，因为没有开源、文档也没那么深入原理）*\\n\\n* uts对基础语法，比如数据类型、关键字、if、for、class等，最终根据平台编译为对应平台的语法。\\n* uts导入系统包、三方aar包等语句，把import语句转为对应平台语法的字符串了。\\n* uts导入另一个模块，类似于ESM导入，静态分析，并编译对应模块的uts。\\n* 以上三步完成后就形成了对应平台的源码，再调用对应平台的编译器（如kotlin、swift）生成最终的字节码产物。\\n\\nuvue编译过程：\\n\\n* uvue文件先走uvue编译器，取SFC代码块，模版和样式经过编译。最终输出为uts代码。\\n* 上一步后，uvue文件转译为uts文件\\n* uts文件走上述uts编译过程，形成原生产物。\\n\\nuts也有学习成本，因为你仍然需要原生知识，比如android上，我要使用哪些类，调用类的哪些方法来实现xx功能。iOS上可能就是另外的实现方式。它其实是方便了习惯ts的开发人员不用再学习新的语言，也不用准备复杂的开发环境，IDE，打包等等。\",\"n\":0.078}}},{\"i\":50,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"点名识别\\\"\\ncover: images/speech_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"大数据部-课堂老师提取音频，speech-to-text，拼音模糊音匹配算法\\\"\\ndatePublished: \\\"2019-01-16 07:33:04\\\"\\ndateModified: \\\"2019-01-16 07:33:04\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - C++\\n  - 脚本\\n  - 语音处理\\n  - AI\\n  - 库\\n---\\n\\n点名识别使用课堂老师音频提取、切割转码、speech-to-text、拼音模糊音算法匹配等手段，计算点名次数\\n\\n### 背景\\n\\n需要对各个授课老师课堂教学效果进行数据化评测。\\n\\n### 我的职责\\n\\n作为项目负责人负责点名的数据化分析工作。包括数据资源获取、方案调研、方案设计、编码实施、申请资源、效果统计等。\\n\\n### 主要技术\\n\\n1. 整体程序使用shell脚本运行\\n\\n2. shell负责处理oss音频批量提取webm、webm提取pcm、pcm静音去除/降噪、pcm静音切分vad、pcm转wav\\n\\n3. 其中静音切分使用webrtc的vad模块c++源码\\n\\n4. wav调用百度/讯飞接口speech-to-text转文本\\n\\n5. 文本转拼音，不断调整模糊音匹配算法，提升准确率\",\"n\":0.189}}},{\"i\":51,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"vite-reactts-starter\\\"\\ncover: vrars/cover.jpg\\ncoverAlt: \\\"脚手架模版\\\"\\ndescription: \\\"vite+react+ts+Antd+redux+eslint项目启动脚手架\\\"\\ndatePublished: \\\"2021-10-10 10:27:09\\\"\\ndateModified: \\\"2021-10-10 10:27:09\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - 前端\\n  - 脚手架\\n  - React\\n  - Antd\\n  - Vite\\n  - 开源\\n---\\n\\nVite for React快速启动脚手架。\\n\\n*[Vite + React + TypeScript + React Router + Redux Toolkit + Antd + Eslint + Prettier + axios + less]*\\n\\nGithub仓库：https://github.com/missmess/vite-reactts-antd-redux-starter\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n1. **集成常用三方框架，一键启动**\\n\\n1. **默认自带通用管理后台样式**\\n\\n1. **支持配置式路由**\\n\\n    支持本地tsx或json来配置菜单。\\n\\n    页面组件可以直接用string格式路径。\\n\\n1. **支持N级嵌套菜单**\\n\\n1. **菜单和路由联动**\\n\\n1. **可使用页面标签卡组件**\\n\\n1. **面包屑/页面标签卡和路由联动**\\n\\n### 截图\\n\\n![管理后台](./vite-react/1.png)\\n![配置菜单代码](./vite-react/2.png)\",\"n\":0.131}}},{\"i\":52,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"vite-plugin-qiankun\\\"\\ncover: images/default_img5.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"让qiankun框架支持vite的es特性的框架\\\"\\ndatePublished: \\\"2022-09-02 11:38:19\\\"\\ndateModified: \\\"2022-09-02 11:38:19\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - 前端\\n  - 库\\n  - 微前端\\n  - Vite\\n  - 开源\\n---\\n\\nvite-plugin-qiankun是用于vite构建的微应用，想要接入qiankun时，需要引入该插件。\\n\\ngithub仓库：https://github.com/missmess/vite-plugin-qiankun/tree/feature/support-prod-publicpath\\n\\n---\\n\\n### 为什么需要这个插件？\\n\\nqiankun加载vite微应用时，开发模式下，对于ES模块无法获取到对应的生命周期函数。所以需要修改html entry的代码来hack生命周期的函数。\\n\\n同时微应用的相对路径的资源需要添加前缀（微应用的地址）```window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__```。否则资源加载会出现404。\\n\\n> 参考：[qiankun使用webpack时的publicPath](https://qiankun.umijs.org/zh/faq#a-%E4%BD%BF%E7%94%A8-webpack-%E8%BF%90%E8%A1%8C%E6%97%B6-publicpath-%E9%85%8D%E7%BD%AE)\\n\\nwebpack本身就有[runtime publicPath技术](https://webpack.js.org/guides/public-path/#on-the-fly)，而vite还没有。\\n\\n### 原理\\n\\nqiankun加载vite微应用，hack代理方法window.proxy[vite-app-name].mount指向代码中配置的`renderWithQiankun`的参数对象。这样qiankun就能正常调用各个生命周期函数。\\n\\n同时，vite开发环境下，加载qiankun微应用的esm模块时，需要修改路径追加前缀。\\n比如```./main.ts```，需要改为```window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ + '/main.ts'```。\\n\\n这样的话，qiankun就能正常加载es模块入口代码。\\n\\n### 使用方法\\n\\n**安装**\\n\\n`@oneline.top/vite-plugin-qiankun`用于支持qiankun。`vite-plugin-dynamic-base`用于vite支持动态publicPath。\\n\\n```shell\\nnpm install -D @oneline.top/vite-plugin-qiankun vite-plugin-dynamic-base\\n```\\n\\n**vite.config.ts**\\n\\n配置动态base为`window.__DYNAMIC_BASE_PATH__`变量。\\n\\n```typescript\\nimport qiankun from '@oneline.top/vite-plugin-qiankun';\\n...\\nexport default defineConfig(({ mode }) => {\\n  return {\\n    plugins: [\\n      ...\\n      qiankun(MICRO_APP_NAME, {\\n        useDevMode: true,\\n        // qiankun-plugin默认会处理js文件，跟设置的base冲突了，所以需要手动去掉\\n        urlTransform: (ori) => ori.replace('/__dynamic_base__', ''),\\n      }),\\n      dynamicBase({\\n        // 所有的资源导入路径，前缀加上该动态变量\\n        publicPath: ' window.__DYNAMIC_BASE_PATH__ ',\\n        // 是否转换入口html文件\\n        transformIndexHtml: true,\\n      }),\\n    ],\\n    ...\\n    // dynamicBase要求打包时必须加上该前缀，用来在代码中匹配并替换为dynamicBase.publicPath\\n    base: process.env.NODE_ENV === 'production' ? '/__dynamic_base__/' : '/',\\n  }\\n})\\n```\\n\\n**main.ts**\\n\\n在入口文件设置`window.__DYNAMIC_BASE_PATH__`动态变量从qiankun变量来获取。\\n\\n\\n```javascript\\n// 用于子应用的资源动态加载路径\\nwindow.__DYNAMIC_BASE_PATH__ = window.proxy ? window.proxy.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ : '';\\n```\\n\\n### 存在的问题\\n\\n生产环境必须要在vite.config.ts中配置base。但是这样的话就不能支持多环境部署了（如微应用部署到//xxx.prod.com、//xxx.test.com）。\\n\\n但是vite又不像webpack一样支持runtime publicPath，所以用到了另一个插件：[vite-plugin-dynamic-base](https://github.com/chenxch/vite-plugin-dynamic-base)。\\n\\nvite-plugin-qiankun和这个插件有冲突，所以修改了vite-plugin-qiankun源码，增加了urlTransform特性，让插件对路径做预转换。\\n\\n同时去掉插件中，生产环境下不支持动态base的代码。\\n\\n最后实现的效果就是，vite+React的微应用能在开发环境下正常使用。同时生产打包后，能支持多环境部署。微应用可以用域名直接访问；也可以在主应用中加载，微应用的资源地址始终是从`__INJECTED_PUBLIC_PATH_BY_QIANKUN__`参数获取的，不会404。\\n\\n原issue链接：https://github.com/tengmaoqing/vite-plugin-qiankun/issues/16\",\"n\":0.104}}},{\"i\":53,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"【造轮子】在React中手搓一个Vue\\\"\\ncover: ../static/assets/vue-in-react.png\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"如何在React中模拟写出来一个Vue\\\"\\ndatePublished: \\\"2021-12-22 21:30:17\\\"\\ndateModified: \\\"2021-12-22 21:30:17\\\"\\nslug: \\\"vue-demo\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 前端\\n  - Vue2\\n  - 架构\\n  - 造轮子\\n---\\n\\n闲来无事，突发奇想，来造个轮子吧：如何在React中，仿照Vue的框架功能设计，重造一个Vue出来。\\n\\n> 注意！并不是**Vue的源码解析**，也不是**Vue官方版本的minimal**。完全是我个人根据Vue的功能，凭空捏的一个变种Vue。做这个的目的只是为了提升自己的框架设计能力！\\n\\n花了4、5个小时的时间，一步一步捏出来，最后实现的功能大概有这些：\\n\\n| 功能点 | 说明 |\\n| --- | --- |\\n| data | 支持响应式数据 |\\n| watch | 监听响应式数据的变化 |\\n| methods | 支持方法 |\\n| components | 支持添加子组件 |\\n| props | 子组件支持props |\\n| mounted | 组件加载 |\\n| destroyed | 组件卸载 |\\n| render | 使用渲染函数渲染组件，支持子组件，html元素 |\\n| style | 支持style内联样式 |\\n| 事件处理 | 支持事件监听 |\\n| 局部重绘 | 只有状态变更的组件才会重绘 |\\n| 虚拟dom | 组件树转换成了VNode |\\n\\n没有列出的功能都是没有实现的，包括但不限于`模版语法`、`diff算法`、`计算属性`、`条件/列表渲染`、`组件slot`、`$emit`、`filter`、`mixin`、`全局方法`等等。*（内容有点太多了，这些都可以慢慢加，并不是重点）*。\\n\\n> 总结下来就是：Vue的核心设计包括`响应式`、`组件化`、`虚拟dom`、`diff算法`、`模版语法`。本次demo实现了`响应式`、`组件化`、`虚拟dom`。\\n\\n最终的用法和Vue一样：\\n```javascript\\nnew Vue({\\n  el: ref.current!, // 挂载到react的div元素上\\n  data() {\\n    return {\\n      toggle: true,\\n    };\\n  },\\n  methods: {\\n    clickChange() {\\n      this.toggle = !this.toggle;\\n    },\\n  },\\n  watch: {\\n    toggle: function (newVal, oldVal) {\\n      console.log(`toggle: ${oldVal} -> ${newVal}`);\\n    },\\n  },\\n  mounted() {\\n    console.log(\\\"page mounted\\\");\\n  },\\n  render(h) {\\n    return h(\\\"article\\\", {}, [\\n      h(\\\"h3\\\", {}, [\\\"父组件-【App】\\\"]),\\n      h(\\\"span\\\", {}, [`当前状态：${this.toggle ? \\\"开启\\\" : \\\"关闭\\\"}`]),\\n      h(\\\"button\\\", { onClick: this.clickChange }, [\\\"切换\\\"]),\\n    ]);\\n  },\\n});\\n```\\n\\n💻源码在最后。\\n\\n---\\n\\n### 先看Demo效果\\n\\n展示的效果如下：\\n\\n<video src=\\\"../static/assets/vue-演示.mov\\\" width=\\\"100%\\\" autoplay muted loop />\\n\\n渲染函数的组件结构：\\n\\n```typescript\\n// App组件\\nrender(h) {\\n  return h(\\n    \\\"article\\\",\\n    { style: { backgroundColor: \\\"aliceblue\\\", padding: \\\"10px\\\" } },\\n    [\\n      h(\\\"h3\\\", {}, [\\\"父组件-【App】\\\"]),\\n      h(\\\"span\\\", {}, [`当前状态：${this.toggle ? \\\"开启\\\" : \\\"关闭\\\"}`]),\\n      h(\\\"button\\\", { onClick: this.clickChange }, [\\\"切换\\\"]),\\n      h(\\\"section\\\", {}, [h(\\\"Comp\\\", { state: this.toggle })]), // Comp子组件\\n    ]\\n  );\\n}\\n...\\n// Comp组件\\nrender(h) {\\n  return h(\\\"div\\\", { style: { background: \\\"antiquewhite\\\" } }, [\\n    h(\\\"h3\\\", {}, [\\\"子组件-【Comp】\\\"]),\\n    h(\\\"p\\\", {}, [`父组件状态：${this.state ? \\\"开启\\\" : \\\"关闭\\\"}`]),\\n    h(\\\"button\\\", { onClick: this.clickAdd }, [\\\"count+1\\\"]),\\n    h(\\\"span\\\", { \\\"aria-label\\\": \\\"计数\\\" }, [`count: ${this.count}`]),\\n  ]);\\n}\\n```\\n\\n最终生成的dom结构：\\n\\n![](../static/assets/dom结构.jpg)\\n\\n### 实现步骤\\n\\n#### 搭出一个Vue架子\\n\\n**0. 准备工作**\\n\\n先创建一个`React项目`，用CRA也好，用其他模版也好。项目创建好后，在源码目录下创建一个`libs/vue.tsx`。\\n\\n**1. Vue设置选项**\\n\\n先想好我们要支持哪些功能，然后在`vue.tsx`中写好Vue的设置选项的类型`VueOptions`。这样我们`new Vue({/* VueOptions */})`的时候就能看到这些选项了。\\n\\n```typescript\\nexport type VueOptions = {\\n  el?: HTMLElement | null;\\n  components?: Record<string, VueOptions>;\\n  props?: string[];\\n  data?: () => Record<string, any>;\\n  watch?: Record<string, (newVal: any, oldVal: any) => void>;\\n  methods?: Record<string, any>;\\n  mounted?: () => void;\\n  destroyed?: () => void;\\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode;\\n};\\n```\\n\\n**2. Vue的class初始化**\\n\\n开始写Vue的class实现。Vue实例需要从VueOptions里读取配置，并初始化，存储为class变量。\\n\\n```typescript\\nexport default class Vue {\\n  _options: VueOptions; // 选项\\n  el?: HTMLElement | null; // 父级element元素\\n  components: Record<string, VueOptions>; // 声明的组件\\n  _componentInstances: Record<string, Vue>; // 使用到的组件实例\\n  data: Record<string, any>; // 数据\\n  methods: Record<string, any>; // 数据\\n  props: Record<string, any>; // 数据\\n  watchers: Record<string, (newVal: any, oldVal: any) => void>; // 监听器\\n  mounted: () => void; // 挂载完成回调\\n  destroyed: () => void; // 销毁回调\\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode; // 渲染函数\\n\\n  constructor(options: VueOptions) {\\n    this._options = options;\\n    // el\\n    this.el = options.el;\\n    // components\\n    this.components = options.components || {};\\n    // data\\n    this.data = options.data?.() || {};\\n    // method\\n    this.methods = options.methods || {};\\n    // prop\\n    this.props = {}\\n    for (const key of (options.props || [])) {\\n      this.props[key] = undefined;\\n    }\\n    // watch\\n    this.watchers = options.watch || {};\\n    // lifecycle\\n    this.mounted = options.mounted || (() => {});\\n    this.destroyed = options.destroyed || (() => {});\\n\\n    this.render = options.render;\\n\\n    this._init();\\n  }\\n  _init() {\\n    this.mounted();\\n    // 首次渲染\\n    this._doRender.call(this);\\n  }\\n  ...\\n}\\n```\\n\\n#### 监听数据变化\\n\\n数据都获取到了，开始搓Vue最重要的一个功能：`响应式`。响应式贯穿了Vue很多的功能，不过我们本次demo要实现的功能简化版的：监听data或props的数据变化，并且在变化时，触发watcher和重新渲染。Vue2和Vue3略有不同，Vue2使用`Object.defineProperty`实现，Vue3使用`Proxy`实现。我们这次demo直接用`Proxy`。\\n\\n考虑到我们要在watcher、method、生命周期里面都要通过this.xxx能访问到**data、methods和props**。所以将**data、methods和props**都加到一个proxy实例上，这个proxy是我们要实现响应式的核心。既要通过这个proxy监听数据变化，也要将watcher、method之类的`this指向`设置到为proxy上。\\n\\n> 这里和正版Vue的实现不一样，正版Vue的proxy为Vue实例本身，我们是新加了一个proxy对象。\\n\\n```typescript\\nexport default class Vue {\\n  ...\\n  // 去掉data、methods、props\\n  proxy: Record<string, any>; // 代理对象，用于访问this.data、this.methods、this.props\\n  ...\\n  constructor(options: VueOptions) {\\n    // 也去掉data、methods、props的初始化\\n    this.proxy = this._proxyThis(\\n      options.data?.(),\\n      options.methods,\\n      options.props\\n    );\\n  }\\n  ...\\n  // 为当前Vue实例创建一个代理\\n  _proxyThis(data: Record<string, any> = {}, methods: Record<string, any> = {}, props: string[] = []) {\\n    const that = this;\\n    const obj = { ...data, ...methods };\\n    for (const key of props) {\\n      obj[key] = undefined;\\n    }\\n    const proxy = new Proxy(obj, {\\n      get: (target, p: string, receiver) => {\\n        const value = target[p];\\n        if (typeof value === \\\"function\\\") {\\n          // 为methods绑定proxy\\n          return value.bind(proxy);\\n        }\\n        return value;\\n      },\\n      set: (target, p: string, newValue, receiver) => {\\n        const oldValue = target[p];\\n        target[p] = newValue;\\n        // 触发watcher\\n        if (p in that.watchers) {\\n          that.watchers[p].call(proxy, newValue, oldValue);\\n        }\\n        // 重新渲染\\n        that._doRender.call(that);\\n        return true;\\n      },\\n    });\\n    return proxy;\\n  }\\n}\\n```\\n\\n代码中，我们为methods和watchers重新设置`this`指向proxy。同时在`set`props和data时，触发watcher和重新渲染。\\n\\n#### 渲染一：生成虚拟dom\\n\\n接下来就是渲染过程。本次demo中我们没有使用`模版语法`，直接使用的是渲染函数。属实是简化了许多。\\n\\n> 正版Vue的模版语法，是有**解析模版html转为AST** -> **AST转为调用渲染函数** -> **渲染函数生成虚拟dom** -> **虚拟dom更新真实dom**。\\n\\n渲染函数即在每个vue组件中，都实现`render函数`来告知vue本组件是什么结构。`render函数`提供一个`h方法`来创建虚拟dom。\\n\\n所以我们需要通过我们提供的`h方法`，将本组件中的虚拟dom节点都记录下来。`h方法`我们保持和正版vue相同的三个参数：`type`-节点类型，`props`-节点属性，`children`-该节点的子节点数组。节点包含原生dom元素和已注册的vue组件，如果是原生dom元素，那props我们就当作元素的attrs设置上去；如果是组件，那props就作为组件的props传递下去。\\n\\n先不考虑vue组件，实现一下`h方法`：\\n\\n```typescript\\n/** 虚拟node节点 */\\nexport type VNode = {\\n  type: string;\\n  props: Record<string, any>;\\n  children: VNode[];\\n};\\n\\nexport default class Vue {\\n  ...\\n  h(type: string, props: any, children: any[] = []): VNode {\\n    let vnode: VNode;\\n    if (this.components.hasOwnProperty(type)) {\\n      // 如果是自定义组件 TODO\\n    } else {\\n      // 如果是原生标签\\n      // 存储为VNode\\n      vnode = { type, props, children };\\n      // 添加children\\n      vnode.children = [];\\n      for (const child of children) {\\n        if (typeof child === \\\"string\\\") {\\n          vnode.children.push({\\n            type: \\\"text\\\",\\n            props: { textContent: child },\\n            children: [],\\n          });\\n        } else {\\n          vnode.children.push(child);\\n        }\\n      }\\n    }\\n    return vnode;\\n  }\\n  ...\\n}\\n```\\n\\n这样我们就将原生dom元素和纯文本保存为`VNode`（就是定义的虚拟dom节点）\\n\\n#### 渲染二：创建真实dom\\n\\n前面我们在`init()`和`watcher触发`时都调用了`_doRender()方法`，在这里我们就是要执行具体的渲染操作了：将虚拟dom映射为真实dom上。该创建创建该更新更新。不过这个demo也是为了简单，正版vue是需要通过diff算法来判断哪些dom需要创建，哪些dom不需要创建只需要更新，这次的demo先去掉这些，每次渲染都是全部卸载后创建。*（日后有时间再补上）*\\n\\n```typescript\\nexport default class Vue {\\n  ...\\n  // 执行渲染（简化版本，没有加diff算法）\\n  _doRender() {\\n    if (this.el) {\\n      const vnodeTree = this.render(this.h.bind(this));\\n      // 清空el下所有元素\\n      this.el.innerHTML = \\\"\\\";\\n      // 重新渲染子树\\n      this._renderRecursively(vnodeTree, this.el);\\n    }\\n  }\\n\\n  // 递归渲染vnode树\\n  _renderRecursively(vnode: VNode, parent: HTMLElement) {\\n    if (vnode.type === \\\"text\\\") {\\n      // 文本节点\\n      parent.appendChild(document.createTextNode(vnode.props.textContent));\\n      return;\\n    } else if (vnode.type === \\\"Component\\\") {\\n      // 组件节点 TODO\\n      return;\\n    }\\n    // 其他节点，创建HtmlElement\\n    const element = document.createElement(vnode.type);\\n    // 设置属性\\n    for (const key in vnode.props) {\\n      if (key === \\\"style\\\") {\\n        // style\\n        Object.assign(element.style, vnode.props[key]);\\n      } else if (key.startsWith(\\\"on\\\")) {\\n        // 事件\\n        element.addEventListener(key.slice(2).toLowerCase(), vnode.props[key]);\\n      } else {\\n        // 其他\\n        element.setAttribute(key, vnode.props[key]);\\n      }\\n    }\\n    // 递归渲染children\\n    for (const child of vnode.children) {\\n      this._renderRecursively(child, element);\\n    }\\n    parent.appendChild(element);\\n  }\\n  ...\\n}\\n```\\n\\n`_renderRecursively`就是递归渲染VNode树。如果是文本虚拟dom，直接append；如果是组件，后面讲；否则作为原生dom元素：创建`element`，处理一下属性，然后递归处理children，再把处理完的自己加到dom树上。\\n\\n> 正版vue处理的属性不止`style`和`on事件`。这里简化了。\\n\\n#### 在React中试用\\n\\n到这里，我们手搓的简版vue对于渲染原生dom节点，并支持响应式、watcher、method等，已经没有任何问题！。赶紧试一下吧：\\n\\n创建一个React组件，引入vue，`import Vue from \\\"src/libs/vue\\\"`。加一个div，我们将vue组件渲染到这个div下。在`useEffect`hooks下，初始化vue实例，方便于React组件销毁时同时销毁Vue组件。\\n\\n```typescript\\nimport React, { useEffect, useRef } from \\\"react\\\";\\nimport Vue from \\\"../../libs/vue\\\";\\n\\nconst VueTest: React.FC = () => {\\n  const ref = useRef<HTMLDivElement>(null);\\n\\n  useEffect(() => {\\n    // App组件\\n    const App = new Vue({\\n      el: ref.current!, // 挂载到react的div元素上\\n      data() {\\n        return {\\n          toggle: true,\\n        };\\n      },\\n      methods: {\\n        clickChange() {\\n          this.toggle = !this.toggle;\\n        },\\n      },\\n      watch: {\\n        toggle: function (newVal, oldVal) {\\n          console.log(`toggle: ${oldVal} -> ${newVal}`);\\n        },\\n      },\\n      mounted() {\\n        console.log(\\\"page mounted\\\");\\n      },\\n      render(h) {\\n        return h(\\\"article\\\", {}, [\\n          h(\\\"h3\\\", {}, [\\\"父组件-【App】\\\"]),\\n          h(\\\"span\\\", {}, [`当前状态：${this.toggle ? \\\"开启\\\" : \\\"关闭\\\"}`]),\\n          h(\\\"button\\\", { onClick: this.clickChange }, [\\\"切换\\\"]),\\n        ]);\\n      },\\n    });\\n    // react页面销毁时，销毁vue的App实例\\n    return () => App.destroy();\\n  });\\n\\n  return <div id=\\\"vue-app\\\" ref={ref}></div>;\\n};\\n\\nexport default VueTest;\\n```\\n\\n功能一切正常！\\n\\n![](../static/assets/base测试.jpg)\\n\\n#### 支持组件化\\n\\n要支持组件化，主要是两步：一是在提供的`h方法`里，我们要初始化子组件实例，传递props，调用子组件的`render函数`获取子组件的VNode，然后把子组件的VNode记录下来，注意要把它和原生元素区分开。二是在实际渲染时，如果有子组件，则递归渲染子组件，然后append到dom树上即可。\\n\\n**1. 创建子组件实例**\\n\\n在原来的`h方法`里，补充上子组件的实现。注意子组件需要缓存下来，不能每次new一个新的实例。同时为了区分它是个组件类型，创建了一个`type: \\\"Component\\\"`的虚拟dom。\\n\\n```typescript\\nexport default class Vue {\\n  ...\\n  h(type: string, props: any, children: any[] = []): VNode {\\n    let vnode: VNode;\\n    if (this.components.hasOwnProperty(type)) {\\n      // 如果是自定义组件\\n      // 获取组件实例\\n      let component = this._componentInstances[type];\\n      if (!component) {\\n        component = new Vue(this.components[type]);\\n      }\\n      this._componentInstances[type] = component;\\n      // 更新proxy的props\\n      for (const key in props) {\\n        component.proxy[key] = props[key];\\n      }\\n      // 渲染组件到element\\n      vnode = {\\n        type: \\\"Component\\\",\\n        props,\\n        _component: component,\\n        children: [component.render(component.h.bind(component))],\\n      };\\n    } else {\\n      // 如果是原生标签\\n      ...\\n    }\\n    return vnode;\\n  }\\n  ...\\n}\\n```\\n\\n**2. 子组件递归渲染**\\n\\n渲染真实dom时，如果有子组件，递归渲染子组件。*（需要告知子组件父级真实dom是什么，不然无法append上去）*\\n```typescript\\nexport default class Vue {\\n  ...\\n  // 递归渲染vnode树\\n  _renderRecursively(vnode: VNode, parent: HTMLElement) {\\n    if (vnode.type === \\\"text\\\") {\\n      // 文本节点\\n      ...\\n    } else if (vnode.type === \\\"Component\\\") {\\n      // 组件节点\\n      if (vnode._component) {\\n        vnode._component.el = parent;\\n      }\\n      // 本身不用append，从第一个child开始\\n      this._renderRecursively(vnode.children[0], parent);\\n      return;\\n    }\\n    // 其他节点，创建HtmlElement\\n    ...\\n  }\\n  ...\\n}\\n```\\n\\n至此，Vue的组件化系统也支持完毕了。现在vue组件内可以声明子组件，渲染子组件。当然，子组件也可以继续包含子组件，形成任意级嵌套。属性也能通过props传递下去。最终的demo效果在开篇就已经展示了。\\n\\n### 源码\\n\\n完整的“Vue”的源码如下：\\n\\n```typescript\\n// src/libs/vue.tsx\\n/** Vue设置选项（同Vue2） */\\nexport type VueOptions = {\\n  el?: HTMLElement | null;\\n  components?: Record<string, VueOptions>;\\n  props?: string[];\\n  data?: () => Record<string, any>;\\n  watch?: Record<string, (newVal: any, oldVal: any) => void>;\\n  methods?: Record<string, any>;\\n  mounted?: () => void;\\n  destroyed?: () => void;\\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode;\\n\\n  [key: string]: any;\\n};\\n\\n/** 虚拟node节点 */\\nexport type VNode = {\\n  type: string;\\n  props: Record<string, any>;\\n  children: VNode[];\\n  _component?: Vue;\\n};\\n\\n/** Vue对象 */\\nexport default class Vue {\\n  _options: VueOptions; // 选项\\n  el?: HTMLElement | null; // 父级element元素\\n  components: Record<string, VueOptions>; // 声明的组件\\n  _componentInstances: Record<string, Vue>; // 使用到的组件实例\\n  proxy: Record<string, any>; // 代理对象，用于访问this.data、this.methods、this.props\\n  watchers: Record<string, (newVal: any, oldVal: any) => void>; // 监听器\\n  mounted: () => void; // 挂载完成回调\\n  destroyed: () => void; // 销毁回调\\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode; // 渲染函数\\n\\n  constructor(options: VueOptions) {\\n    this._options = options;\\n    // el\\n    this.el = options.el;\\n    // components\\n    this.components = options.components || {};\\n    this._componentInstances = {};\\n    // data\\n    this.proxy = this._proxyThis(\\n      options.data?.(),\\n      options.methods,\\n      options.props\\n    );\\n    // watch\\n    this.watchers = options.watch || {};\\n    // lifecycle\\n    this.mounted = options.mounted || (() => {});\\n    this.destroyed = options.destroyed || (() => {});\\n\\n    this.render = options.render.bind(this.proxy);\\n\\n    this._init();\\n  }\\n\\n  _init() {\\n    this.mounted();\\n    // 首次渲染\\n    this._doRender.call(this);\\n  }\\n\\n  // 为当前Vue实例创建一个代理\\n  _proxyThis(\\n    data: Record<string, any> = {},\\n    methods: Record<string, any> = {},\\n    props: string[] = []\\n  ) {\\n    const that = this;\\n    const obj = { ...data, ...methods };\\n    for (const key of props) {\\n      obj[key] = undefined;\\n    }\\n    const proxy = new Proxy(obj, {\\n      get: (target, p: string, receiver) => {\\n        const value = target[p];\\n        if (typeof value === \\\"function\\\") {\\n          // 为methods绑定proxy\\n          return value.bind(proxy);\\n        }\\n        return value;\\n      },\\n      set: (target, p: string, newValue, receiver) => {\\n        const oldValue = target[p];\\n        target[p] = newValue;\\n        // 触发watcher\\n        if (p in that.watchers) {\\n          that.watchers[p].call(proxy, newValue, oldValue);\\n        }\\n        // 重新渲染\\n        that._doRender.call(that);\\n        return true;\\n      },\\n    });\\n    return proxy;\\n  }\\n\\n  // 执行渲染（简化版本，没有加diff算法）\\n  _doRender() {\\n    if (this.el) {\\n      const vnodeTree = this.render(this.h.bind(this));\\n      // 清空el下所有元素\\n      this.el.innerHTML = \\\"\\\";\\n      // 重新渲染子树\\n      this._renderRecursively(vnodeTree, this.el);\\n    }\\n  }\\n\\n  // 递归渲染vnode树\\n  _renderRecursively(vnode: VNode, parent: HTMLElement) {\\n    if (vnode.type === \\\"text\\\") {\\n      // 文本节点\\n      parent.appendChild(document.createTextNode(vnode.props.textContent));\\n      return;\\n    } else if (vnode.type === \\\"Component\\\") {\\n      // 组件节点\\n      if (vnode._component) {\\n        vnode._component.el = parent;\\n      }\\n      // 本身不用append，从第一个child开始\\n      this._renderRecursively(vnode.children[0], parent);\\n      return;\\n    }\\n    // 其他节点，创建HtmlElement\\n    const element = document.createElement(vnode.type);\\n    // 设置属性\\n    for (const key in vnode.props) {\\n      if (key === \\\"style\\\") {\\n        // style\\n        Object.assign(element.style, vnode.props[key]);\\n      } else if (key.startsWith(\\\"on\\\")) {\\n        // 事件\\n        element.addEventListener(key.slice(2).toLowerCase(), vnode.props[key]);\\n      } else {\\n        // 其他\\n        element.setAttribute(key, vnode.props[key]);\\n      }\\n    }\\n    // 递归渲染children\\n    for (const child of vnode.children) {\\n      this._renderRecursively(child, element);\\n    }\\n    parent.appendChild(element);\\n  }\\n\\n  h(type: string, props: any, children: any[] = []): VNode {\\n    let vnode: VNode;\\n\\n    if (this.components.hasOwnProperty(type)) {\\n      // 如果是自定义组件\\n      // 获取组件实例\\n      let component = this._componentInstances[type];\\n      if (!component) {\\n        component = new Vue(this.components[type]);\\n      }\\n      this._componentInstances[type] = component;\\n      // 更新proxy的props\\n      for (const key in props) {\\n        component.proxy[key] = props[key];\\n      }\\n      // 渲染组件到element\\n      vnode = {\\n        type: \\\"Component\\\",\\n        props,\\n        _component: component,\\n        children: [component.render(component.h.bind(component))],\\n      };\\n    } else {\\n      // 如果是原生标签\\n      // 存储为VNode\\n      vnode = { type, props, children };\\n      // 添加children\\n      vnode.children = [];\\n      for (const child of children) {\\n        if (typeof child === \\\"string\\\") {\\n          vnode.children.push({\\n            type: \\\"text\\\",\\n            props: { textContent: child },\\n            children: [],\\n          });\\n        } else {\\n          vnode.children.push(child);\\n        }\\n      }\\n    }\\n\\n    return vnode;\\n  }\\n\\n  destroy() {\\n    // 销毁子组件\\n    for (const key in this._componentInstances) {\\n      this._componentInstances[key].destroy();\\n    }\\n    // 销毁自己\\n    this.destroyed();\\n  }\\n}\\n```\\n\\n完整的react测试页面如下：\\n```typescript\\n// src/pages/vuetest/index.tsx\\nimport React, { useEffect, useRef } from \\\"react\\\";\\nimport Vue, { VueOptions } from \\\"../../libs/vue\\\";\\n\\n// 子组件\\nconst Comp: VueOptions = {\\n  props: [\\\"state\\\"],\\n\\n  data() {\\n    return {\\n      count: 0,\\n    };\\n  },\\n\\n  watch: {\\n    count: function (newVal, oldVal) {\\n      console.log(`count: ${oldVal} -> ${newVal}`);\\n    },\\n  },\\n\\n  methods: {\\n    clickAdd() {\\n      this.add();\\n    },\\n    add() {\\n      this.count++;\\n    },\\n  },\\n\\n  mounted() {\\n    console.log(\\\"comp mounted\\\");\\n  },\\n\\n  destroyed() {\\n    console.log(\\\"comp destroyed\\\");\\n  },\\n\\n  render(h) {\\n    return h(\\\"div\\\", { style: { background: \\\"antiquewhite\\\" } }, [\\n      h(\\\"h3\\\", {}, [\\\"子组件-【Comp】\\\"]),\\n      h(\\\"p\\\", {}, [`父组件状态：${this.state ? \\\"开启\\\" : \\\"关闭\\\"}`]),\\n      h(\\\"button\\\", { onClick: this.clickAdd }, [\\\"count+1\\\"]),\\n      h(\\\"span\\\", { \\\"aria-label\\\": \\\"计数\\\" }, [`count: ${this.count}`]),\\n    ]);\\n  },\\n};\\n\\nconst VueTest: React.FC = () => {\\n  const ref = useRef<HTMLDivElement>(null);\\n\\n  useEffect(() => {\\n    // App组件\\n    const App = new Vue({\\n      el: ref.current!, // 挂载到react的div元素上\\n      components: { Comp },\\n      data() {\\n        return {\\n          toggle: true,\\n        };\\n      },\\n\\n      methods: {\\n        clickChange() {\\n          this.toggle = !this.toggle;\\n        },\\n      },\\n\\n      mounted() {\\n        console.log(\\\"page mounted\\\");\\n      },\\n\\n      destroyed() {\\n        console.log(\\\"page destroyed\\\");\\n      },\\n\\n      render(h) {\\n        return h(\\n          \\\"article\\\",\\n          { style: { backgroundColor: \\\"aliceblue\\\", padding: \\\"10px\\\" } },\\n          [\\n            h(\\\"h3\\\", {}, [\\\"父组件-【App】\\\"]),\\n            h(\\\"span\\\", {}, [`当前状态：${this.toggle ? \\\"开启\\\" : \\\"关闭\\\"}`]),\\n            h(\\\"button\\\", { onClick: this.clickChange }, [\\\"切换\\\"]),\\n            h(\\\"section\\\", {}, [h(\\\"Comp\\\", { state: this.toggle })]), // Comp子组件\\n          ]\\n        );\\n      },\\n    });\\n    // react页面销毁时，销毁vue的App实例\\n    return () => App.destroy();\\n  });\\n\\n  return <div id=\\\"vue-app\\\" ref={ref}></div>;\\n};\\n\\nexport default VueTest;\\n```\\n\",\"n\":0.024}}},{\"i\":54,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"【造轮子】Vue双端diff算法\\\"\\ncover: ../static/assets/vue-diff.jpeg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"结合之前手写的的Vue，加上diff算法实现差量更新dom\\\"\\ndatePublished: \\\"2022-09-28 12:52:49\\\"\\ndateModified: \\\"2022-09-28 12:52:49\\\"\\nslug: \\\"vue-demo-diff\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 前端\\n  - Vue2\\n  - 架构\\n  - 造轮子\\n---\\n\\n去年抽空花了半天时间，手敲了个[Vue的简易版](/vue-demo)，能够实现Vue的常规使用、响应式、虚拟dom、组件化等。但是布局渲染部分，是使用的虚拟dom转换为真实dom，然后全量插入到Vue的根节点。每次刷新都是全量，这个性能可见一斑。\\n\\n这次花点时间，在原来版本的基础上，尝试加上VNode的diff算法，然后在diff过程中差量更新真实dom树，实现一个真正能用的vue版本。\\n\\n> 声明！本次依然不是vue源码解析，是我自己基于vue的diff算法的理解，在原来的自制vue版本基础上加进去的。不代表官方实现！\\n\\n源码依然贴在最后面。\\n\\n#### 节点key\\n\\n在前面，我们实现了通过渲染函数生成虚拟dom树（VNode）。diff算法就是为了对比出新的Vnode树和旧的VNode树的差异：哪些VNode是新增的节点，哪些是要删除的节点，哪些是移动了位置的节点。对于新增的节点，我们要创建对应的真实dom；对于删除的节点，我们要删除对应的dom；对于移动位置的节点，我们可以复用原来的dom，只需要更新dom属性即可。\\n\\n在vue中，比对是根据节点的key和节点类型来判断的。如果key和类型一致，则视为同一节点；不一致则为不同节点。每个节点都有一个名为key的属性。如果未提供key，默认使用列表中的index。提供了key的话，比较起来会更高效。\\n\\n先加上创建key的函数：\\n\\n```typescript\\n/**\\n * 创建VNode的key\\n * 默认key为type-idx\\n * 如果提供了props.key，则为type-key\\n */\\nfunction _createKey(\\n  type: string,\\n  key: string | undefined,\\n  idx: number = 0\\n): string {\\n  return key ? `${type}-${key}` : `${type}-${idx}`;\\n}\\n```\\n\\n然后改造一下`h函数`，让它在生成VNode的同时生成key。\\n\\n```typescript\\n/** h函数帮助生成虚拟节点VNode */\\nfunction h(type: string, props: any, children: (VNode | string | null)[] = []): VNode {\\n  // 存储为VNode\\n  let vnode: VNode = { type, props, children: [], key: _createKey(type, props.key) };\\n  let nonNullChildren = children.filter((child) => child !== null);\\n  // 添加children\\n  for (let idx = 0; idx < nonNullChildren.length; idx++) {\\n    const child = nonNullChildren[idx];\\n    if (typeof child === \\\"string\\\") {\\n      vnode.children.push({\\n        type: \\\"text\\\",\\n        props: { textContent: child },\\n        children: [],\\n        key: _createKey(\\\"text\\\", undefined, idx),\\n      });\\n    } else {\\n      // 重新计算key\\n      child.key = _createKey(child.type, child.props.key, idx);\\n      vnode.children.push(child);\\n    }\\n  }\\n\\n  return vnode;\\n}\\n```\\n\\n> 这里没有考虑静态节点（不根据状态变化的节点）优化，所以节点如果不提供key的话，会跟它所处的index有关。那么只要发生中间元素的插入或删除，都会导致后面元素的key发生变化，匹配不上导致性能下降。\\n\\n#### 双端diff算法\\n\\n有了key之后，就可以根据key来判断新旧两组VNode，是如何变化的。vue采用了一种很高效的双端diff算法，即同时从新旧VNode数组的前后两端共4个指针，尝试相互匹配并向中间移动：即判断新前.key==旧前.key、新后.key==旧后.key、新前.key==旧后.key、新后.key==旧前.key，匹配到了则指针往中间移动一位。这四种匹配已经满足了大部分的列表变更情形：比如在列表中插入一个或多个元素，或者删除一个或多个元素。只要不是位置互换，这四种匹配都一定能匹配上。但是不保险，假如发生了位置很错乱的互换，那么这四种就可能匹配不到。所以还得有一个**backup方案**，就是直接在旧数组里面，查找key==新前.key的，如果查不到，那证明该元素是新增的，查到了则将旧数组这个位置的VNode置空，防止被再次匹配上。这种性能会差一些，但一般走不到。\\n\\n如果最后有一方指针走完了（新前指针大于新后指针或者旧前指针大于旧后指针），则代表新旧数组不可能再有匹配的了。如果这时候新数组还有剩余，那都是要新建的；如果旧数组还有剩余，那都是要删除的。\\n\\n在遍历过程中，要实时更新真实dom，比如创建、删除dom元素、或者只需要更新元素属性。有一些特殊情况，就是创建的要考虑dom元素插入的位置。比如旧前.key==新后.key，那就需要将旧前对应的dom移动到旧后对应的dom后面。同理如果某VNode.key==新前.key，那么需要将该节点的dom移动到旧前对应的dom前面（记住始终变动的是旧列表，所以位置都是以旧列表的指针来的）。\\n\\n完整的diff算法如下：\\n\\n```typescript\\n/**\\n * 遍历以及diff一组新旧VNode，同时对parent下的真实dom进行创建、更新、移动或删除。\\n * 从而以最小的变动让真实dom和最新VNode树保持一致。\\n */\\n_renderDomWithDiff(oldChildren: VNode[], newChildren: VNode[], parent: HTMLElement) {\\n  let oldStartIdx = 0;\\n  let oldEndIdx = oldChildren.length - 1;\\n  let newStartIdx = 0;\\n  let newEndIdx = newChildren.length - 1;\\n\\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n    // 旧节点可能已被匹配，被置空了，跳过\\n    if (!oldChildren[oldStartIdx]) {\\n      oldStartIdx++;\\n    } else if (!oldChildren[oldEndIdx]) {\\n      oldEndIdx--;\\n    } else if (\\n      oldChildren[oldStartIdx].key === newChildren[newStartIdx].key\\n    ) {\\n      // 旧开始节点和新开始节点key相同，无需移动dom\\n      console.log(`【${this.name}】[${oldChildren[oldStartIdx].key}]匹配到节点`);\\n      this._patch(oldChildren[oldStartIdx], newChildren[newStartIdx], parent);\\n      oldStartIdx++;\\n      newStartIdx++;\\n    } else if (oldChildren[oldEndIdx].key === newChildren[newEndIdx].key) {\\n      // 旧结束节点和新结束节点key相同，无需移动dom\\n      console.log(`【${this.name}】[${oldChildren[oldEndIdx].key }]匹配到节点`);\\n      this._patch(oldChildren[oldEndIdx], newChildren[newEndIdx], parent);\\n      oldEndIdx--;\\n      newEndIdx--;\\n    } else if (oldChildren[oldStartIdx].key === newChildren[newEndIdx].key) {\\n      // 旧开始节点和新结束节点key相同，需要移动到旧结束节点后面\\n      console.log(`【${this.name}】[${oldChildren[oldStartIdx].key}]匹配到节点`);\\n      const node = this._patch(\\n        oldChildren[oldStartIdx],\\n        newChildren[newEndIdx],\\n        parent\\n      );\\n      parent.insertBefore(node, oldChildren[oldEndIdx]._domNode!.nextSibling);\\n      oldStartIdx++;\\n      newEndIdx--;\\n    } else if (oldChildren[oldEndIdx].key === newChildren[newStartIdx].key) {\\n      // 旧结束节点和新开始节点key相同，需要移动到旧开始节点前面\\n      console.log(`【${this.name}】[${oldChildren[oldEndIdx].key}]匹配到节点`);\\n      const node = this._patch(\\n        oldChildren[oldEndIdx],\\n        newChildren[newStartIdx],\\n        parent\\n      );\\n      parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\\n      oldEndIdx--;\\n      newStartIdx++;\\n    } else {\\n      // 前面四种情况都不匹配，尝试从旧数组中匹配新开始节点\\n      const idxInOld = oldChildren.findIndex(\\n        (node) => node && node.key === newChildren[newStartIdx].key\\n      );\\n      if (idxInOld !== -1) {\\n        // 找到了，需要移动到旧开始节点前面\\n        console.log(`【${this.name}】[${newChildren[newStartIdx].key}]匹配到节点`);\\n        const node = this._patch(\\n          oldChildren[idxInOld],\\n          newChildren[newStartIdx],\\n          parent\\n        );\\n        parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\\n        // 置空，防止反复鞭尸\\n        // @ts-ignore\\n        oldChildren[idxInOld] = undefined;\\n      } else {\\n        // 找不到，创建dom，插入到旧开始节点前面\\n        console.log(`【${this.name}】[${newChildren[newStartIdx].key}]是新增节点`);\\n        // 插入到oldStartIdx前面正好保证顺序\\n        const node = this._patch(undefined, newChildren[newStartIdx], parent);\\n        parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\\n      }\\n      newStartIdx++;\\n    }\\n  }\\n\\n  // 新节点比较完毕，旧节点还有剩余\\n  if (oldStartIdx <= oldEndIdx) {\\n    for (let i = oldStartIdx; i <= oldEndIdx; i++) {\\n      if (!oldChildren[i]) continue;\\n      // 删除掉对应的dom\\n      console.log(`【${this.name}】[${oldChildren[i].key}]是删除节点`);\\n      parent.removeChild(oldChildren[i]._domNode!);\\n      // 如果是组件，需要销毁\\n      if (this.components.hasOwnProperty(oldChildren[i].type)) {\\n        this._unmountComponent(oldChildren[i].key);\\n      }\\n    }\\n  } else if (newStartIdx <= newEndIdx) {\\n    // 旧节点比较完毕，新节点还有剩余\\n    for (let i = newStartIdx; i <= newEndIdx; i++) {\\n      console.log(`【${this.name}】[${newChildren[i].key}]是新增节点`);\\n      // 创建dom，插入到parent末尾\\n      const node = this._patch(undefined, newChildren[i], parent);\\n      parent.insertBefore(node, newChildren[newEndIdx + 1]?._domNode || null);\\n    }\\n  }\\n}\\n```\\n\\n这样，只需要告诉新旧两个VNode树，和它们的parent节点。调用该方法后，就能在parent节点下，差量更新它的children dom元素。\\n\\n#### _patch方法\\n\\n里面还有一个重要的方法，就是`_patch方法`。这个方法就是处理那些key相同的VNode，如果是text，则更新文本内容。如果是组件，则复用组件更新props。否则为dom，让它们更新属性。（额外的情况，如果旧VNode为空，则创建对应的dom）。\\n\\n同时需要在这里处理递归，调用`_renderDomWithDiff`函数。\\n\\n```typescript\\n/**\\n * 创建或更新真实dom节点。\\n * 1. 如果有oldVNode：复用dom，只更新dom属性。\\n * 2. 如果没有oldVNode：创建新的dom\\n * 3. 递归处理children\\n */\\n_patch(oldVNode: VNode | undefined, vnode: VNode, parent: HTMLElement): Node {\\n  // 1. 文本节点\\n  if (vnode.type === \\\"text\\\") {\\n    if (!oldVNode) {\\n      // 没有则创建\\n      const node = document.createTextNode(vnode.props.textContent);\\n      vnode._domNode = node;\\n    } else {\\n      if (oldVNode.props.textContent !== vnode.props.textContent) {\\n        oldVNode._domNode!.textContent = vnode.props.textContent;\\n      }\\n      vnode._domNode = oldVNode._domNode;\\n    }\\n    return vnode._domNode!;\\n  }\\n\\n  // 2. 组件节点\\n  if (this.components.hasOwnProperty(vnode.type)) {\\n    if (!oldVNode) {\\n      // 没有则创建\\n      let component = this._componentInstances[vnode.key];\\n      if (!component) {\\n        component = new Vue(this.components[vnode.type]);\\n        component._innerSetName(vnode.type);\\n        this._componentInstances[vnode.key] = component;\\n      }\\n      // 更新proxy的props\\n      for (const key in vnode.props) {\\n        component.proxy[key] = vnode.props[key];\\n      }\\n      vnode._component = component;\\n    } else {\\n      // 否则只需更新\\n      for (const key in vnode.props) {\\n        oldVNode._component!.proxy[key] = vnode.props[key];\\n      }\\n      vnode._component = oldVNode._component;\\n    }\\n\\n    vnode._component!.el = parent;\\n    // 子组件去渲染自己的元素即可\\n    vnode._component!._doRender();\\n    vnode._domNode = vnode._component!._lastVNode!._domNode!;\\n    return vnode._domNode;\\n  }\\n\\n  // 3. 其他节点\\n  if (!oldVNode) {\\n    // 没有则创建\\n    const element = document.createElement(vnode.type);\\n    // 设置属性\\n    _updateProps(element, vnode.props);\\n    vnode._domNode = element;\\n  } else {\\n    // 否则只需更新\\n    _updateProps(\\n      oldVNode._domNode as HTMLElement,\\n      vnode.props,\\n      oldVNode.props\\n    );\\n    vnode._domNode = oldVNode._domNode;\\n  }\\n\\n  // 递归处理children\\n  this._renderDomWithDiff(\\n    oldVNode?.children || [],\\n    vnode.children,\\n    vnode._domNode as HTMLElement\\n  );\\n\\n  return vnode._domNode!;\\n}\\n```\\n\\n到这里通过双端diff算法差量更新真实dom的工作就全部做完了。现在我们需要将递归渲染函数，由原来的全量创建版本`_renderRecursively`改为现在写的差量更新版本`_renderDomWithDiff`。\\n\\n#### 区分App组件和子组件\\n\\n现在每个Vue组件都可以使用`_renderDomWithDiff`函数，来将自己下面的元素都绘制到`this.el`上了。但是子组件还好，它能始终保证它的`this.el`下面children都是由我们的渲染机制渲染出来的。而App组件就无法保证了，因为它挂载在一个根dom元素上，可能这个根dom元素上本来就有其他元素。这样我们差量更新可能会导致更新了错误的元素。所以我们要区分一下App根组件和其他组件。\\n\\n参考Vue3，它是通过`createApp`方法来创建一个App级别的Vue实例的。我们也一样：\\n\\n```typescript\\n/** 创建一个根Vue组件 */\\nexport function createApp(options: VueOptions) {\\n  const vue = new Vue(options);\\n  vue._isAppRoot = true;\\n  vue._innerSetName(\\\"App\\\");\\n  // @ts-ignore\\n  window.__vue_app__ = vue;\\n  return vue;\\n}\\n```\\n\\n然后我们在执行`_renderDomWithDiff`函数之前，如果首次渲染，需要清空元素。\\n\\n```typescript\\n// 执行渲染\\n_doRender() {\\n  if (this.el) {\\n    const vnodeTree = this.render(h.bind(this));\\n    // 根组件首次渲染，清空el下所有元素，防止VNode和真实dom不一致\\n    if (this._isAppRoot) {\\n      // 首次渲染\\n      if (!this._lastVNode) {\\n        this.el.innerHTML = \\\"\\\";\\n      }\\n    }\\n\\n    // 使用diff算法重新渲染子树\\n    this._renderDomWithDiff(\\n      this._lastVNode ? [this._lastVNode] : [],\\n      [vnodeTree],\\n      this.el\\n    );\\n    // 记录下来\\n    this._lastVNode = vnodeTree;\\n  }\\n}\\n```\\n\\n#### 异步更新\\n\\n整个差量更新渲染流程已经ready。但是还有一个问题，现在是同步执行的渲染，初始化或者每次数据变更，都会导致一个`_doRender()`差量更新。虽然已经差量更新了，但也架不住可能出现的1秒更新100次吧...\\n\\n所以参考vue，我们加一下异步更新，即多次发起render，但是一段时间只会执行一次实际渲染。\\n\\n我们通过微任务+防抖实现，这样的话，同步代码触发的不管多少次，都会在同步代码执行结束后，只执行一次实际渲染。\\n\\n```typescript\\n// 异步更新队列，在微任务结束后执行渲染\\n_queueRender() {\\n  // 防抖\\n  if (!this._updateQueued) {\\n    this._updateQueued = true;\\n    Promise.resolve().then(() => {\\n      this._doRender();\\n      this._updateQueued = false;\\n    });\\n  }\\n}\\n```\\n\\n初始化和proxy状态变更触发，都调用`_queueRender`：\\n\\n```typescript\\n  _init() {\\n    this.mounted();\\n    // 首次渲染\\n    this._queueRender.call(this);\\n  }\\n\\n  _proxyThis(data: Record<string, any> = {}, methods: Record<string, any> = {}, props: string[] = []) {\\n    ...\\n    const proxy = new Proxy(obj, {\\n      ...\\n      set: (target, p: string, newValue, receiver) => {\\n        ...\\n        // 重新渲染\\n        that._queueRender.call(that);\\n      ...\\n      }\\n    }\\n    ...\\n  }\\n```\\n\\n#### 其他\\n\\n其他还有一些变动，诸如组件卸载逻辑、dom属性更新逻辑。都不是重点，不再介绍，简单看下源码即可。\\n\\n#### 源码\\n\\n加上了diff算法差量更新，以及异步更新后，最新的手搓简版vue代码如下：\\n\\n```typescript\\n/** Vue设置选项（同Vue2） */\\nexport type VueOptions = {\\n  name?: string;\\n  el?: HTMLElement | null;\\n  components?: Record<string, VueOptions>;\\n  props?: string[];\\n  data?: () => Record<string, any>;\\n  watch?: Record<string, (newVal: any, oldVal: any) => void>;\\n  methods?: Record<string, any>;\\n  mounted?: () => void;\\n  destroyed?: () => void;\\n  render: (\\n    h: (tag: string, opts: any, children?: (VNode | string | null)[]) => VNode\\n  ) => VNode;\\n\\n  [key: string]: any;\\n};\\n\\n/** 虚拟node节点 */\\nexport type VNode = {\\n  key: string;\\n  type: string;\\n  props: Record<string, any>;\\n  children: VNode[];\\n  _component?: Vue;\\n  _domNode?: Node | null;\\n};\\n\\n/** 创建一个根Vue组件 */\\nexport function createApp(options: VueOptions) {\\n  const vue = new Vue(options);\\n  vue._isAppRoot = true;\\n  vue._innerSetName(\\\"App\\\");\\n  // @ts-ignore\\n  window.__vue_app__ = vue;\\n  return vue;\\n}\\n\\n/** Vue对象 */\\nexport default class Vue {\\n  name?: string;\\n  _isAppRoot: boolean = false; // 是否是App根组件\\n  _options: VueOptions; // 选项\\n  el?: HTMLElement | null; // 父级element元素\\n  components: Record<string, VueOptions>; // 声明的组件\\n  _componentInstances: Record<string, Vue>; // 使用到的组件实例\\n  proxy: Record<string, any>; // 代理对象，用于访问this.data、this.methods、this.props\\n  watchers: Record<string, (newVal: any, oldVal: any) => void>; // 监听器\\n  _lastVNode?: VNode; // 上一次渲染的vnode\\n  mounted: () => void; // 挂载完成回调\\n  destroyed: () => void; // 销毁回调\\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode; // 渲染函数\\n  _updateQueued: boolean = false; // 是否有更新任务\\n\\n  constructor(options: VueOptions) {\\n    this._options = options;\\n    // name\\n    this.name = options.name;\\n    // el\\n    this.el = options.el;\\n    // components\\n    this.components = options.components || {};\\n    this._componentInstances = {};\\n    // data\\n    this.proxy = this._proxyThis(\\n      options.data?.(),\\n      options.methods,\\n      options.props\\n    );\\n    // watch\\n    this.watchers = options.watch || {};\\n    // lifecycle\\n    this.mounted = options.mounted || (() => {});\\n    this.destroyed = options.destroyed || (() => {});\\n\\n    this.render = options.render.bind(this.proxy);\\n\\n    this._init();\\n  }\\n\\n  _init() {\\n    this.mounted();\\n    // 首次渲染\\n    this._queueRender.call(this);\\n  }\\n\\n  /** 设置组件name，如果已在options中设置，则忽略 */\\n  _innerSetName(name: string) {\\n    if (!this.name) this.name = name;\\n  }\\n\\n  // 为当前Vue实例创建一个代理\\n  _proxyThis(\\n    data: Record<string, any> = {},\\n    methods: Record<string, any> = {},\\n    props: string[] = []\\n  ) {\\n    const that = this;\\n    const obj = { ...data, ...methods };\\n    for (const key of props) {\\n      obj[key] = undefined;\\n    }\\n    const proxy = new Proxy(obj, {\\n      get: (target, p: string, receiver) => {\\n        const value = target[p];\\n        if (typeof value === \\\"function\\\") {\\n          // 为methods绑定proxy\\n          return value.bind(proxy);\\n        }\\n        return value;\\n      },\\n      set: (target, p: string, newValue, receiver) => {\\n        const oldValue = target[p];\\n        target[p] = newValue;\\n        // 触发watcher\\n        if (p in that.watchers) {\\n          that.watchers[p].call(proxy, newValue, oldValue);\\n        }\\n        // 重新渲染\\n        that._queueRender.call(that);\\n        return true;\\n      },\\n    });\\n    return proxy;\\n  }\\n\\n  // 异步更新队列，在微任务结束后执行渲染\\n  _queueRender() {\\n    // 防抖\\n    if (!this._updateQueued) {\\n      this._updateQueued = true;\\n      Promise.resolve().then(() => {\\n        this._doRender();\\n        this._updateQueued = false;\\n      });\\n    }\\n  }\\n\\n  // 执行渲染\\n  _doRender() {\\n    if (this.el) {\\n      const vnodeTree = this.render(h.bind(this));\\n      // 根组件首次渲染，清空el下所有元素，防止VNode和真实dom不一致\\n      if (this._isAppRoot) {\\n        // 首次渲染\\n        if (!this._lastVNode) {\\n          this.el.innerHTML = \\\"\\\";\\n        }\\n      }\\n\\n      // 使用diff算法重新渲染子树\\n      this._renderDomWithDiff(\\n        this._lastVNode ? [this._lastVNode] : [],\\n        [vnodeTree],\\n        this.el\\n      );\\n      // 记录下来\\n      this._lastVNode = vnodeTree;\\n    }\\n  }\\n\\n  destroy() {\\n    // 销毁子组件\\n    this._unmountComponents();\\n    // 销毁自己\\n    this.destroyed();\\n  }\\n\\n  /** 销毁特定的子组件实例 */\\n  _unmountComponent(key: string) {\\n    if (this._componentInstances.hasOwnProperty(key)) {\\n      this._componentInstances[key].destroy();\\n      delete this._componentInstances[key];\\n    }\\n  }\\n\\n  /** 未销毁的子组件实例全部销毁 */\\n  _unmountComponents() {\\n    for (const key in this._componentInstances) {\\n      this._componentInstances[key].destroy();\\n    }\\n    this._componentInstances = {};\\n  }\\n\\n  /**\\n   * 遍历以及diff一组新旧VNode，同时对parent下的真实dom进行创建、更新、移动或删除。\\n   * 从而以最小的变动让真实dom和最新VNode树保持一致。\\n   *\\n   * 原理：\\n   * 使用双端diff算法，新旧前后共4个指针从两端向中间移动并尝试相互匹配。\\n   * 匹配到key相同的VNode，复用dom，调用patch更新属性，然后移动或保持dom位置（根据指针）；\\n   * 未匹配到key相同的VNode，创建dom并插入到parent某个位置下（根据指针）；\\n   * 最后，如果旧的VNode有多余，删除parent下对应的dom。\\n   *\\n   * @param oldChildren 旧children\\n   * @param newChildren 新children\\n   * @param parent 父级dom元素\\n   */\\n  _renderDomWithDiff(\\n    oldChildren: VNode[],\\n    newChildren: VNode[],\\n    parent: HTMLElement\\n  ) {\\n    let oldStartIdx = 0;\\n    let oldEndIdx = oldChildren.length - 1;\\n    let newStartIdx = 0;\\n    let newEndIdx = newChildren.length - 1;\\n\\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\\n      // 旧节点可能已被匹配，被置空了，跳过\\n      if (!oldChildren[oldStartIdx]) {\\n        oldStartIdx++;\\n      } else if (!oldChildren[oldEndIdx]) {\\n        oldEndIdx--;\\n      } else if (\\n        oldChildren[oldStartIdx].key === newChildren[newStartIdx].key\\n      ) {\\n        // 旧开始节点和新开始节点key相同，无需移动dom\\n        console.log(\\n          `【${this.name}】[${oldChildren[oldStartIdx].key}]匹配到节点`\\n        );\\n        this._patch(oldChildren[oldStartIdx], newChildren[newStartIdx], parent);\\n        oldStartIdx++;\\n        newStartIdx++;\\n      } else if (oldChildren[oldEndIdx].key === newChildren[newEndIdx].key) {\\n        // 旧结束节点和新结束节点key相同，无需移动dom\\n        console.log(\\n          `【${this.name}】[${oldChildren[oldEndIdx].key}]匹配到节点`\\n        );\\n        this._patch(oldChildren[oldEndIdx], newChildren[newEndIdx], parent);\\n        oldEndIdx--;\\n        newEndIdx--;\\n      } else if (oldChildren[oldStartIdx].key === newChildren[newEndIdx].key) {\\n        // 旧开始节点和新结束节点key相同，需要移动到旧结束节点后面\\n        console.log(\\n          `【${this.name}】[${oldChildren[oldStartIdx].key}]匹配到节点`\\n        );\\n        const node = this._patch(\\n          oldChildren[oldStartIdx],\\n          newChildren[newEndIdx],\\n          parent\\n        );\\n        parent.insertBefore(node, oldChildren[oldEndIdx]._domNode!.nextSibling);\\n        oldStartIdx++;\\n        newEndIdx--;\\n      } else if (oldChildren[oldEndIdx].key === newChildren[newStartIdx].key) {\\n        // 旧结束节点和新开始节点key相同，需要移动到旧开始节点前面\\n        console.log(\\n          `【${this.name}】[${oldChildren[oldEndIdx].key}]匹配到节点`\\n        );\\n        const node = this._patch(\\n          oldChildren[oldEndIdx],\\n          newChildren[newStartIdx],\\n          parent\\n        );\\n        parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\\n        oldEndIdx--;\\n        newStartIdx++;\\n      } else {\\n        // 前面四种情况都不匹配，尝试从旧数组中匹配新开始节点\\n        const idxInOld = oldChildren.findIndex(\\n          (node) => node && node.key === newChildren[newStartIdx].key\\n        );\\n        if (idxInOld !== -1) {\\n          // 找到了，需要移动到旧开始节点前面\\n          console.log(\\n            `【${this.name}】[${newChildren[newStartIdx].key}]匹配到节点`\\n          );\\n          const node = this._patch(\\n            oldChildren[idxInOld],\\n            newChildren[newStartIdx],\\n            parent\\n          );\\n          parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\\n          // 置空，防止反复鞭尸\\n          // @ts-ignore\\n          oldChildren[idxInOld] = undefined;\\n        } else {\\n          // 找不到，创建dom，插入到旧开始节点前面\\n          console.log(\\n            `【${this.name}】[${newChildren[newStartIdx].key}]是新增节点`\\n          );\\n          // 插入到oldStartIdx前面正好保证顺序\\n          const node = this._patch(undefined, newChildren[newStartIdx], parent);\\n          parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\\n        }\\n        newStartIdx++;\\n      }\\n    }\\n\\n    // 新节点比较完毕，旧节点还有剩余\\n    if (oldStartIdx <= oldEndIdx) {\\n      for (let i = oldStartIdx; i <= oldEndIdx; i++) {\\n        if (!oldChildren[i]) continue;\\n        // 删除掉对应的dom\\n        console.log(`【${this.name}】[${oldChildren[i].key}]是删除节点`);\\n        parent.removeChild(oldChildren[i]._domNode!);\\n        // 如果是组件，需要销毁\\n        if (this.components.hasOwnProperty(oldChildren[i].type)) {\\n          this._unmountComponent(oldChildren[i].key);\\n        }\\n      }\\n    } else if (newStartIdx <= newEndIdx) {\\n      // 旧节点比较完毕，新节点还有剩余\\n      for (let i = newStartIdx; i <= newEndIdx; i++) {\\n        console.log(`【${this.name}】[${newChildren[i].key}]是新增节点`);\\n        // 创建dom，插入到parent末尾\\n        const node = this._patch(undefined, newChildren[i], parent);\\n        parent.insertBefore(node, newChildren[newEndIdx + 1]?._domNode || null);\\n      }\\n    }\\n  }\\n\\n  /**\\n   * 创建或更新真实dom节点。\\n   *\\n   * 1. 如果有oldVNode：复用dom，只更新dom属性。\\n   * 2. 如果没有oldVNode：创建新的dom\\n   * 3. 递归处理children\\n   * @param oldVNode 旧的vnode\\n   * @param vnode 新的vnode\\n   * @param parent 父级dom元素\\n   * @returns 真实dom节点\\n   */\\n  _patch(oldVNode: VNode | undefined, vnode: VNode, parent: HTMLElement): Node {\\n    // 1. 文本节点\\n    if (vnode.type === \\\"text\\\") {\\n      if (!oldVNode) {\\n        // 没有则创建\\n        const node = document.createTextNode(vnode.props.textContent);\\n        vnode._domNode = node;\\n      } else {\\n        if (oldVNode.props.textContent !== vnode.props.textContent) {\\n          oldVNode._domNode!.textContent = vnode.props.textContent;\\n        }\\n        vnode._domNode = oldVNode._domNode;\\n      }\\n      return vnode._domNode!;\\n    }\\n\\n    // 2. 组件节点\\n    if (this.components.hasOwnProperty(vnode.type)) {\\n      if (!oldVNode) {\\n        // 没有则创建\\n        let component = this._componentInstances[vnode.key];\\n        if (!component) {\\n          component = new Vue(this.components[vnode.type]);\\n          component._innerSetName(vnode.type);\\n          this._componentInstances[vnode.key] = component;\\n        }\\n        // 更新proxy的props\\n        for (const key in vnode.props) {\\n          component.proxy[key] = vnode.props[key];\\n        }\\n        vnode._component = component;\\n      } else {\\n        // 否则只需更新\\n        for (const key in vnode.props) {\\n          oldVNode._component!.proxy[key] = vnode.props[key];\\n        }\\n        vnode._component = oldVNode._component;\\n      }\\n\\n      vnode._component!.el = parent;\\n      // 子组件去渲染自己的元素即可\\n      vnode._component!._doRender();\\n      vnode._domNode = vnode._component!._lastVNode!._domNode!;\\n      return vnode._domNode;\\n    }\\n\\n    // 3. 其他节点\\n    if (!oldVNode) {\\n      // 没有则创建\\n      const element = document.createElement(vnode.type);\\n      // 设置属性\\n      _updateProps(element, vnode.props);\\n      vnode._domNode = element;\\n    } else {\\n      // 否则只需更新\\n      _updateProps(\\n        oldVNode._domNode as HTMLElement,\\n        vnode.props,\\n        oldVNode.props\\n      );\\n      vnode._domNode = oldVNode._domNode;\\n    }\\n\\n    // 递归处理children\\n    this._renderDomWithDiff(\\n      oldVNode?.children || [],\\n      vnode.children,\\n      vnode._domNode as HTMLElement\\n    );\\n\\n    return vnode._domNode!;\\n  }\\n}\\n\\n/** 差量更新dom节点的属性 */\\nfunction _updateProps(\\n  element: HTMLElement,\\n  props: Record<string, any>,\\n  oldProps?: Record<string, any>\\n) {\\n  for (const key in props) {\\n    if (key === \\\"style\\\") {\\n      // style\\n      if (oldProps && oldProps[\\\"style\\\"]) {\\n        // 清空旧的style\\n        for (const styleKey in oldProps[\\\"style\\\"]) {\\n          // @ts-ignore\\n          element.style[styleKey] = \\\"\\\";\\n        }\\n      }\\n      Object.assign(element.style, props[key]);\\n    } else if (key.startsWith(\\\"on\\\")) {\\n      // 事件\\n      if (oldProps && oldProps[key]) {\\n        // 移除旧的事件\\n        element.removeEventListener(key.slice(2).toLowerCase(), oldProps[key]);\\n      }\\n      element.addEventListener(key.slice(2).toLowerCase(), props[key]);\\n    } else {\\n      // 其他\\n      if (oldProps && oldProps[key]) {\\n        // 移除旧属性\\n        element.removeAttribute(key);\\n      }\\n      element.setAttribute(key, props[key]);\\n    }\\n  }\\n}\\n\\n/** h函数帮助生成虚拟节点VNode */\\nfunction h(\\n  type: string,\\n  props: any,\\n  children: (VNode | string | null)[] = []\\n): VNode {\\n  // 存储为VNode\\n  let vnode: VNode = {\\n    type,\\n    props,\\n    children: [],\\n    key: _createKey(type, props.key),\\n  };\\n  let nonNullChildren = children.filter((child) => child !== null);\\n  // 添加children\\n  for (let idx = 0; idx < nonNullChildren.length; idx++) {\\n    const child = nonNullChildren[idx];\\n    if (typeof child === \\\"string\\\") {\\n      vnode.children.push({\\n        type: \\\"text\\\",\\n        props: { textContent: child },\\n        children: [],\\n        key: _createKey(\\\"text\\\", undefined, idx),\\n      });\\n    } else {\\n      // 重新计算key\\n      child.key = _createKey(child.type, child.props.key, idx);\\n      vnode.children.push(child);\\n    }\\n  }\\n\\n  return vnode;\\n}\\n\\n/**\\n * 创建VNode的key\\n * 默认key为type-idx\\n * 如果提供了props.key，则为type-key\\n */\\nfunction _createKey(\\n  type: string,\\n  key: string | undefined,\\n  idx: number = 0\\n): string {\\n  return key ? `${type}-${key}` : `${type}-${idx}`;\\n}\\n```\",\"n\":0.023}}},{\"i\":55,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"vue-i18n-converter\\\"\\ncover: images/default_img6.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"将vue2项目源码中，提取中文替换为i18n配置，提升国际化效率\\\"\\ndatePublished: \\\"2022-03-25 16:30:20\\\"\\ndateModified: \\\"2022-03-25 16:30:20\\\"\\ncategory: \\\"框架工具\\\"\\ntags:\\n  - 前端\\n  - Node.js\\n  - 脚本\\n  - 开源\\n---\\n\\n**vue-i18n-converter**是一个脚本工具。用于vue2项目中，提取项目中的中文转为i18n的配置，并生成i18n配置文件。\\n\\nGitee仓库：https://gitee.com/missmess/vue-i18n-converter-script\\n\\n---\\n\\n### 导航\\n\\n- [使用方法](#使用方法)\\n- [已实现功能](#已实现功能)\\n- [其他场景](#其他场景)\\n\\n### 使用方法\\n```shell\\nnode index.js (文件或目录路径) [-js]\\n```\\n\\n#### 参数说明\\n\\n参数1（必填参数）:\\n\\nvue文件地址或目录地址，如果传目录地址则递归处理该目录下的所有vue文件\\n\\n参数2 `-js`（可选参数）:\\n\\n如果传入`-js`，才会去处理vue文件中的script块。默认不传入则不处理script块\\n\\n#### 示例:\\n```shell\\nnode index.js /Users/missmess/FEProjects/lilishop-ui/buyer/src/ -js\\n```\\n\\n脚本执行成功后，将在output目录下，会生成作为参数传入的，并且已经转换好的vue文件或同样结构的目录。同时生成cn.json的语言配置文件。\\n\\n可以将转换后的文件或目录覆盖源文件或目录，然后自己复制多套语言配置文件，自行翻译，并放入到项目中使用。\\n\\n> **注意：需要自己安装[vue-i18n](https://kazupon.github.io/vue-i18n/zh/introduction.html)，并在main.js中配置i18n。**\\n\\n---\\n\\n### 已实现功能\\n1. 处理template块中组件属性中的连续中文：\\n  ```html\\n  <!-- CouponCenter.vue -->\\n  <!-- 转换前 -->\\n  <Input search style=\\\"width:400px\\\" @on-search='search' enter-button=\\\"搜索\\\" placeholder=\\\"搜索优惠券\\\" />\\n  <!-- 转换后 -->\\n  <Input search style=\\\"width:400px\\\" @on-search='search' :enter-button=\\\"$t('CouponCenter.搜索')\\\" :placeholder=\\\"$t('CouponCenter.搜索优惠券')\\\" />\\n  ```\\n  对应的i18n配置文件的key（下同）\\n  ```json\\n  {\\n    \\\"CouponCenter\\\": {\\n      \\\"搜索\\\": \\\"搜索\\\",\\n      \\\"搜索优惠券\\\": \\\"搜索优惠券\\\",\\n    }\\n  }\\n  ```\\n\\n2. 处理template块中的非属性中的连续中文\\n  ```html\\n  <!-- CouponCenter.vue -->\\n  <!-- 转换前 -->\\n  <p>使用范围</p>\\n  <p>有效期：{{item.endTime}}</p>\\n  <!-- 转换后 -->\\n  <p>{{ $t(\\\"CouponCenter.使用范围\\\") }}</p>\\n  <p>{{ $t(\\\"CouponCenter.有效期\\\") }}：{{item.endTime}}</p>\\n  ```\\n\\n3. 处理script块中字符串中文段落\\n  仅当执行脚本时，传入`-js`参数才生效\\n  ```javascript\\n  /* Cart.vue */\\n  // 转换前\\n  this.$Message.success(\\\"领取成功\\\");\\n  // 转换后\\n  this.$Message.success(this.$t(\\\"Cart.领取成功\\\"));\\n  ```\\n\\n  > **谨慎使用:**\\n  > 本脚本在处理script块中的中文时，会将中文字符串替换为this.$t(\\\"\\\")的函数。此时需要特别注意this的指向问题，如果this并不指向vue组件实例，则执行时会抛异常。请自行检查。\\n\\n---\\n\\n### 其他场景\\n\\n一些国际化场景本脚本暂未支持，请自行处理：\\n1. 只处理vue文件中的中文配置，非vue文件将保持原样。\\n\\n2. template块中的非连续中文支持不友好，比如：\\n  ```html\\n  <!-- 转换前 -->\\n  <span>满{{ item.consumeThreshold }}元可用</span>\\n  <!-- 转换后：被拆为\\\"满\\\"和\\\"元可用\\\"两部分 -->\\n  <span>{{ $t(\\\"Cart.满\\\") }}{{ item.consumeThreshold }}{{ $t(\\\"Cart.元可用\\\") }}</span>\\n  ```\\n  这是由于脚本无法正确处理动态的拼接中文，同时无法分析语义。\\n\\n3. script块中的动态拼接中文或html文本，比如：\\n  ```javascript\\n  // html文本 转换前\\n  this.$Modal.confirm({ title: \\\"删除\\\", content: \\\"<p>确定要删除该商品吗？</p>\\\" });\\n  // html文本 转换后\\n  this.$Modal.confirm({ title: this.$t(\\\"Cart.删除\\\"), content: \\\"<p>确定要删除该商品吗？</p>\\\" });\\n\\n  // 动态文本 转换前\\n  this.$Message.success(`清空购物车${res}个`);\\n  // 动态文本 转换后\\n  this.$Message.success(`清空购物车${res}个`);\\n  ```\\n\\n4. style块中的中文暂不支持\\n\\n\",\"n\":0.079}}},{\"i\":56,\"$\":{\"0\":{\"v\":\"---\\ntitle: 渲染流程：Vue vs React\\ndescription: 对比Vue2和React15渲染流程中的原理和差异\\ndatePublished: 2023-01-04T08:05:58.604Z\\ndateModified: 2023-01-04T08:05:58.610Z\\ncover: ../static/assets/vuevsreact.jpeg\\ncoverAlt: cover\\nslug: vue-react-render\\ncategory: 经验总结\\ntags:\\n  - 前端\\n  - 架构\\n  - Vue2\\n  - React\\n---\\n\\n本文主要从渲染流程中对比Vue和React的原理和结构差异。其中Vue使用的是Vue2，React是React15。\\n\\n## 架构\\n\\n### Vue\\n\\nVue中，每个组件都有一个Vue实例。渲染、挂载、卸载、子组件管理、响应式都在这个实例内进行。所有功能以实例为载体实现。\\n\\n每个Vue实例内，通过render函数，得到VNode树并存储下来。在实例的渲染过程中，通过深度优先遍历+双端diff算法对比新旧VNode树，并patch相应的dom变更。对于子组件，要么实例化新的，要么从组件缓存中获取。子组件的渲染交给子组件自己去执行。从而实现整个组件树的渲染。\\n\\n### React\\n\\nReact中，渲染分为Reconciler（协调）和Renderer（渲染）。16.8版本之前使用的是[Stack Reconciler](https://zh-hans.legacy.reactjs.org/docs/implementation-notes.html)。包含框架从`ReactDom.render`入口开始，深度遍历渲染整个组件树。React在渲染过程中，会将每个jsx节点都对应创建一个内部实例，包含**组合组件**（CompositeComponent）和**宿主组件**（HostComponent）两种类型。组合组件与`<App />`这样的React组件节点对应。宿主组件与`<div />`这样的原生节点对应。内部实例里包含了每个节点需要的上下文信息。\\n\\n> 它的工作机制类似于函数调用栈，所以称为Stack Reconciler。包括mount、unmount、更新等，都是递归调用+深度优先。\\n\\n**宿主组件**mount时，根据当前的jsx虚拟节点（element）。创建或更新对应的原生节点（node）。然后遍历children并挨个创建内部实例，得到子内部实例列表（renderedChildren）。再调用`renderedChildren.forEach.mount()`往深层执行。mount函数执行过程中，存储element、node和renderedChildren。函数最后return node。\\n\\n**组合组件**mount时，根据当前的jsx虚拟节点（element）。如果是class组件则实例化，执行生命周期，执行render函数。如果是函数组件则无需实例化（本身即render函数）。执行render后得到组件根jsx节点，对应创建内部实例（renderedComponent）。组合组件无需遍历children，因为永远只有一个根节点。函数执行过程中存储element、renderedComponent。函数最后返回值为`return renderedComponent.mount()`，即继续执行子内部实例的mount函数，并取其返回值。这么看来，它最终返回的是离它深度最小的子宿主组件的node。执行过程中通知renderer挂载dom。\\n\\n### 数据结构对比\\n\\n现有如下的一个模版：\\n```html\\n<App>\\n    <h1>App标题</h1>\\n    <Detail />\\n</App>\\n\\n// App组件：\\n\\n<div>{children}</div>\\n\\n// Detail组件：\\n<button />\\n```\\n\\n在Vue里的存储结构为：\\n\\n![Vue实例结构](assets/vue-render-struct.jpg \\\"Vue render struct\\\")\\n\\n图中每个实线框都是一个VNode，每个Vue组件对应一个Vue实例。\\n\\n在vue中，父级实例包含子级实例：App实例包含一个div根级VNode，div下包含一个h1和一个Detail的VNode，其中Detail虚拟节点对应了Detail实例，Detail实例下又包含了一个button的VNode。\\n\\n同样的模版，在React里的存储结构为：\\n\\n![React实例结构](assets/react-render-sturct.jpg \\\"React render struct\\\")\\n\\n图中每个圆角框都是一个内部实例。组合组件总是有一个且只有一个renderedComponent，指向另一个内部实例。宿主组件的renderedChildren可能包含多个，指向其他的内部实例。此外，宿主组件会return dom节点元素。而组合组件会return第一个宿主组件的return值。\\n\\n## Diff更新\\n\\n### Vue\\n\\nVue使用深度优先，对每个实例下的VNode tree进行递归渲染，同一级的VNode trees使用双端diff算法进行最小化的差异对比，并同步操作真实dom树。\\n\\n双端diff算法，使用四个指针，通过对新旧VNode数组的头头、尾尾、头尾、尾头的俩俩对比，匹配节点。这四种对比能覆盖80%以上的列表变更的场景。如果这四种都不满足，那会直接在旧数组中查找，如果还未查找到，则说明是新增节点。四指针遍历结束后，如果新数组还有剩余，则说明旧数组中找不到，要添加dom。如果旧数组还有剩余，则说明新数组中找不到，要删除dom。\\n\\n### React\\n\\nReact在首次挂载完后，便通过内部实例之间的相互引用，得到了一个内部实例的树。渲染更新时，由根内部实例，深度递归遍历，调用实例的receive方法。receive方法接收一个可以复用的新jsx节点（element），即key和type都相同。\\n\\n在组合组件的receive方法中，如果是class组件，更新props，执行生命周期，并调用render方法；如果是函数组件，执行函数。得到子jsx虚拟节点。与旧的虚拟节点对比，如果key和type都一样，则可以复用子内部实例，调用子内部实例的receive方法，形成递归。如果不可复用，则重新创建子内部实例。并unmount旧的子内部实例，mount新的子内部实例。同时通知renderer卸载dom。\\n\\n在宿主组件的receive方法中，首先更新props为新的element的props。接着开始遍历处理props.children。对比旧的子内部实例数组（prevRenderedChildren）和新的数组（nextRenderedChildren）。数组遍历中，找到可以复用的，也是直接调用该子内部实例的receive方法，往下递归，如果存在位置移动，添加一个“MOVE”操作到操作队列（operationQueue）里。如果找不到，则需要新增，添加一个“ADD”操作到操作队列里。如果旧数组存在而新数组不存在，则需要删除，添加一个“REMOVE”操作到操作队列里。最终遍历操作队列，通知renderer更新dom。\\n\\n总结下来就是，组合组件每次渲染更新都执行render函数，并对比renderedComponent是否可以复用。宿主组件每次渲染更新，都更新props，对比props.children考虑renderedChildren中哪些可以复用。复用的则向下递归调用receive方法。不复用的则调用renderer更新dom。\\n\\n## 简单版源码\\n\\n本文的结构分析是基于我造轮子的[Vuelon](https://github.com/missmess/leon-build-wheel/tree/main/packages/vuelon)和[Reacteon](https://github.com/missmess/leon-build-wheel/tree/main/packages/reacteon)。\\n\\n有兴趣的可以同时从npm包下载，直接在[npmjs.com](https://npmjs.com)搜索包即可：Vuelon和Reacteon。\\n\",\"n\":0.143}}},{\"i\":57,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"程序员Leon\\\"\\ncover: images/wang_blog.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"本站\\\"\\ndatePublished: \\\"2022-01-30 11:22:01\\\"\\ndateModified: \\\"2022-01-30 11:22:01\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - React\\n  - Node.js\\n  - Gatsby\\n  - graphQL\\n  - PWA\\n---\\n\\n本站！\\n\\n### 优势\\n\\n- SEO优化\\n  1. 所有的可访问页面在打包后都生成了对应的html文件。做了seo优化，html里的内容就是最终的页面内容。\\n\\n- 支持PWA特性\\n  1. 首次访问通过http加载html，并注册ServiceWorker。后续访问使用sw加载。可离线访问。\\n  2. 支持pwa桌面应用安装。\\n  3. nprogress展示网页加载进度。\\n\\n- SPA体验\\n  1. 使用Link组件链接的页面，会在当前页面加载完成后，异步加载，以提升跳转时的体验。\\n\\n### 功能点\\n\\n1. 支持markdown和MDX。\\n\\n2. 图片渐进式加载。\\n\\n3. 支持分类（category）和标签（tag）。\\n\\n4. 列表页都支持分页加载。\\n\\n5. 支持模糊搜索。\\n\\n6. 全部页面都进行了SEO优化。\\n\\n7. 响应式设计，同时支持pc端和移动端浏览器\\n\\n### 技术点\\n\\n1. 使用Gatsby实现的纯静态站点。Node.js + React + styled-components。\\n\\n2. 数据层通过graphQL和remark插件读取和处理所有markdown和mdx文档。\\n\\n3. 在Node.js层控制分页json数据查询，在client端通过fetch+react query实现分页加载。\\n\\n4. 在Node.js层生成每个category、每个tag、每个blog的静态页面。\\n\\n5. 使用gatsby-plugin-image对图片渲染优化。\\n\\n6. 使用fusejs、gatsby-plugin-fusejs在Node.js层实现索引，client端通过react-use-fusejs插件进行关键字搜索。\\n\\n7. 借助[gatsby themes](https://www.gatsbyjs.com/docs/themes/using-multiple-gatsby-themes/)实现功能和UI抽离，并支持主题切换。所有功能在themes/advanced模块下，只包含基础ui。像素主题的ui在themes/pixel模块下。\",\"n\":0.131}}},{\"i\":58,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"Webpack是如何处理ESM的\\\"\\ncover: ../static/assets/webpack-package.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"介绍一段import和require的代码在webpack中如何被打包\\\"\\ndatePublished: \\\"2023-02-08 21:52:32\\\"\\ndateModified: \\\"2023-02-08 21:52:32\\\"\\ncategory: \\\"经验总结\\\"\\ntags:\\n  - 前端\\n  - 架构\\n  - 造轮子\\n---\\n\\n周所周知，ES6引入了官方的模块化方案`import`和`export`。在此之前，js想要实现模块化开发，需要依赖于非官方方案。\\n\\n#### 模块化历史\\n\\n**最早期：IIFE**\\n\\n最开始为了避免在全局作用域执行代码，开发者使用IIFE将代码封装在函数作用域内。\\n\\n```javascript\\nvar mathToolModule = (function () {\\n    var pi = 3.141592653\\n    function add (a, b) {\\n        return a + b\\n    }\\n    return {\\n        pi: pi,\\n        add: add\\n    }\\n})()\\n\\nmathToolModule.add(1, 2)\\n```\\n\\n**CommonJs**\\n\\n比较常用的模块化方案，使用`require`和`module.exports`来导入/导出模块。现今的Node.js仍然使用该模块化标准。\\n\\n```javascript\\n// toolsModule.js\\nmodule.exports = {\\n    add: function (a, b) {\\n        return a + b\\n    }\\n}\\n\\n// main.js\\nconst mathToolModule = require('./toolsModule.js');\\nmathToolModule.add(1, 2)\\n```\\n\\n缺点很明显，因为是同步加载，所以在浏览器上网络差的情况下会比较慢影响性能。而Node服务端因为都在本地所以不影响。\\n\\n**AMD（Async Module Definition）**\\n\\n`CommonJs`实现不了异步加载模块，所以出现了AMD标准。`RequireJs`是AMD的一种实现：\\n\\n```javascript\\n// 定义一个mathTools模块\\ndefine('mathTools', [], function () {\\n    var add = function (a, b) {\\n        return a + b;\\n    };\\n    return {\\n        add: add,\\n    };\\n});\\n\\n// 引入math作为依赖模块\\nrequire(['mathTools'], function (math) {\\n    math.add(1, 2)\\n})\\n```\\n\\n通过引入依赖数组，并异步加载全部的模块，等待加载完成后再运行内部代码。缺点是依赖数组前置了，所以用或者不用都会加载这些模块。没有按需加载。\\n\\n**CMD（Common Module Definition））**\\n\\n阿里巴巴提出的一种前端模块化规范。CMD规范主要用于`Sea.js`模块加载器。特点是按需加载，依赖就近（依赖可以写在代码任意地方，只有使用时才去解析依赖）。\\n\\n```javascript\\n// 定义math模块\\ndefine(function (require, exports, module) {\\n    exports.add = function (a, b) {\\n        return a + b;\\n    }\\n})\\n\\n// 使用math模块\\ndefine(function (require, exports, module) {\\n    var mathTools = require('./math.js');\\n    mathTools.add(1, 2)\\n})\\n```\\n\\n`require`和`exports`都作为`define`内函数的参数。分别代表自己要使用什么模块，以及导出哪些变量。\\n\\n**UMD（Universal Module Definition）**\\n\\nUMD规范的目的是让一个模块能同时在不同环境下运行。不论是浏览器、Node.js还是其他环境。它兼容了AMD、CommonJs以及全局变量。\\n\\n```javascript\\n// mathTools.js\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD\\n        define([], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // CommonJS\\n        module.exports = factory();\\n    } else {\\n        // 浏览器全局变量\\n        root.mathTools = factory();\\n    }\\n}(this, function () {\\n    // 主体代码\\n    return {\\n        add: function (a, b) {\\n            return a + b\\n        }\\n    }\\n}));\\n\\n// main.js\\n(function (root, factory) {\\n    if (typeof define === 'function' && define.amd) {\\n        // AMD\\n        define(['mathTools'], factory);\\n    } else if (typeof module === 'object' && module.exports) {\\n        // CommonJS\\n        module.exports = factory(require('mathTools'));\\n    } else {\\n        // 浏览器全局变量\\n        root.myModule = factory(root.mathTools);\\n    }\\n}(this, function (mathTools) {\\n    // 主体代码\\n    mathTools.add(1, 2)\\n}));\\n```\\n\\n可以看到每个模块的主体代码都在`factory函数`里。模块执行时使用IFFE：判断当前使用哪种模块规范，并把自己导出为当前的模块规范。从而让每个模块都能运行在各种模块规范下。\\n\\n**ESM（EMCAScript Module）**\\n\\nES6从语言层面实现了模块化。旨在统一标准。使用`import`导入模块，`export`导出模块。\\n\\n```javascript\\n// mathTools.js\\nexport default {\\n    add: (a, b) => a + b\\n}\\n\\n// main.js\\nimport add from 'mathTools'\\n\\nadd(1, 2)\\n```\\n\\n并且ESM慢慢成为浏览器的标配。使用`<script type=\\\"module\\\">`就可以定义一个脚本使用该模块规范。在node端也支持ESM。通过在package.json里配置`type: \\\"module\\\"`或者使用`.mjs`后缀，就可以使用ESM。\\n\\n#### ESM和CommonJs的模块加载差异\\n\\nwebpack可以通过配置[output.type](https://www.webpackjs.com/configuration/output/#outputlibrarytype)将代码打包成各种模块规范的格式，我们可以根据库的目标运行环境来更改模块类型。如果要兼容，可以选`umd`格式。\\n\\n本次主要对比一下ESM和CJS的模块加载机制的不同。\\n\\n- esm是静态加载的，即`import`语句是在编译时静态解析和优化的。而commonjs是动态加载的，`require`语句在运行代码时解析。（所以`import`语句只能写在（top-leve）顶层作用域，不可在{}块级作用域中。而`require`无限制）。\\n\\n- 浏览器中，esm是异步加载的。而commonjs是同步加载的。\\n\\n- esm模块导出的是引用，而commonjs导出的是副本。[看下面](#其他)\\n\\n**ESM在浏览器中是如何加载的**\\n\\n定义了`type=\\\"module\\\"`的js脚本中可以直接使用esm语法。\\n\\nesm脚本的加载是异步的。也就是说下面的代码是等同的：\\n\\n```html\\n<script type=\\\"module\\\" src=\\\"./index.js\\\"></script>\\n<script type=\\\"module\\\" src=\\\"./index.js\\\" defer></script>\\n```\\n\\n*BTW：`defer`属性的脚本会在html解析完成后执行并且保证defer脚本的执行顺序。而`async`脚本会在该脚本下载完成后立即执行，执行顺序不保证，执行时间也不保证。所以`async`适合与dom无关，独立运行的脚本。而`defer`适合不需要阻塞html解析的异步脚本。*\\n\\n*执行顺序：html开始解析 => 同步script按顺序执行 => html解析完成 => defer脚本按顺序执行 => DOMContentLoaded事件 => 其他资源加载（link外部样式表，img的图片资源） => 全部完成触发onload事件*\\n\\nesm是编译时静态分析的，虽然在浏览器中使用esm没有了编译阶段。但静态分析仍然存在。浏览器加载esm的步骤：\\n\\n1. 入口：从`<script type=\\\"module\\\">`标签的模块入口，开始解析和加载。\\n\\n2. 预解析模块：在执行代码之前，浏览器先预解析模块文本，确定模块依赖关系，形成模块关系图。\\n\\n3. 加载模块：并行加载和实例化模块，确定导出对象。*（在此过程，浏览器可以做一些优化，比如tree shaking掉未使用的导出）*。\\n\\n4. 执行模块代码：到这里开始，按照深度优先顺序，执行模块的代码（最深的模块最先执行）。并且每个模块的代码只会执行一次（防止循环依赖）。\\n\\n比如以下情况：\\n\\n```javascript\\n// index.js\\nconsole.log(\\\"1\\\");\\nimport \\\"./esm-a.js\\\";\\nconsole.log(\\\"2\\\");\\nimport \\\"./esm-b.js\\\";\\nconsole.log(\\\"3\\\");\\n\\n// esm-a.js\\nconsole.log(\\\"a\\\");\\nexport default {}\\n\\n// esm-b.js\\nconsole.log(\\\"b\\\");\\nexport default {}\\n```\\n\\n输出的结果为：a => b => 1 => 2 => 3\\n\\n如果在`esm-a.js`内部加上`import \\\"./esm-b.js\\\"`，那输出的结果就变为：b => a => 1 => 2 => 3\\n\\n> 详细参考：https://tech.taobao.org/news/go81zn\\n\\n同比之下，commonjs因为是同步执行的，加载机制就简单很多。还是上面的例子，改为commonjs：\\n\\n```javascript\\n// index.js\\nconsole.log(\\\"1\\\");\\nrequire(\\\"./esm-a.js\\\");\\nconsole.log(\\\"2\\\");\\nrequire(\\\"./esm-b.js\\\");\\nconsole.log(\\\"3\\\");\\n```\\n\\n输出结果为：1 => a => 2 => b => 3\\n\\n同时，esm也支持动态导入模块，使用`import()`函数，可以在任意位置调用，无需top-level。比如`import(\\\"./esm-a.js\\\")`会返回一个Promise，在Promise里可以获取到模块导出的内容。动态导入的模块只在调用`import()`函数时，才被解析、加载和执行。\\n\\n```javascript\\n// index.js\\nconsole.log(\\\"1\\\");\\nimport(\\\"./esm-a.js\\\")\\nconsole.log(\\\"2\\\");\\nimport(\\\"./esm-b.js\\\")\\nconsole.log(\\\"3\\\");\\n```\\n\\n输出结果为：1 => 2 => 3 => a => b\\n\\n**Node端处理ESM**\\n\\nNode端解析和执行ESM的逻辑和顺序，和浏览器端如出一辙。无非是Node支持通过裸模块名加载本地模块。比如`import fs from 'fs'`。它会通过不断往上查找`node_modules`目录来加载对应模块。\\n\\n#### Webpack上编译ESM和CommonJs\\n\\n前面所讲的都是浏览器或Node对ESM模块的原生支持，而我们常常会使用Webpack这样的打包工具，对前端应用进行构建打包。而Webpac目前对ESM支持还有限，它在构建ESM时，并不会保留ESM，而是转译成另一种实现。最后通过`webpack.config.js`设置`library.type`来生成最终的输出格式。\\n\\n```javascript\\n// webpack.config.js\\nmodule.exports = {\\n  entry: \\\"./index.js\\\",\\n  output: {\\n    filename: \\\"bundle.js\\\",\\n    path: path.resolve(__dirname, \\\"dist\\\"),\\n    globalObject: \\\"this\\\",\\n    library: {\\n      type: \\\"umd\\\", // 配置模块输出格式为umd\\n    },\\n  },\\n}\\n```\\n\\n我们看一下Webpack在development模式下是如何实现esm模块的。*（production模式下看不出来，因为做了代码压缩、treeshaking、模块合并等）。*拿下面的例子来看esm静态导入和动态导入模块，webpack编译后是什么样子：\\n\\n```javascript\\n// ========== index.js - 编译前\\nconsole.log(\\\"1\\\");\\n{\\n    import(\\\"./esm-a.js\\\").then(() => {\\n        console.log(\\\"esm-a loaded\\\");\\n    })\\n}\\nconsole.log(\\\"2\\\");\\nimport \\\"./esm-b.js\\\"\\nconsole.log(\\\"3\\\");\\n\\n// ========== index.js - 编译后\\n__webpack_require__.r(__webpack_exports__);\\nvar _esm_b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\\\"./esm-b.js\\\");\\nconsole.log(\\\"1\\\");\\n{\\n    __webpack_require__.e(\\\"esm-a_js\\\").then(__webpack_require__.bind(__webpack_require__, \\\"./esm-a.js\\\")).then(() => {\\n        console.log(\\\"esm-a loaded\\\");\\n    })\\n}\\nconsole.log(\\\"2\\\");\\nconsole.log(\\\"3\\\");\\n```\\n\\n可以看到静态import的模块，被提到了代码顶部，并通过`__webpack_require__()`函数加载模块。动态import()的模块还在原来的位置，通过`__webpack_require__.e`Promise化后再加载对应模块，并在模块加载后执行回调函数。\\n\\nwebpack处理CommonJs的就比较简单了。直接使用`__webpack_require__()`加载模块即可。\\n\\n```javascript\\n// ========== index.js - 编译前\\nconsole.log(\\\"1\\\");\\nrequire(\\\"./esm-b.js\\\");\\nconsole.log(\\\"2\\\");\\n\\n// ========== index.js - 编译后\\nconsole.log(\\\"1\\\");\\n__webpack_require__(\\\"./esm-b.js\\\");\\nconsole.log(\\\"2\\\");\\n```\\n\\n**__webpack_require__**\\n\\n也顺便看看webpack的`__webpack_require__()`方法做了什么。\\n\\n```javascript\\n// __webpack_modules__是一个对象。\\nvar __webpack_modules__ = ({\\n    \\\"./esm-b.js\\\": ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\\n        eval(/** code省略 */);\\n    }),\\n\\n    \\\"./index.js\\\": ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {\\n        eval(\\\"console.log(\\\\\\\"1\\\\\\\");\\\\n__webpack_require__(/*! ./esm-b.js */ \\\\\\\"./esm-b.js\\\\\\\");\\\\nconsole.log(\\\\\\\"2\\\\\\\");\\\\n\\\\n//# sourceURL=webpack://esm/./index.js?\\\");\\n    })\\n});\\n\\n// 模块缓存\\nvar __webpack_module_cache__ = {};\\n\\n// require函数实现，用来加载模块\\nfunction __webpack_require__(moduleId) {\\n  var cachedModule = __webpack_module_cache__[moduleId]\\n  if (cachedModule !== undefined) {\\n    return cachedModule.exports\\n  }\\n\\n  var module = __webpack_module_cache__[moduleId] = {exports: {}}\\n\\n  __webpack_modules__[moduleId](module, module.exports, __webpack_require__)\\n\\n  return module.exports\\n}\\n\\n// 执行导入入口文件\\n__webpack_require__(\\\"./index.js\\\");\\n```\\n\\n可以看到，`__webpack_modules__`用来存储所有的模块（不包含异步模块）。以模块路径为key，值为对应模块的工厂函数。\\n\\n`__webpack_require__`函数用来加载模块。它会首先检查缓存，如果有缓存就直接返回缓存。否则调用`__webpack_modules__`中对应模块的工厂函数。\\n\\n工厂函数内，直接`eval`执行了编译后的模块代码。模块代码的作用域限定在函数内，工厂函数提供的三个参数即模块代码的执行上下文。执行模块代码时：使用`__webpack_require__`导入其他模块。导出内容输出到`__webpack_exports__`上。\\n\\n最后执行入口文件的require。从而形成了整个闭环。\\n\\n#### 其他\\n\\n1. ESM的特性之一就是导出的是引用，假如值被某模块修改了，其他模块获取的仍是最新值。ESM官方实现应该是导出的变量是引用，都是指向同一块内存地址。Webpack在实现这个特性时，是通过`Object.definedProperty`设置get()函数。原始值始终是在原模块内，其他模块通过get()取到的始终是原模块内的值。\\n\\n    ```javascript\\n    // esm-b.js - 编译前\\n    export var a = 1\\n    export function setA() {\\n        a++\\n    }\\n\\n    // esm-b.js - 编译后并展开__webpack_require__.d\\n    Object.defineProperty(__webpack_exports__, 'a', {\\n        get: () => (a),\\n    });\\n    Object.defineProperty(__webpack_exports__, 'setA', {\\n        get: () => (setA)\\n    });\\n\\n    var a = 1\\n    function setA() {\\n        a++\\n    }\\n    ```\\n\\n2. 对于动态加载的模块，前面我们看到了是通过`__webpack_require__.e`处理的。简单说一下：\\n\\n    - 动态模块会被单独提到一个chunk中，生成对应的bundle.js。动态模块不会出现在初始的`__webpack_modules__`里。\\n\\n    - 生成的bundle.js里，会把自己执行代码和模块id都push到`chunkLoadingGlobal`里\\n\\n    - `__webpack_require__.e`会执行一系列promise。\\n    \\n    - 加载的promise函数内，会通过script标签加载bundle.js。\\n\\n    - 加载成功后会执行`webpackJsonpCallback`函数，将该模块的id和添加到`__webpack_modules__`上。\\n\\n    - promise执行下一步。调用`__webpack_require__`执行模块代码。\\n\\n    > 详细参考https://blog.csdn.net/letterTiger/article/details/136977101\",\"n\":0.045}}},{\"i\":59,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"优优小班课公众号\\\"\\ncover: banma/public_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"优优小班课-微信公众号项目\\\"\\ndatePublished: \\\"2019-10-28 13:49:02\\\"\\ndateModified: \\\"2019-10-28 13:49:02\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 前端\\n  - Vue2\\n  - Vant\\n  - 公众号\\n---\\n\\n优优小班课-微信公众号，用于学生/家长微信内直接购课，参与团购，查看购课订单，分享。\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n1. 微信直接登录。\\n\\n2. 在线购课（课时包、秒杀），支持微信支付、支付宝支付、支付宝分期、花呗支付等。\\n\\n3. 查看购物车。\\n\\n4. 查看购课订单。\\n\\n5. 参与和发起团购。\\n\\n6. 学前测评。\\n\\n7. 查看课程日历。\\n\\n8. 微信分享活动信息。\\n\\n### 我的职责\\n\\n1. 负责公众号一期功能开发。\\n\\n2. 参与公众号项目维护。\\n\\n3. 开发人员团队管理。\\n\\n### 技术实现\\n\\n1. 基于vue2、vant框架开发。\\n\\n2. 接入微信jssdk实现登录、分享等微信能力。\\n\\n3. 打包为静态资源，发布oss，配置二级域名。处理缓存问题。\\n\\n### 截图\\n\\n![](./banma/public_login.jpg)\\n![](./banma/public_goods.jpg)\\n![](./banma/public_tuangou.jpg)\",\"n\":0.156}}},{\"i\":60,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"优优小班-AI信令sdk\\\"\\ncover: banma/aisdk_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"优优小班AI课信令驱动sdk\\\"\\ndatePublished: \\\"2020-03-27 20:05:31\\\"\\ndateModified: \\\"2020-03-27 20:05:31\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - 跨平台\\n  - Flutter\\n  - dart\\n  - 库\\n  - 架构\\n---\\n\\n类直播课的AI课形式，收集到素材课（直播课）的全部信令。通过本AI信令sdk，驱动信令的执行，来演绎回放AI课。\\n\\n### 为什么需要？\\n\\n一期的AI课走的是server端回放模式，AI课堂上的信令都是从服务端通过websocket按时发送过来。对于网络条件良好的学生来说，误差不会太大，延迟不会太高。但是大部分二三线城市的学生网络状况较差，并且由于信令内容较大，导致延迟很高，课堂效果差。\\n\\n### 调研\\n\\n调研了多种实现方式：\\n\\n1. 原生开发：信令sdk实现很复杂，原生开发逻辑一致性无法保证。测试压力也很大。\\n\\n2. h5版sdk：统一逻辑，在两端的webview加载h5版sdk，通过js接口通信。问题：性能较差、通信成本高。\\n\\n3. flutter版sdk：统一逻辑，使用Flutter引擎加载，性能好，双向通信速度很快，通信方法很多。Android上可以通过曲线方式实现热更新。\\n\\n### 主要功能\\n\\n1. 解析信令文件内容，根据时间戳，设置timer按顺序按时间点发送信令到app端，控制课堂进程。\\n\\n2. 初始化时，根据一定时间间隔生成信令快照，便于后续seek时，快速恢复信令现场。\\n\\n3. seek时，考虑使用快照或者不使用快照，并合并最终信令发送到app端。\\n\\n4. 提供接口供app端调用。\\n\\n![信令sdk流程图](./banma/yyxb_aisdk.jpg)\\n\\n### 技术点\\n\\nAI信令sdk，作为一个纯dart语言开发的库，打包成动态库，集成到Android端和iOS端，app端使用FlutterEngine去加载。\\n\\napp端使用MethodChannel与flutter通信。\\n\\n课堂seek（跳时间点）时，for循环信令列表计算最终信令数组。\\n\\n使用快照技术，提升课堂seek后的计算速度，减少计算。\\n\",\"n\":0.18}}},{\"i\":61,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"优优小班\\\"\\ncover: banma/yyxb_cover.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"K12教育AI课产品\\\"\\ndatePublished: \\\"2020-03-01 21:39:10\\\"\\ndateModified: \\\"2020-03-01 21:39:10\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - Android端\\n  - Java\\n  - iOS端\\n  - 组件化\\n  - Hybrid\\n---\\n\\n优优小班课是K12教育领域类直播形式的AI课产品。\\n\\n> 市面上的AI课，都是提前录好素材，在APP端进行拼接，课程中夹杂互动的形式。<br/>优优小班课的类直播形式是使用真实[袋鼠小班](/袋鼠小班)直播课的素材，在AI课上回放该直播课，替换掉主演，让上AI课的该学生有一种身临其境在上直播课的体验，有同学伴读的感觉。教学效果大大提升。\\n\\n学生端为上课端，包含登录、课表、AI课堂、课后练习等。支持Android、iphone、ipad。\\n\\n---\\n\\n### 导航\\n\\n- [主要功能](#主要功能)\\n- [我的职责](#我的职责)\\n- [技术实现](#技术实现)\\n- [截图](#截图)\\n\\n### 主要功能\\n\\n1. 学生登录进入主界面，查看自己的课程表。\\n\\n2. 到点进入课堂上课。课堂为AI课形式，从学生进入时间点开始播放AI课程。\\n\\n3. 学生中途退出，AI课时间仍然会流逝，重进后从流逝后的时间点继续播放课堂。\\n\\n4. AI课完全还原直播课堂的体验。\\n\\n### 我的职责\\n\\n1. 主导技术项目的开发，包括Android优优小班课、[课件容器](/优优小班-课件容器)、[AI信令sdk](/优优小班-a-i信令sdk)、iOS的技术跟进等。\\n\\n2. 主导重难点技术方案的设计：\\n\\n    - 课件容器架构设计和研发。\\n    - 稳定性相关：课堂关键状态上报、日志sdk、实时监课和远程控制（查看学生视频流、刷新学生课堂白板、刷新课堂等）。\\n    - AI信令sdk架构设计和研发。\\n    - AI课堂恢复算法设计和研发。\\n    - 题库设计。包括管理后台出题、学生端渲染题目、十几种题目类型支持、题目判对判错交互。\\n    - 答题课件设计，比答题器交互更沉浸。\\n    - 等等。\\n\\n3. 多端通信协议及规范设计。\\n\\n4. 稳定性持续跟进和优化。\\n\\n5. 大前端开发团队管理。\\n\\n6. 项目管理。\\n\\n### 技术实现\\n\\n1. Android端基于Java、MessUi、Retrofit等。\\n\\n2. 与h5的通信基于AppSocket。\\n\\n3. 与Flutter sdk的通信基于MethodChannel。\\n\\n4. 学生推送音视频流，基于zego sdk。\\n\\n5. 实现了组件化开发，各个业务module可独立运行、开发、测试。\\n\\n6. **【corelib】**module包含：业务无关的基础依赖、基础UI框架、事件总线RxBus、基础请求框架、常用弹窗、常用工具类。\\n\\n7. **【rcmpt】**module包含：业务相关的基础依赖、BaseActivity/BaseFragment、页面路由定义、业务请求封装、基础控件、一些常量。\\n\\n8. **【app】**module包含：Application基类，启动页。（仅作为app壳子）。\\n\\n9. **【BmLogSdk】**module包含：日志sdk导出的aar。\\n\\n10. **【ClassRoomSdk】**module包含：白板部分和课件容器。\\n\\n11. **【eduhdsdk】**module包含：课堂页面及对应的组件。\\n\\n12. 其他业务模块：如classtable、mine等，各个模块包含自己独立的业务代码。这部分代码包含：\\n\\n    - 页面，activity/fragment/view\\n    - bean model\\n    - 接口类\\n    - 业务资源\\n\\n### 截图\\n\\n<video src=\\\"./banma/xb_class.mp4\\\" autoplay muted controls />\\n\\n![](./banma/xb_class_m.jpg)\",\"n\":0.11}}},{\"i\":62,\"$\":{\"0\":{\"v\":\"---\\ntitle: \\\"优优小班-AI标注平台\\\"\\ncover: banma/aitag.jpg\\ncoverAlt: \\\"封面\\\"\\ndescription: \\\"用于老师、学生音视频标注\\\"\\ndatePublished: \\\"2020-06-12 23:10:09\\\"\\ndateModified: \\\"2020-06-12 23:10:09\\\"\\ncategory: \\\"应用项目\\\"\\ntags:\\n  - Android端\\n  - 后端\\n  - Node.js\\n  - Express\\n  - 脚本\\n  - 前端\\n  - Vue2\\n---\\n\\nAI标注平台用于标注人员对老师和学生音频转文字标注、学生图像在框识别标注。\\n\\n标注平台及配套设施包括：\\n\\n#### AI标注平台web端\\n\\n标注平台web端，用于标注人员在线上直接标注和查看标注结果。支持老师和学生音频转文字标注，支持学生图像在框识别标注。\\n\\n交互形式为类似windows文件夹的交互，图片以文件夹形式网格展示，支持多选框选，ctrl点选操作。（方便标注人员像操作文件夹一样在线操作）\\n\\n#### AI标注Android端\\n\\n用于手机端对百度语音识别结果进行人工标注。支持查看待标注内容、修改识别结果。\\n\\n#### AI标注平台server端\\n\\nserver端基于Node.js、Express框架开发。主要为web端和Android端提供接口。\\n\\n无数据库，所有数据从oss获取，并转存oss。以目录作为资源分隔方式。\\n\\n#### 标注资源获取脚本\\n\\n该脚本旨在生成标注源数据。通过音视频云服务商提供的接口，批量获取某一天上课的所有课程、所有音视频流的webm下载地址，然后下载资源、分割、转存oss。\",\"n\":0.189}}}]}","data":[{"id":"86fa15aa-30ee-5269-9eb7-586f8d261de7","title":"AI聊天统一后台","tags":["前端","React","Antd","Vite"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHbHgQsD//EABgQAAMBAQAAAAAAAAAAAAAAAAACEgEg/9oACAEBAAEFAoUlSc4//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAwADAAAAAAAAAAAAAAAAAAExIDKR/9oACAEBAAY/AojVEXMP/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQEVHB8f/aAAgBAQABPyF2ajkx5mY//9oADAMBAAIAAwAAABAz7//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/EFf/xAAdEAACAgEFAAAAAAAAAAAAAAAAEQEhMVGBscHR/9oACAEBAAE/EETrjSZeL4XSkunGjqRnYQf/2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/e71c085dce2a1254cea162e966b167ad/041b2/cover.jpg","srcSet":"/leon-blog/static/e71c085dce2a1254cea162e966b167ad/ad028/cover.jpg 177w,\n/leon-blog/static/e71c085dce2a1254cea162e966b167ad/da597/cover.jpg 354w,\n/leon-blog/static/e71c085dce2a1254cea162e966b167ad/041b2/cover.jpg 707w,\n/leon-blog/static/e71c085dce2a1254cea162e966b167ad/3de3b/cover.jpg 1414w","sizes":"(min-width: 707px) 707px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/e71c085dce2a1254cea162e966b167ad/647d2/cover.avif 177w,\n/leon-blog/static/e71c085dce2a1254cea162e966b167ad/26062/cover.avif 354w,\n/leon-blog/static/e71c085dce2a1254cea162e966b167ad/7f9d6/cover.avif 707w,\n/leon-blog/static/e71c085dce2a1254cea162e966b167ad/da5ea/cover.avif 1414w","type":"image/avif","sizes":"(min-width: 707px) 707px, 100vw"},{"srcSet":"/leon-blog/static/e71c085dce2a1254cea162e966b167ad/55808/cover.webp 177w,\n/leon-blog/static/e71c085dce2a1254cea162e966b167ad/9b6a9/cover.webp 354w,\n/leon-blog/static/e71c085dce2a1254cea162e966b167ad/9baeb/cover.webp 707w,\n/leon-blog/static/e71c085dce2a1254cea162e966b167ad/cf4f5/cover.webp 1414w","type":"image/webp","sizes":"(min-width: 707px) 707px, 100vw"}]},"width":707,"height":368},"body":"---\ntitle: \"AI聊天统一后台\"\ncover: aibackstage/cover.jpg\ncoverAlt: \"后台概览\"\ndescription: \"AI聊天后台为AI应用提供后台管理功能\"\ndatePublished: \"2023-06-16 19:22:38\"\ndateModified: \"2023-06-16 19:22:38\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - Antd\n  - Vite\n---\n\n**AI聊天统一后台**为FastMind和AI女友项目，提供了统一的管理后台。\n\n访问地址：http://ai.siyisea.com:8860\n\n查看：[FastMind](/fast-mind)\n\n查看：[GF's Heart](/g-fs-heart)\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n1. **AI角色管理**\n\n    在后台管理FastMind助手或者AI女友角色。\n\n1. **会话管理**\n\n    管理所有开启过的会话，也可查询对应会话的聊天消息。\n\n1. **用户管理**\n\n    管理用户增删改查。\n\n1. **系统管理**\n\n    GPT token管理、收入管理等。\n\n### 我的职责\n\n1. 页面及功能开发。\n\n1. AI女友角色创建时，需要拼接对应的prompt。\n\n### 技术实现\n\n1. 基于React、Ant-Deign开发。从vite-reactts脚手架启动。\n\n  查看：[vite-reactts脚手架](/vite-reactts-starter)\n\n1. 富文本使用react-quill。\n\n### 截图\n\n![创建FastMind助手](./aibackstage/fastmind-create.jpg)\n![创建FastMind助手](./aibackstage/fastmind-create2.jpg)\n![创建AI女友](./aibackstage/aigf-edit.jpg)","slug":"/ai聊天统一后台"},{"id":"ae839b0d-82c6-5cdd-b261-7fb6c5fdc576","title":"GF's Heart","tags":["前端","React","大模型","AI"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEDAgX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB62HBajI//8QAHRAAAQIHAAAAAAAAAAAAAAAAAQACAwQSIiMyM//aAAgBAQABBQIkVvORtqd1mFC1/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGBAAAwEBAAAAAAAAAAAAAAAAAAIQEWH/2gAIAQEABj8CwzkQWf/EAB0QAAEDBQEAAAAAAAAAAAAAAAABESExQVGBsZH/2gAIAQEAAT8h8BYZiyIFSsudnCtV8ktz/9oADAMBAAIAAwAAABATP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAbEAEBAAMBAQEAAAAAAAAAAAABEQAhMUFxof/aAAgBAQABPxARffG5H2/mQSGHxyuEh1abe4KDsWz5pmgdUEdm9Zortruf/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/483b8/cover.jpg","srcSet":"/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/9fa5a/cover.jpg 184w,\n/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/63e75/cover.jpg 368w,\n/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/483b8/cover.jpg 735w,\n/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/99734/cover.jpg 1470w","sizes":"(min-width: 735px) 735px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/9d028/cover.avif 184w,\n/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/c6ee4/cover.avif 368w,\n/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/6f2e7/cover.avif 735w,\n/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/201fd/cover.avif 1470w","type":"image/avif","sizes":"(min-width: 735px) 735px, 100vw"},{"srcSet":"/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/ef27d/cover.webp 184w,\n/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/4ae45/cover.webp 368w,\n/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/51181/cover.webp 735w,\n/leon-blog/static/6aff3f68362d86a7d411e1bffe675dfe/1c5dc/cover.webp 1470w","type":"image/webp","sizes":"(min-width: 735px) 735px, 100vw"}]},"width":735,"height":368},"body":"---\ntitle: \"GF's Heart\"\ncover: aigf/cover.jpg\ncoverAlt: \"GF's Heart应用\"\ndescription: \"这是你的AI女友，陪她聊天吧\"\ndatePublished: \"2023-05-11 12:34:01\"\ndateModified: \"2023-05-11 12:34:01\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - 大模型\n  - AI\n---\n\n**GF's Heart**是你身边最真实的AI女友。\n\n访问地址：http://47.251.51.76:3838\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n1. **AI大模型**\n\n    文字聊天使用gpt提供语言服务，构建prompt让女友按照设定去聊天。\n\n2. **保留记忆**\n\n    使用langchain构建有记忆的AI。\n\n3. **计划性**\n\n    利用定时任务和llm，生成后续明日或下一周的计划。\n\n4. **发送自己的照片**\n\n    利用prompt工程，在需要发送照片的时候，发送自己的照片。照片预先生成。\n\n### 我的职责\n\n1. 产品UI设计\n\n2. 多个女友的prompt调整优化\n\n3. 前端页面开发\n\n4. flowise插件开发\n\n### 技术实现\n\n1. 使用CRA创建和开发项目\n\n2. i18n提供多语言支持\n\n3. 参照[斯坦福某研究论文](https://arxiv.org/pdf/2304.03442v1.pdf)实现记忆和计划\n\n4. 使用flowise来图形化构建langchain，并实时测试聊天效果\n\n### 截图\n\n![首页](./aigf/home.jpg)\n![登录](./aigf/login.jpg)\n![注册](./aigf/register.jpg)\n![聊天](./aigf/chat.jpg)\n![flowise后台](./aigf/flowise.jpg)","slug":"/g-fs-heart"},{"id":"80949f69-c79d-5297-8752-eb6c815a511c","title":"AutoRollPager","tags":["Android端","Java","UI组件","开源"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAQFA//EABUBAQEAAAAAAAAAAAAAAAAAAAIB/9oADAMBAAIQAxAAAAHCgkIvk8U//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAIDEgERE//aAAgBAQABBQJJ0Flj10QqpVSuD//EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAEDAQE/AYf/xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGn/8QAGBABAAMBAAAAAAAAAAAAAAAAAAEyQjH/2gAIAQEABj8CywyrCsOQ/8QAGxAAAgIDAQAAAAAAAAAAAAAAAAEh8RFRcaH/2gAIAQEAAT8hWhpe5G0n0PaagqCkP//aAAwDAQACAAMAAAAQH9//xAAYEQEAAwEAAAAAAAAAAAAAAAABAEGRgf/aAAgBAwEBPxBFBk4ZP//EABkRAQACAwAAAAAAAAAAAAAAAAEAkREhYf/aAAgBAgEBPxAbpW5jrc//xAAdEAEAAgEFAQAAAAAAAAAAAAABACFRETFxkcHx/9oACAEBAAE/ENqHgfIyXJejCWu1nzcQaHgyxzYT/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/63e75/arp_cover.jpg","srcSet":"/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/32b5d/arp_cover.jpg 92w,\n/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/9fa5a/arp_cover.jpg 184w,\n/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/63e75/arp_cover.jpg 368w","sizes":"(min-width: 368px) 368px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/04b4e/arp_cover.avif 92w,\n/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/9d028/arp_cover.avif 184w,\n/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/c6ee4/arp_cover.avif 368w","type":"image/avif","sizes":"(min-width: 368px) 368px, 100vw"},{"srcSet":"/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/d35bd/arp_cover.webp 92w,\n/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/ef27d/arp_cover.webp 184w,\n/leon-blog/static/8e0f7c26f4306015d556651f66cb86b9/4ae45/arp_cover.webp 368w","type":"image/webp","sizes":"(min-width: 368px) 368px, 100vw"}]},"width":368,"height":184},"body":"---\ntitle: \"AutoRollPager\"\ncover: images/arp_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"轮播图控件，支持自定义view、支持无限循环\"\ndatePublished: \"2015-12-21 20:08:09\"\ndateModified: \"2015-12-21 20:08:09\"\ncategory: \"框架工具\"\ntags:\n  - Android端\n  - Java\n  - UI组件\n  - 开源\n---\n\n轮播图控件，支持自定义view、支持无限循环。\n\ngithub仓库：https://github.com/missmess/autorollpager\n\n---\n\nAutoRollViewPager控件可以展示一组轮播图或一组自定义view，可以自动横向滚动，带指示点和标题，支持无限循环模式。\n\nAn AutoRollViewPager can be used to display a sort of images or your custom views which can auto roll horizontally. Loop Mode supported.\n  \n---\n\n### 主要功能介绍\n\n* 可以实现view自动轮播，带指示点。\n* 支持轮播图：可以使用网络图片、本地图片资源、Drawable对象，可以混用。\n* 支持轮播自定义的view。 \n* 支持显示轮播view的文字描述。\n* 支持开关自动轮播。\n* 支持普通模式和无限循环模式。\n* 支持轮播view的点击事件\n* 支持选择自动轮播方向。\n* 可以自定义轮播时间间隔。\n* 触摸时停止自动滚动，离开后继续滚动。\n* 不影响竖向滑动。如ScrollView、ListView。\n\n---\n\n### 如何添加到项目中\n\nAndroid Studio用户，可以很轻松地通过maven仓库引用到本library。只需要在项目的build.gradle中添加该depandencies：\n  \n  `\n    compile 'com.missmess.autorollpager:library:1.0.4'\n  `\n\n---\n\n### 如何使用\n  \n###### 1、在xml布局中定义，或者代码中 new AutoRollViewPager(context)。\n  ```xml\n  <com.missmess.autorollpager.AutoRollImagePager\n            android:id=\"@+id/arp\"\n            android:layout_width=\"wrap_content\"\n            android:layout_height=\"220dp\"/>\n  ```\n  \n###### 2、代码中提供适配器，并显示：\n  \n  ```java\n  AutoRollViewPager arp = (AutoRollViewPager) findViewById(R.id.arp);\n  arp.setRollAdapter(new MyRollAdapter());\n  arp.showUp();\n  ```\n  \n###### 3、在activity的onDestory()或fragment的onDestoryView()中关闭AutoRollViewPager。\n  ```java\n  @Override\n    protected void onDestroy() {\n        super.onDestroy();\n        arp.tearDown();\n }\n  ```\n---\n\n### 示例代码\n###### 1、使用AutoRollImagePager显示轮播图\n\nAutoRollImagePager为AutoRollViewPager专用于轮播图片的一个实现。支持网络图片、本地资源、自定义drawable，以及三者混用的显示。\n\n```java\n        List<Object> images = new ArrayList<>();\n        titles = new ArrayList<>();\n\n        images.add(R.mipmap.pic1);\n        images.add(R.mipmap.pic2);\n        images.add(\"http://img3.imgtn.bdimg.com/it/u=509912007,3678988032&fm=21&gp=0.jpg\");\n        images.add(createADrawable());\n\n        titles.add(\"本地图片1\");\n        titles.add(\"本地图片2\");\n        titles.add(\"网络图片\");\n        titles.add(\"Drawable图片\");\n\n        //设置图片源\n        arp.setImageLists(images);\n        //设置描述标题\n        arp.setTitles(titles);\n        //自动滚动（默认true）\n        arp.setAutoRoll(true);\n        //设置指示点间隔（默认5dp）\n        arp.setDotInterval(8);\n        //是否无限循环模式（默认false）\n        arp.setLoopMode(true);\n        //设置自动滚动间隔（默认3秒）\n        arp.setRollInterval(3000);\n        //设置轮播view点击事件\n        arp.setOnPageClickListener(new ClickPager());\n        //设置自动滚动方向\n        arp.setRollDirection(AutoRollViewPager.DIRECTION_RIGHT);\n        //完成配置并显示\n        arp.showUp();\n\n```\n\n###### 2、使用AutoRollViewPager\n\n使用AutoRollViewPager可参考上文中的 `如何使用` 。提供的adapter需要继承于BaseRollAdapter。\n```java\n    class MyRollAdapter extends BaseRollAdapter {\n\n        public MyRollAdapter(Context context) {\n            super(context);\n        }\n\n        @Override\n        public View getView(ViewGroup container, int position) {\n            View content = null;\n            switch (position) {\n                case 0:\n                    content = View.inflate(context, R.layout.item_roll_view_1, null);\n                    break;\n                case 1:\n                    content = View.inflate(context, R.layout.item_roll_view_2, null);\n                    break;\n                case 2:\n                    content = View.inflate(context, R.layout.item_roll_view_3, null);\n                    break;\n                case 3:\n                    content = View.inflate(context, R.layout.item_roll_view_4, null);\n                    break;\n            }\n\n            return content;\n        }\n\n        @Override\n        public int getRealCount() {\n            return 4;\n        }\n    }\n```\n\n---\n\n### 截图\n\n![image](https://raw.githubusercontent.com/missmess/autorollpager/master/raw/picc1.jpg)\n![image](https://raw.githubusercontent.com/missmess/autorollpager/master/raw/picc2.png)\n![image](https://raw.githubusercontent.com/missmess/autorollpager/master/raw/picc3.jpg)\n![image](https://raw.githubusercontent.com/missmess/autorollpager/master/raw/picc4.jpg)\n","slug":"/auto-roll-pager"},{"id":"a5982a97-934a-57fb-85e5-1f0b74457c8d","title":"Big Test","tags":["测试"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABxsjWGkQn/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAIBETES/9oACAEBAAEFAmay4rtRdJ3/xAAWEQEBAQAAAAAAAAAAAAAAAAAAEgH/2gAIAQMBAT8BhOP/xAAWEQEBAQAAAAAAAAAAAAAAAAAAEgH/2gAIAQIBAT8Btev/xAAYEAADAQEAAAAAAAAAAAAAAAAAATIQEf/aAAgBAQAGPwLiZSKHv//EABoQAAIDAQEAAAAAAAAAAAAAAAAxARFhIZH/2gAIAQEAAT8hiQ6Qx6mI6sKi0MP/2gAMAwEAAgADAAAAEO8//8QAFREBAQAAAAAAAAAAAAAAAAAAERD/2gAIAQMBAT8QBD//xAAVEQEBAAAAAAAAAAAAAAAAAAAREP/aAAgBAgEBPxBLD//EABwQAQACAwADAAAAAAAAAAAAAAEAESExUUFhgf/aAAgBAQABPxCovLFGn1cGHEMvlEXDfGEUL3uaNK5Uwo7P/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/8275e/default_img.jpg","srcSet":"/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/fd641/default_img.jpg 183w,\n/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/2a971/default_img.jpg 367w,\n/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/8275e/default_img.jpg 733w,\n/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/86c10/default_img.jpg 1466w","sizes":"(min-width: 733px) 733px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/bd419/default_img.avif 183w,\n/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/fcbd2/default_img.avif 367w,\n/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/f8378/default_img.avif 733w,\n/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/087fe/default_img.avif 1466w","type":"image/avif","sizes":"(min-width: 733px) 733px, 100vw"},{"srcSet":"/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/1be9d/default_img.webp 183w,\n/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/6963a/default_img.webp 367w,\n/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/0eb16/default_img.webp 733w,\n/leon-blog/static/13ad655831d63fec4b7b307c6e5d2326/91707/default_img.webp 1466w","type":"image/webp","sizes":"(min-width: 733px) 733px, 100vw"}]},"width":733,"height":368},"body":"---\ntitle: \"Big Test\"\ncover: images/default_img.jpg\ncoverAlt: \"An image tagged as nature and water for the big test.\"\ndescription: \"A big test intended for checking the MDX rendering.\"\ndatePublished: \"2000-01-01 00:00:00\"\ndateModified: \"2000-01-01 00:00:00\"\nslug: \"Big_Sample_Test\"\ncategory: \"经验总结\"\ntags:\n  - 测试\n---\n<!-- markdownlint-disable-->\nNOTE: This \"post\" is based on [Markdown Cheatsheet](https://github.com/adam-p/markdown-here/wiki/Markdown-Cheatsheet) and is meant to test styling of Markdown generated documents.\n\nThis is intended as a quick reference and showcase. For more complete info, see [John Gruber's original spec](http://daringfireball.net/projects/markdown/) and the [Github-flavored Markdown info page](http://github.github.com/github-flavored-markdown/).\n\nThis cheatsheet is specifically _Markdown Here's_ version of Github-flavored Markdown. This differs slightly in styling and syntax from what Github uses, so what you see below might vary a little from what you get in a _Markdown Here_ email, but it should be pretty close.\n\nYou can play around with Markdown on our [live demo page](http://www.markdown-here.com/livedemo.html).\n\n(If you're not a Markdown Here user, check out the [Markdown Cheatsheet](./Markdown-Cheatsheet) that is not specific to MDH. But, really, you should also use Markdown Here, because it's awesome. http://markdown-here.com)\n\n## Table of Contents\n\n- [Headers](#headers)\n\n- [Emphasis](#emphasis)\n\n- [Lists](#lists)\n\n- [Links](#links)\n\n- [Images](#images)\n\n- [Code and Syntax Highlighting](#code-and-syntax-highlighting)\n\n- [Tables](#tables)\n\n- [Blockquotes](#blockquotes)\n\n- [Inline HTML](#inline-html)\n\n- [Horizontal Rule](#horizontal-rule)\n\n- [Line Breaks](#line-breaks)\n\n- [YouTube Videos](#you-tube-videos)\n\n## Headers\n\n```no-highlight\n# H1\n## H2\n### H3\n#### H4\n##### H5\n###### H6\n\nAlternatively, for H1 and H2, an underline-ish style:\n\nAlt-H1\n======\n\nAlt-H2\n------\n```\n\n# H1\n\n## H2\n\n### H3\n\n#### H4\n\n##### H5\n\n###### H6\n\nAlternatively, for H1 and H2, an underline-ish style:\n\n# Alt-H1\n\n## Alt-H2\n\n## Emphasis\n\n```no-highlight\nEmphasis, aka italics, with *asterisks* or _underscores_.\n\nStrong emphasis, aka bold, with **asterisks** or __underscores__.\n\nCombined emphasis with **asterisks and _underscores_**.\n\nStrikethrough uses two tildes. ~~Scratch this.~~\n```\n\nEmphasis, aka italics, with _asterisks_ or _underscores_.\n\nStrong emphasis, aka bold, with **asterisks** or **underscores**.\n\nCombined emphasis with **asterisks and _underscores_**.\n\nStrikethrough uses two tildes. ~~Scratch this.~~\n\n## Lists\n\n```no-highlight\n1. First ordered list item\n2. Another item\n  * Unordered sub-list.\n1. Actual numbers don't matter, just that it's a number\n  1. Ordered sub-list\n4. And another item.\n\n   Some text that should be aligned with the above item.\n\n* Unordered list can use asterisks\n- Or minuses\n+ Or pluses\n```\n\n1. First ordered list item\n2. Another item\n\n   - Unordered sub-list.\n\n3. Actual numbers don't matter, just that it's a number\n\n   1. Ordered sub-list\n\n4. And another item.\n\n   Some text that should be aligned with the above item.\n\n- Unordered list can use asterisks\n\n* Or minuses\n\n- Or pluses\n\n## Links\n\nThere are two ways to create links.\n\n```no-highlight\n[I'm an hash link](#links)\n\n[I'm an internal link](/)\n\n[I'm an inline-style link](https://www.google.com)\n\n[I'm a reference-style link][Arbitrary case-insensitive reference text]\n\n[You can use numbers for reference-style link definitions][1]\n\nOr leave it empty and use the [link text itself]\n\nURLs and URLs in angle brackets will automatically get turned into links.\nhttp://www.example.com or <http://www.example.com> and sometimes\nexample.com (but not on Github, for example).\n\nSome text to show that the reference links can follow later.\n\n[arbitrary case-insensitive reference text]: https://www.mozilla.org\n[1]: http://slashdot.org\n[link text itself]: http://www.reddit.com\n```\n\n[I'm an hash link](#links)\n\n[I'm an internal link](/)\n\n[I'm an inline-style link](https://www.baidu.com)\n\n[I'm a reference-style link][arbitrary case-insensitive reference text]\n\n[You can use numbers for reference-style link definitions][1]\n\nOr leave it empty and use the [link text itself]\n\nURLs and URLs in angle brackets will automatically get turned into links.\nhttp://www.example.com or <http://www.example.com> and sometimes\nexample.com (but not on Github, for example).\n\nSome text to show that the reference links can follow later.\n\n[arbitrary case-insensitive reference text]: https://www.mozilla.org\n[1]: http://slashdot.org\n[link text itself]: http://www.reddit.com\n\n## Images\n\n```no-highlight\nHere's our logo (hover to see the title text):\n\nInline-style:\n![alt text](https://foruda.gitee.com/avatar/1718886307882607881/1208717_missmess_1718886307.png \"Logo Title Text 1\")\n\nReference-style:\n![alt text][logo]\n\n[logo]: https://foruda.gitee.com/avatar/1718886307882607881/1208717_missmess_1718886307.png \"Logo Title Text 2\"\n```\n\nHere's our logo (hover to see the title text):\n\nInline-style:\n![alt text](https://foruda.gitee.com/avatar/1718886307882607881/1208717_missmess_1718886307.png \"Logo Title Text 1\")\n\nReference-style:\n![alt text][logo]\n\n[logo]: https://foruda.gitee.com/avatar/1718886307882607881/1208717_missmess_1718886307.png \"Logo Title Text 2\"\n\nLocal picture:\n\n![local picture](./images/local_test.jpeg)\n\nBig picture:\n\n![big picture that applies to water or nature](https://pic.rmb.bdstatic.com/bjh/events/8444faff1b3925f854eae33f904e1e2d1222.png@h_1280)\n\n## Code and Syntax Highlighting\n\nCode blocks are part of the Markdown spec, but syntax highlighting isn't. However, many renderers -- like Github's and _Markdown Here_ -- support syntax highlighting. _Markdown Here_ supports highlighting for dozens of languages (and not-really-languages, like diffs and HTTP headers); to see the complete list, and how to write the language names, see the [highlight.js demo page](http://softwaremaniacs.org/media/soft/highlight/test.html).\n\n```no-highlight\nInline `code` has `back-ticks around` it.\n```\n\nInline `code` has `back-ticks around` it.\n\nBlocks of code are either fenced by lines with three back-ticks <code>```</code>, or are indented with four spaces. I recommend only using the fenced code blocks -- they're easier and only they support syntax highlighting.\n\n```javascript\nvar s = \"JavaScript syntax highlighting\";\nalert(s);\n```\n\n```python\ns = \"Python syntax highlighting\"\nprint s\n```\n\n```no-highlight\nNo language indicated, so no syntax highlighting in Markdown Here (varies on Github).\nBut let's throw in a <b>tag</b>.\n```\n\nAgain, to see what languages are available for highlighting, and how to write those language names, see the [highlight.js demo page](http://softwaremaniacs.org/media/soft/highlight/test.html).\n\n## Tables\n\nTables aren't part of the core Markdown spec, but they are part of GFM and _Markdown Here_ supports them. They are an easy way of adding tables to your email -- a task that would otherwise require copy-pasting from another application.\n\n```no-highlight\nColons can be used to align columns.\n\n| Tables        |      Are      |  Cool |\n| ------------- | :-----------: | ----: |\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      |   centered    |   $12 |\n| zebra stripes |   are neat    |    $1 |\n\nThe outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown.\n\n| | Markdown | Less           | Pretty     |     |\n| | ------------- | --------------- | ---------- |------- |\n| | *Still*   | `renders` | **nicely** | |\n| | 1               | 2                 | 3          |          |\n```\n\nColons can be used to align columns.\n\n| Tables        |      Are      |  Cool |\n| ------------- | :-----------: | ----: |\n| col 3 is      | right-aligned | $1600 |\n| col 2 is      |   centered    |   $12 |\n| zebra stripes |   are neat    |    $1 |\n\nThe outer pipes (|) are optional, and you don't need to make the raw Markdown line up prettily. You can also use inline Markdown.\n\n| Markdown | Less      | Pretty     | Pretty     | Pretty     |\n| -------- | --------- | ---------- | ---------- | ---------- |\n| _Still_  | `renders` | **nicely** | **nicely** | **nicely** |\n| 1        | 2         | 3          | 3          | 3          |\n\n## Blockquotes\n\n```no-highlight\n> Blockquotes are very handy in email to emulate reply text.\n> This line is part of the same quote.\n\nQuote break.\n\n> This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can *put* **Markdown** into a blockquote.\n```\n\n> Blockquotes are very handy in email to emulate reply text.\n> This line is part of the same quote.\n\nQuote break.\n\n> This is a very long line that will still be quoted properly when it wraps. Oh boy let's keep writing to make sure this is long enough to actually wrap for everyone. Oh, you can _put_ **Markdown** into a blockquote.\n\n## Inline HTML\n\nYou can also use raw HTML in your Markdown, and it'll mostly work pretty well.\n\n```no-highlight\n<dl>\n  <dt>Definition list</dt>\n  <dd>Is something people use sometimes.</dd>\n\n  <dt>Markdown in HTML</dt>\n  <dd>Does *not* work **very** well. Use HTML <em>tags</em>.</dd>\n</dl>\n```\n\n<dl>\n  <dt>Definition list</dt>\n  <dd>Is something people use sometimes.</dd>\n\n  <dt>Markdown in HTML</dt>\n  <dd>Does *not* work **very** well. Use HTML <em>tags</em>.</dd>\n</dl>\n\n## Horizontal Rule\n\n```no-highlight\nThree or more...\n\n---\n\nHyphens\n\n***\n\nAsterisks\n\n___\n\nUnderscores\n```\n\nThree or more...\n\n---\n\nHyphens\n\n---\n\nAsterisks\n\n---\n\nUnderscores\n\n## Line Breaks\n\nMy basic recommendation for learning how line breaks work is to experiment and discover -- hit &lt;Enter&gt; once (i.e., insert one newline), then hit it twice (i.e., insert two newlines), see what happens. You'll soon learn to get what you want. \"Markdown Toggle\" is your friend.\n\nHere are some things to try out:\n\n```no-highlight\nHere's a line for us to start with.\n\nThis line is separated from the one above by two newlines, so it will be a *separate paragraph*.\n\nThis line is also a separate paragraph, but...\nThis line is only separated by a single newline, so it's a separate line in the *same paragraph*.\n```\n\nHere's a line for us to start with.\n\nThis line is separated from the one above by two newlines, so it will be a _separate paragraph_.\n\nThis line is also begins a separate paragraph, but...\nThis line is only separated by a single newline, so it's a separate line in the _same paragraph_.\n\n(Technical note: _Markdown Here_ uses GFM line breaks, so there's no need to use MD's two-space line breaks.)\n\n## YouTube Videos\n\nThey can't be added directly but you can add an image with a link to the video like this:\n\n```no-highlight\n<a href=\"http://www.youtube.com/watch?feature=player_embedded&v=8AkLfYOgIrE\n\" target=\"_blank\"><img src=\"http://img.youtube.com/vi/8AkLfYOgIrE/0.jpg\"\nalt=\"IMAGE ALT TEXT HERE\" width=\"240\" height=\"180\" border=\"10\" /></a>\n```\n\nOr, in pure Markdown, but losing the image sizing and border:\n\n```no-highlight\n[![IMAGE ALT TEXT HERE](http://img.youtube.com/vi/YOUTUBE_VIDEO_ID_HERE/0.jpg)](http://www.youtube.com/watch?v=YOUTUBE_VIDEO_ID_HERE)\n```\n\n`video: [VoiceBot Demo](https://www.youtube.com/watch?v=vRwp--RoJdo)`\n","slug":"/big-sample-test"},{"id":"6e79ad39-abcf-5de1-9026-9f949724c09e","title":"CSS即时通（App+后台）","tags":["Android端","Java","前端","Vue2","Vant","Hybrid"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIEBf/EABUBAQEAAAAAAAAAAAAAAAAAAAIB/9oADAMBAAIQAxAAAAGI25mGGFP/xAAaEAACAwEBAAAAAAAAAAAAAAAAAQIDEhMh/9oACAEBAAEFAubM+VUQxAuSGf/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAIDAQAAAAAAAAAAAAAAAAEQABIxcf/aAAgBAQAGPwLChbWOT//EABoQAAIDAQEAAAAAAAAAAAAAAAARASExUbH/2gAIAQEAAT8hpdXUTCqvpAVcr0lSGMjDwH//2gAMAwEAAgADAAAAEJzP/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8QV//EABcRAAMBAAAAAAAAAAAAAAAAAAABEVH/2gAIAQIBAT8QRHp//8QAGxABAAMBAQEBAAAAAAAAAAAAAQARITHwQZH/2gAIAQEAAT8QEJsNaV+ypt2r8V64riHpFDEtZp6X3IDGWM5Fnhk//9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/b87a048b248279d79fc4611a699e5d89/923d1/cover.jpg","srcSet":"/leon-blog/static/b87a048b248279d79fc4611a699e5d89/f6d4d/cover.jpg 187w,\n/leon-blog/static/b87a048b248279d79fc4611a699e5d89/afab3/cover.jpg 375w,\n/leon-blog/static/b87a048b248279d79fc4611a699e5d89/923d1/cover.jpg 749w","sizes":"(min-width: 749px) 749px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/b87a048b248279d79fc4611a699e5d89/776cd/cover.avif 187w,\n/leon-blog/static/b87a048b248279d79fc4611a699e5d89/4e433/cover.avif 375w,\n/leon-blog/static/b87a048b248279d79fc4611a699e5d89/8cb79/cover.avif 749w","type":"image/avif","sizes":"(min-width: 749px) 749px, 100vw"},{"srcSet":"/leon-blog/static/b87a048b248279d79fc4611a699e5d89/e009f/cover.webp 187w,\n/leon-blog/static/b87a048b248279d79fc4611a699e5d89/9a123/cover.webp 375w,\n/leon-blog/static/b87a048b248279d79fc4611a699e5d89/b31e0/cover.webp 749w","type":"image/webp","sizes":"(min-width: 749px) 749px, 100vw"}]},"width":749,"height":367.99999999999994},"body":"---\ntitle: \"CSS即时通（App+后台）\"\ncover: css-oa/cover.jpg\ncoverAlt: \"封面\"\ndescription: \"CSS即时通为集团内部通讯和办公app\"\ndatePublished: \"2023-10-27 13:44:33\"\ndateModified: \"2023-10-27 13:44:33\"\ncategory: \"应用项目\"\ntags:\n  - Android端\n  - Java\n  - 前端\n  - Vue2\n  - Vant\n  - Hybrid\n---\n\nCSS即时通为集团内部通讯和办公app。\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [员工端App截图](#员工端-app截图)\n- [管理端App截图](#管理端-app截图)\n- [管理后台截图](#管理后台截图)\n\n### 主要功能\n\n1. 实时告警传达到对应组成员，app弹出系统级通知弹窗。\n\n2. 查看组织架构通讯录。\n\n3. 发起OA流程，自定义流程，领导审批。\n\n4. 【后台】管理员工、组织架构、分组\n\n5. 【后台】管理通讯录、流程\n\n6. 【后台】管理告警模版、告警和收取记录\n\n### 我的职责\n\n1. 负责App和管理端UI、风格设计\n\n2. 负责原生Android App开发\n\n3. 负责管理端web项目开发\n\n### 技术实现\n\n1. 员工APP支持Android，使用Java开发。\n\n2. 工作台设计为应用容器，动态可配置。支持原生页面，也支持webview嵌入H5页面。\n\n3. 告警部分，使用独立service拉取告警。重难点为任意界面的系统级弹窗，以及service保活。\n\n4. 管理端为纯H5套壳APP。使用javascriptInterface通信。\n\n### 员工端App截图\n\n![](./css-oa/login.jpg)\n![](./css-oa/workbench.jpg)\n![](./css-oa/mine.jpg)\n![](./css-oa/alarm.jpg)\n![](./css-oa/oa.jpg)\n![](./css-oa/export.jpg)\n\n### 管理端App截图\n\n![](./css-oa/workbench2.jpg)\n![](./css-oa/template.jpg)\n\n### 管理后台截图\n\n![](./css-oa/login3.jpg)\n![](./css-oa/workflow.jpg)","slug":"/css即时通（-app-后台）"},{"id":"f36d457b-da8e-5617-8f83-1ad7d6609c08","title":"CalendarView","tags":["Android端","Java","UI组件","开源"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHvRTQQT//EABUQAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEBAAEFAql//8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQMBAT8Bh//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABUQAQEAAAAAAAAAAAAAAAAAABCB/9oACAEBAAY/AmP/xAAYEAEBAAMAAAAAAAAAAAAAAAABEAARMf/aAAgBAQABPyHADhCV2Ff/2gAMAwEAAgADAAAAEEgP/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAEDAQE/EHAM/8QAFhEBAQEAAAAAAAAAAAAAAAAAARAR/9oACAECAQE/EB2f/8QAGxAAAwACAwAAAAAAAAAAAAAAAAERMVEQIUH/2gAIAQEAAT8QqSyNXBXSGWpYdry8RaP/2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/e10e6875905d8f21cb839d60584b8948/0cea4/calendarview.jpg","srcSet":"/leon-blog/static/e10e6875905d8f21cb839d60584b8948/0e5ea/calendarview.jpg 126w,\n/leon-blog/static/e10e6875905d8f21cb839d60584b8948/b2d74/calendarview.jpg 252w,\n/leon-blog/static/e10e6875905d8f21cb839d60584b8948/0cea4/calendarview.jpg 504w","sizes":"(min-width: 504px) 504px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/e10e6875905d8f21cb839d60584b8948/d428b/calendarview.avif 126w,\n/leon-blog/static/e10e6875905d8f21cb839d60584b8948/f84da/calendarview.avif 252w,\n/leon-blog/static/e10e6875905d8f21cb839d60584b8948/e911a/calendarview.avif 504w","type":"image/avif","sizes":"(min-width: 504px) 504px, 100vw"},{"srcSet":"/leon-blog/static/e10e6875905d8f21cb839d60584b8948/4262b/calendarview.webp 126w,\n/leon-blog/static/e10e6875905d8f21cb839d60584b8948/fee56/calendarview.webp 252w,\n/leon-blog/static/e10e6875905d8f21cb839d60584b8948/39afb/calendarview.webp 504w","type":"image/webp","sizes":"(min-width: 504px) 504px, 100vw"}]},"width":504,"height":252},"body":"---\ntitle: \"CalendarView\"\ncover: images/calendarview.jpg\ncoverAlt: \"封面\"\ndescription: \"CalendarView是一个用于Android的可任意定制的日历组件\"\ndatePublished: \"2016-05-12 19:19:40\"\ndateModified: \"2016-05-12 19:19:40\"\ncategory: \"框架工具\"\ntags:\n  - Android端\n  - Java\n  - UI组件\n  - 开源\n---\n\ngithub仓库：https://github.com/missmess/CalendarView\n\n一个Android日历控件库，包含年历，月历，滚动月历，以及一个实现了年历、月历过渡的控件。它们既可以单独使用，也可以组合使用。\n主要特点是包含丰富的自定义属性；年历月历可以为某一天添加各种样式的decorator。支持android api 11以上。\n\nThanks for [ScrollerCalendar](https://github.com/guanchao/ScrollerCalendar), a material style calendar widget library, contains some widget, you\ncan be use them alone, also you can use them in combination. For Android api level 11+.\n\n---\n  GIF预览：\n\n  ![gif](https://raw.githubusercontent.com/missmess/CalendarView/master/raw/cd.gif)\n\n---\n\n  * [主要功能简介](#主要功能简介)\n  * [添加到项目中](#添加到项目中)\n  * [主要API](#api)\n\n---\n\n### 主要功能简介\n\n* 包含年历，月历。并且每个控件都有全方面的自定义属性。\n* 为某一天添加自定义文字样式和背景。\n* 包含滚动月历。支持滑动显示其它月份。\n* 支持多种监听。\n* 类似小米日历实现的，月历和周历上滑切换功能。\n* 支持disable；禁选，单选，多选，范围选择。\n* 提供一个帮助实现年历到月历的过渡动画的viewgroup。\n\n---\n\n### 添加到项目中\n\nAndroid Studio用户，在项目的build.gradle中添加该dependencies：\n\n  `\n    compile \"com.missmess.calendarview:calendarview:2.5.3\"\n  `\n\n从2.2.0及以下升级到2.4.0的请注意：\n1、由于2.4.0增加了控件对多选和范围选择的支持。原来MonthView中跟selection相关的方法有部分已经被删除或者修改。\n2、同样由于对多选的支持。周历滑动时，由于要保留多选模式下的selections，控件不再默认选中下一周的某一天，这里跟小米日历已经不一样了。其它方面在实现时已经尽量保持一致。\n\n---\n\n<h3 id='api'>主要API</h3>\n\n介绍一下主要的控件和api，更详细的可以下载demo来了解~\n\n###### 1、YearView\n\n  年历，显示一年的所有日期。YearView提供了16个自定义属性，用于完全定义你想要的布局：\n```xml\n    <declare-styleable name=\"YearView\">\n        <attr name=\"showYearLabel\" format=\"boolean\"/>\n        <attr name=\"showYearLunarLabel\" format=\"boolean\"/>\n        <attr name=\"dividerColor\" format=\"color\"/>\n        <attr name=\"yearHeaderTextColor\" format=\"color\" />\n        <attr name=\"yearHeaderTextHeight\" format=\"dimension\"/>\n        <attr name=\"yearHeaderTextSize\" format=\"dimension\"/>\n        <attr name=\"yearHeaderLunarTextColor\" format=\"color\"/>\n        <attr name=\"yearHeaderLunarTextSize\" format=\"dimension\"/>\n        <attr name=\"yearHeaderDashColor\" format=\"color\"/>\n        <attr name=\"monthLabelTextColor\" format=\"color\"/>\n        <attr name=\"monthLabelTextSize\" format=\"dimension\"/>\n        <attr name=\"monthLabelTextHeight\" format=\"dimension\"/>\n        <attr name=\"dayLabelTextColor\" format=\"color\"/>\n        <attr name=\"dayLabelTextSize\" format=\"dimension\"/>\n        <attr name=\"dayLabelRowHeight\" format=\"dimension\"/>\n        <attr name=\"dayLabelCircleRadius\" format=\"dimension\"/>\n    </declare-styleable>\n```\n\n  可以通过setDecors方法为YearView设置decorators。setDecors方法对于其它的控件都可用。详细见 [这里](#decorDetail) 。\n```java\n\tyearView.setToday(new CalendarDay(2017, 2, 12));\n\tDayDecor dayDecor = new DayDecor();\n\tdayDecor.putOne(new CalendarDay(2017, 1, 1), Color.GREEN);\n\tyearView.setDecors(dayDecor);\n```\n\n  截图：\n\n  ![image1](https://raw.githubusercontent.com/missmess/CalendarView/master/raw/yv.jpg)\n\n###### 2、MonthView\n\n  月历。提供了17个自定义属性来控制MonthView布局。\n  ```xml\n    <declare-styleable name=\"MonthView\">\n        <attr name=\"dayCircleRadius\" format=\"dimension\" />\n\t\t<attr name=\"selectDayCircleBgColor\" format=\"color\" />\n\t\t<attr name=\"dayTextColor\" format=\"color\"/>\n\t\t<attr name=\"dayDisableTextColor\" format=\"color\"/>\n\t\t<attr name=\"dayTextSize\" format=\"dimension\"/>\n\t\t<attr name=\"dayRowHeight\" format=\"dimension\" />\n\t\t<attr name=\"firstDayOfWeek\" format=\"integer\" />\n\t\t<attr name=\"monthTitleColor\" format=\"color\" />\n\t\t<attr name=\"monthTextSize\" format=\"dimension\" />\n\t\t<attr name=\"monthHeaderHeight\" format=\"dimension\" />\n\t\t<attr name=\"weekLabelTextColor\" format=\"color\" />\n\t\t<attr name=\"weekLabelTextSize\" format=\"dimension\" />\n\t\t<attr name=\"weekLabelPadding\" format=\"dimension\" />\n\t\t<attr name=\"showWeekLabel\" format=\"boolean\"/>\n\t\t<attr name=\"showWeekDivider\" format=\"boolean\"/>\n\t\t<attr name=\"showMonthTitle\" format=\"boolean\"/>\n\t\t<attr name=\"weekMode\" format=\"boolean\"/>\n    </declare-styleable>\n  ```\n\n 截图：\n\n ![image2](https://raw.githubusercontent.com/missmess/CalendarView/master/raw/mv2.jpg)\n\n###### 3、MonthViewPager\n\n  可滚动的月历，左右滑动或点击indicator切换显示的月份。\n\n  **使用MonthViewPager需要在xml中为它设置一个子view。这个子view只可以用来添加属性，但是不可以通过findViewById使用它。这个子view仅用作定义样式。**\n\n  截图：\n\n  ![gif2](https://raw.githubusercontent.com/missmess/CalendarView/master/raw/mvp.gif)\n\n###### 4、TransitRootView\n\n  这个viewgroup用来控制年历和月历之间的过渡。在xml中需要使用TransitRootView作为根布局，增加两个子view或viewgroup，它们分别包含你的YearView和MonthView（或者MonthViewPager）。\n  顺序不能颠倒，否则达不到指定的效果。详见demo。\n\n  提供了多个自定义属性用来控制过渡过程：\n  ```xml\n  <declare-styleable name=\"TransitRootView\">\n\t  <attr name=\"y2m_interpolator\" format=\"reference\" />\n\t  <attr name=\"m2y_interpolator\" format=\"reference\" />\n\t  <attr name=\"y_anim_duration\" format=\"integer\" />\n\t  <attr name=\"transit_base_duration\" format=\"integer\" />\n\t  <attr name=\"m_anim_duration\" format=\"integer\" />\n  </declare-styleable>\n  ```\n\n<h6 id='decorDetail'>5、DayDecor和Style</h6>\n\n  DayDecor可以为某一个显示的天，添加多种样式的Decorator或定义文字样式。示例：\n  ```java\n\t// add decorators\n\tDayDecor dayDecor = new DayDecor();\n\t// circle bg\n\tdayDecor.putOne(new CalendarDay(2017, 2, 1), 0xFFFF6600);\n\t// rectangle bg\n\tint color = 0xFFAAAAAA;\n\tdayDecor.putOne(new CalendarDay(2017, 2, 4), color, DayDecor.Style.RECTANGLE);\n\tdayDecor.putOne(new CalendarDay(2017, 2, 11), color, DayDecor.Style.RECTANGLE);\n\tdayDecor.putOne(new CalendarDay(2017, 2, 18), color, DayDecor.Style.RECTANGLE);\n\tdayDecor.putOne(new CalendarDay(2017, 2, 25), color, DayDecor.Style.RECTANGLE);\n\t// drawable bg\n\tdayDecor.putOne(new CalendarDay(2017, 2, 19), getResources().getDrawable(R.drawable.a_decor));\n\t// styled background and text\n\tDayDecor.Style style = new DayDecor.Style();\n\tstyle.setTextSize(getResources().getDimensionPixelSize(R.dimen.big_text));\n\tstyle.setTextColor(0xFF72E6BC);\n\tstyle.setBold(true);\n\tstyle.setItalic(true);\n\tstyle.setUnderline(true);\n\tstyle.setStrikeThrough(true);\n\tstyle.setPureColorBgShape(DayDecor.Style.CIRCLE);\n\tstyle.setPureColorBg(0xFF66AA76);\n\tdayDecor.putOne(new CalendarDay(2017, 2, 24), style);\n\tmonthView.setDecors(dayDecor);\n  ```\n\n###### 6、周历到月历切换\n  \n  1、支持月历周历的竖直滑动切换。需要配合nested scrolling。示例：\n  ```xml\n      <!-- 顶层需使用CoordinatorLayout -->\n      <android.support.design.widget.CoordinatorLayout\n          android:layout_width=\"match_parent\"\n          android:layout_height=\"match_parent\">\n  \n          <com.missmess.calendarview.MonthViewPager\n              android:id=\"@+id/mvp\"\n              android:layout_width=\"match_parent\"\n              android:layout_height=\"match_parent\"\n              calendar:ic_next_month=\"@mipmap/right_icon\"\n              calendar:ic_previous_month=\"@mipmap/left_icon\"\n              calendar:month_marginTop=\"0dp\"\n              calendar:otherMonthTextColor=\"#CCCCCC\"\n              calendar:showOtherMonth=\"true\"\n              calendar:show_indicator=\"false\">\n  \n              <com.missmess.calendarview.MonthView\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"wrap_content\"\n                  calendar:showMonthTitle=\"false\"\n                  calendar:showWeekDivider=\"false\"\n                  calendar:dayRowHeight=\"50dp\"\n                  calendar:showWeekLabel=\"false\"/>\n  \n          </com.missmess.calendarview.MonthViewPager>\n  \n  \t\t  <!-- 这个view将覆盖MonthViewPager，并且需要支持nested scrolling -->\n  \t\t  <!-- 需要增加behavior,  使用@string/monthViewPager_scroll_behavior-->\n          <android.support.v4.widget.NestedScrollView\n              android:id=\"@+id/scrollView\"\n              android:layout_width=\"match_parent\"\n              calendar:layout_behavior=\"@string/monthViewPager_scroll_behavior\"\n              android:background=\"@android:color/white\"\n              android:layout_height=\"match_parent\" >\n  \n              <TextView\n                  android:id=\"@+id/tv\"\n                  android:layout_width=\"match_parent\"\n                  android:layout_height=\"wrap_content\"\n                  android:gravity=\"center\"\n                  android:padding=\"15dp\"\n                  android:text=\"@string/no_event\"\n                  android:textSize=\"20sp\"/>\n  \n          </android.support.v4.widget.NestedScrollView>\n      </android.support.design.widget.CoordinatorLayout>\n  ```\n  \n  2、如果不需要嵌套垂直滑动切换week/month mode。则不要使用behavior即可。同时提供直接在代码中进行切换。\n  ```java\n  \t\tif(monthViewPager.isMonthMode()) {\n\t\t\tmonthViewPager.setWeekMode();\n\t\t} else {\n\t\t\tmonthViewPager.setMonthMode();\n\t\t}\n  ```\n  \n  通过上述步骤就能实现周历、月历切换功能。\n\n---\n\n### 接下来的工作\n###### 还有一些工作需要完善：\n\n  ~~1、 强化DayDecor的功能，包括对样式（加粗、斜体），任意背景，任意字体颜色的自定义。~~\n\n  ~~2、 增加月历上滑显示到周历的功能。类似于小米日历的效果。~~\n\n  ~~3、周历上切换时，默认设置selection也根据切换变化。~~\n\n  ~~4、设置某一天disable属性~~\n  ","slug":"/calendar-view"},{"id":"f0de2ec4-1280-53b1-89b9-0e64d3450d61","title":"CoverFlowView","tags":["Android端","Java","UI组件","开源"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAQBBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAGPOYShOX//xAAaEAACAgMAAAAAAAAAAAAAAAACAwEREhMg/9oACAEBAAEFAlinWULwoOP/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAACAgMAAAAAAAAAAAAAAAAAEQESIDFB/9oACAEBAAY/AuWIaZvD/8QAGxAAAgIDAQAAAAAAAAAAAAAAAREAISAxQaH/2gAIAQEAAT8hUktfZiC7tQLv1h//2gAMAwEAAgADAAAAEDwP/8QAFhEBAQEAAAAAAAAAAAAAAAAAERAh/9oACAEDAQE/EDWf/8QAFhEBAQEAAAAAAAAAAAAAAAAAEQEQ/9oACAECAQE/EEhn/8QAHRABAAICAgMAAAAAAAAAAAAAAQAhETEQQWFxwf/aAAgBAQABPxDdqgUztxTWoNACCw9rWPEeVR71+QUaYqlvH//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/28724f881f84f202e866ed1630787889/483b8/coverflow.jpg","srcSet":"/leon-blog/static/28724f881f84f202e866ed1630787889/9fa5a/coverflow.jpg 184w,\n/leon-blog/static/28724f881f84f202e866ed1630787889/63e75/coverflow.jpg 368w,\n/leon-blog/static/28724f881f84f202e866ed1630787889/483b8/coverflow.jpg 735w","sizes":"(min-width: 735px) 735px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/28724f881f84f202e866ed1630787889/9d028/coverflow.avif 184w,\n/leon-blog/static/28724f881f84f202e866ed1630787889/c6ee4/coverflow.avif 368w,\n/leon-blog/static/28724f881f84f202e866ed1630787889/6f2e7/coverflow.avif 735w","type":"image/avif","sizes":"(min-width: 735px) 735px, 100vw"},{"srcSet":"/leon-blog/static/28724f881f84f202e866ed1630787889/ef27d/coverflow.webp 184w,\n/leon-blog/static/28724f881f84f202e866ed1630787889/4ae45/coverflow.webp 368w,\n/leon-blog/static/28724f881f84f202e866ed1630787889/51181/coverflow.webp 735w","type":"image/webp","sizes":"(min-width: 735px) 735px, 100vw"}]},"width":735,"height":368},"body":"---\ntitle: \"CoverFlowView\"\ncover: images/coverflow.jpg\ncoverAlt: \"封面\"\ndescription: \"CoverFlowView是一个在Android上实现coverflow效果的组件\"\ndatePublished: \"2016-11-21 15:44:15\"\ndateModified: \"2016-11-21 15:44:15\"\ncategory: \"框架工具\"\ntags:\n  - Android端\n  - Java\n  - UI组件\n  - 开源\n---\n\nCoverFlowView是一个在Android上实现coverflow效果的组件。它的Item支持任意自定义布局。\n\ngithub仓库：https://github.com/missmess/CoverFlowView\n\n---\n\n  基于[ImageCoverFlow](https://github.com/dolphinwang/ImageCoverFlow)，但是有较大改动，在ImageCoverFlow的基础上增加了\n  对自定义布局的支持，可以支持任意布局。同时增加了一些其他支持，并修复了一些bug，提升绘制速度。\n\n  Based on [ImageCoverFlow](https://github.com/dolphinwang/ImageCoverFlow), add support to custom\n  layout in CoverFlow, fix some bugs, add other function.\n\n---\n  GIF预览：\n\n  ![gif](https://raw.githubusercontent.com/missmess/CoverFlowView/master/raw/sample.gif)\n\n---\n\n  * [主要功能介绍](#主要功能介绍)\n  * [如何添加到项目中](#如何添加到项目中)\n  * [如何使用](#如何使用)\n  * [其它API](#其它API)\n\n---\n\n### 主要功能介绍\n\n* 支持自定义布局。\n* 支持多种view切换方式。\n* 支持view on top， top click， long click监听。\n* 支持notify刷新数据源和重设适配器。\n\n---\n\n### 如何添加到项目中\n\n本library已经支持Gradle直接添加远程依赖。Android Studio用户，只需要在项目的build.gradle中添加该dependencies：\n\n  `\n    compile \"com.missmess.coverflowview:coverflowview:1.2.8\"\n  `\n\n---\n\n###如何使用\n\n使用非常简单。仅需几句代码。用法如下：\n###### 1、在xml中定义布局。\n```xml\n<com.missmess.coverflowview.CoverFlowView\n    android:id=\"@+id/coverflow_view\"\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"180dp\"\n    app:loopMode=\"true\"\n\tapp:visibleViews=\"3\"/>\n```\n###### 2、创建adapter。继承于ACoverFlowAdapter。adapter的实现与RecyclerView.Adapter完全相同。\n```java\npublic class MyCoverFlowAdapter extends ACoverFlowAdapter<MyCoverFlowAdapter.ViewHolder> {\n    @Override\n    public int getCount() {\n        return 0;\n    }\n\n    @Override\n    public ViewHolder onCreateViewHolder(ViewGroup parent, int type) {\n        return null;\n    }\n\n    @Override\n    public void onBindViewHolder(ViewHolder vh, int position) {\n    }\n\n    class ViewHolder extends ACoverFlowAdapter.ViewHolder {\n        public ViewHolder(View itemView) {\n            super(itemView);\n        }\n    }\n}\n```\n\n###### 3、为CoverFlowView设置adapter。\n```java\nCoverFlowView coverflow_view = (CoverFlowView) findViewById(R.id.coverflow_view);\nMyCoverFlowAdapter adapter = new MyCoverFlowAdapter();\ncoverflow_view.setAdapter(adapter);\n```\n---\n\n### 其它API\n###### 1、切换CoverFlow\n* 你可以通过滑动切换，也可以通过点击CoverFlow的左右两侧实现快速切换。但点击切换需要确保clickSwitchEnable为\ntrue。\n\n  通过coverFlowView.setClick2SwitchEnabled(boolean enable)方法设置是否启用点击左右侧切换。\n\n* 如果你想在在代码中切换view。可以有如下的几种方法：\n\n  1. gotoPrevious()：当前位置往前切换一个。\n\n  2. gotoForward()：当前位置往后切换一个。\n\n  3. setSelection(int selection, boolean smooth)：切换到指定的位置，smooth为true则显示过渡动画，为false\n则快速切换。\n\n###### 2、更新数据\n* 你可以直接使用adapter.notifyDataSetChanged()来刷新你的适配器数据。\n* 也可以使用新的adapter：\n```java\ncoverflow_view.setAdapter(new NewCoverFlowAdapter());\n```\n\n###### 3、设置监听\nCoverFlowView提供三种lister：\n\n* setOnViewOnTopListener：当任意一个新的view停止滑动后，位于顶部。就会调用。这个是最常用的。\n* setOnTopViewClickListener：当位于顶部的view被点击后调用。\n* setOnTopViewLongClickListener：当位于顶部的view接收了long click事件时调用。\n\n\n###### 4、循环模式\n使用setLoopMode(boolean)方法或者在xml中定义loopMode来启用和关闭循环模式。\n在循环模式下，将可以无限向左和向右滑动，item将会循环显示。关闭后，滑动到第一个或者最后一个item，将\n不能继续向左或向右滑动。\n\n\n---\n\n### 截图\n\n  ![image1](https://raw.githubusercontent.com/missmess/CoverFlowView/master/raw/screenshot_1.jpg)\n  ![image2](https://raw.githubusercontent.com/missmess/CoverFlowView/master/raw/screenshot_2.jpg)\n  ![image3](https://raw.githubusercontent.com/missmess/CoverFlowView/master/raw/screenshot_3.jpg)\n","slug":"/cover-flow-view"},{"id":"9573c561-38e1-5489-bd26-84c9d072e301","title":"EmotionKeyboard","tags":["Android端","Java","库","开源"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAP/aAAwDAQACEAMQAAAB2k4DYMb/xAAXEAEBAQEAAAAAAAAAAAAAAAAAAREC/9oACAEBAAEFAmox3Ij/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAACAgMAAAAAAAAAAAAAAAAAECFBARGB/9oACAEBAAY/AqJ0umItf//EABkQAAMBAQEAAAAAAAAAAAAAAAABETEhQf/aAAgBAQABPyGvs9Qcyk7NKdzRpcQYwKJXnp//2gAMAwEAAgADAAAAEFfP/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8QiP/EABURAQEAAAAAAAAAAAAAAAAAABAR/9oACAECAQE/EKf/xAAdEAEAAgICAwAAAAAAAAAAAAABETEAIUFRYXHR/9oACAEBAAE/EAoqRc17xGCW0bfHzIsthGmckuq1zF4pJdHYX3iEQSlgvP/Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/a6e1b/ekb_cover.jpg","srcSet":"/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/a5a17/ekb_cover.jpg 136w,\n/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/befb6/ekb_cover.jpg 271w,\n/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/a6e1b/ekb_cover.jpg 542w","sizes":"(min-width: 542px) 542px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/115b9/ekb_cover.avif 136w,\n/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/1db71/ekb_cover.avif 271w,\n/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/ec68b/ekb_cover.avif 542w","type":"image/avif","sizes":"(min-width: 542px) 542px, 100vw"},{"srcSet":"/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/29acf/ekb_cover.webp 136w,\n/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/c5a28/ekb_cover.webp 271w,\n/leon-blog/static/220d40ff8d0489743ae9bf77c737f0a3/785ec/ekb_cover.webp 542w","type":"image/webp","sizes":"(min-width: 542px) 542px, 100vw"}]},"width":542,"height":272},"body":"---\ntitle: \"EmotionKeyboard\"\ncover: images/ekb_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"帮助实现类似微信的聊天界面表情布局和功能布局与键盘同高，并且无缝切换的特效。\"\ndatePublished: \"2017-06-20 10:40:32\"\ndateModified: \"2017-06-20 10:40:32\"\ncategory: \"框架工具\"\ntags:\n  - Android端\n  - Java\n  - 库\n  - 开源\n---\n\n帮助实现类似微信的聊天界面表情布局和功能布局与键盘同高，并且无缝切换的特效。\n\ngithub仓库：https://github.com/missmess/EmotionKeyboard\n\n---\n\n类似微信聊天界面的表情窗口控制，窗口跟软键盘同高，无缝切换效果。\n有两个类，原先的EmotionKeyboard使用的核心代码参考的是dss886的开源项目（ https://github.com/dss886/Android-EmotionInputDetector ）。\n但是经测试发现，这个类有一些无法解决的问题（源于它的方法实现原理），如\n\n<ol>\n<li>表情键盘显示时，长按输入框文字会导致表情键盘，软键盘切换出错。</li>\n<li>表情键盘和软键盘无法平滑的过渡。</li>\n<li>使用不太方便，默认只支持LinearLayout，要自己实现locker</li>\n</ol>\n\n所以这个类已经不提供更新了，仅仅提供大家作为参考。\n现在用了一个新的思路去实现同样的功能。使用方法相同，但是却解决了以上无法解决的所有问题。详情请查看EmojiconKeyBoard源码。\n  \n---\n  GIF和图片预览：\n\n  ![gif](https://raw.githubusercontent.com/missmess/EmotionKeyboard/master/raw/sample.gif)\n  \n  ![gif](https://raw.githubusercontent.com/missmess/EmotionKeyboard/master/raw/sample2.gif)\n\n---\n\n### 如何添加到项目中\n\n在项目的build.gradle中添加该dependencies：\n\n  `\n    compile 'com.missmess.emotionkeyboard:emotionkeyboard:1.1.3'\n  `\n\n---\n\n### 功能介绍\n\n#### KeyboardInfo\n  \n  KeyboardInfo可以用来监听键盘状态变化和获取键盘高度信息，并缓存。使用步骤：\n  \n  1. 在onCreate中获取：\n  ```java\n  KeyboardInfo keyboardInfo = KeyboardInfo.from(this);\n  ```\n  \n  2. 设置监听listener:\n  ```java\n    keyboardInfo.setOnKeyboardChangeListener(new KeyboardInfo.OnSoftKeyboardChangeListener() {\n\t\t@Override\n\t\tpublic void onSoftKeyboardStateChanged(boolean shown, int height) {\n\t\t\tif (shown) {\n\t\t\t\ttv_status.setText(String.format(\"键盘弹出了，高度为 %d\", height));\n\t\t\t} else {\n\t\t\t\ttv_status.setText(\"键盘收起了\");\n\t\t\t}\n\t\t}\n\t});\n  ```\n  \n  3. 在onCreate或者onResume中开始监听键盘状态变化：\n  ```java\n    keyboardInfo.startListening();\n  ```\n  \n  4. 在onDestory或者onPause中结束监听：\n  ```java\n    keyboardInfo.stopListening();\n  ```\n  \n  也可以通过调用getSoftKeyboardHeight()方法，只要打开过一次键盘之后这个方法就总能取到正确的键盘高度值。\n  \n#### EmojiconKeyBoard\n\n  帮助协调聊天内容布局，聊天输入框，表情按钮和表情布局的控制类。这个类的作用有：\n  \n  1. 实现弹出键盘和表情布局；\n  2. 实现表情布局和软键盘同高，无缝切换；\n  3. 实现输入框和内容布局的焦点控制。\n  \n  实现效果类似微信的聊天输入框交互，并能实现很多的自定义扩展功能。\n  \n  使用步骤：\n  1. 使用Builder创建和定义你需要的功能：\n  ```java\n  \t\t\t  emotionKeyboard = new EmojiconKeyBoard.Builder(this)\n                  .contentLayout(contentView)//绑定内容view\n                  .editText(editText)//绑定EditView\n                  .addEmotionBtnAndLayout(emoji_button1, layout_button1)//添加第一个表情按钮布局\n                  .addEmotionBtnAndLayout(emoji_button2, layout_button2)//第二个\n                  .touchContentViewHideAllEnabled(null)//是否在触摸内容view时获取焦点隐藏键盘\n                  .keyboardStateCallback(callback)//键盘状态监听\n                  .emotionPanelStateCallback(callback)//表情布局状态监听\n                  .build();//创建\n  ```\n  \n  2. 注意在按下返回键时判断是否要隐藏表情布局：\n  ```java\n      @Override\n      public void onBackPressed() {\n          if (!emotionKeyboard.interceptBackPress()) {\n              super.onBackPressed();\n          }\n      }\n  ```\n  \n  参考DEMO中的WechatActivity，可以完全的实现类似微信聊天界面的交互。\n  \n  <b>你的主题和你的window属性很多情况下都会导致，键盘弹出和收起不平滑，即动画的背景不是我们的表情布局。\n  建议你使用全屏主题。如果使用透明状态栏主题，请自行设置fitSystemWindow为true，和clipToPadding为false。</b>\n  \n#### EmojiconKeyBoard\n\n  已经废弃，仅供参考，不要使用。已经使用的请使用新的类EmojiconKeyBoard\n  ","slug":"/emotion-keyboard"},{"id":"554bce3d-c481-585f-ad39-d88b8405d0da","title":"FastMind","tags":["前端","React","大模型","Antd","AI"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHVsKcBIf/EABsQAAEEAwAAAAAAAAAAAAAAAAIAAQMQEjNB/9oACAEBAAEFAohfGg19X//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAIDAQAAAAAAAAAAAAAAAAEQAhIxgf/aAAgBAQAGPwKJscY4/wD/xAAcEAABAwUAAAAAAAAAAAAAAAAAETGBASFhocH/2gAIAQEAAT8hYWRaCRMmmOCjH//aAAwDAQACAAMAAAAQZA//xAAWEQEBAQAAAAAAAAAAAAAAAAABEDH/2gAIAQMBAT8QVdn/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAbEAEAAgMBAQAAAAAAAAAAAAABABEhMZFBUf/aAAgBAQABPxC1s6fOdJWd/sFVj5GlSlEcJbYjRP/Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/dba67/cover.jpg","srcSet":"/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/891f5/cover.jpg 176w,\n/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/19cc4/cover.jpg 352w,\n/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/dba67/cover.jpg 704w,\n/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/1f3b1/cover.jpg 1408w","sizes":"(min-width: 704px) 704px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/94818/cover.avif 176w,\n/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/bd4f6/cover.avif 352w,\n/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/2856f/cover.avif 704w,\n/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/69a09/cover.avif 1408w","type":"image/avif","sizes":"(min-width: 704px) 704px, 100vw"},{"srcSet":"/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/76df1/cover.webp 176w,\n/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/d3e0a/cover.webp 352w,\n/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/b4509/cover.webp 704w,\n/leon-blog/static/9b6596944e6bd19b0a208a4d75f8b5f6/816c4/cover.webp 1408w","type":"image/webp","sizes":"(min-width: 704px) 704px, 100vw"}]},"width":704,"height":368},"body":"---\ntitle: \"FastMind\"\ncover: fastmind/cover.jpg\ncoverAlt: \"FastMind工作台\"\ndescription: \"FastMind是一个AI大模型助手平台\"\ndatePublished: \"2023-06-23 09:13:11\"\ndateModified: \"2023-06-23 09:13:11\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - 大模型\n  - Antd\n  - AI\n---\n\n**FastMind**是一个免费可用的AI大语言模型**自建助手**平台，可以创建你自己想要的助手，并可以在平台内外分享。\n\n访问地址：http://ai.siyisea.com\n\n![](./fastmind/intro.jpg)\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [PC截图](#pc截图)\n- [H5截图](#h-5-截图)\n\n### 主要功能\n\n1. **AI大模型**\n\n    接入llm提供商（gpt3.5、gpt4、文心一言等）处理语言服务。\n\n2. **180+官方助手**\n\n    已涵盖大部分大语言模型可以提效的场景，开箱即用。\n\n3. **自建知识库**\n\n    支持自己上传任意常用格式的文档，让助手理解你的业务。\n\n    ![](./fastmind/zhishiku.jpg)\n\n4. **自建助手**\n\n    可以任意自定义助手的形象、名称、对话风格、聊天框背景、llm模型、模型设置、知识库等。\n\n    并且可以在修改配置后，实时预览移动端效果。\n\n    ![](./fastmind/zhushou.jpg)\n\n5. **支持多话题**\n\n    可以和同一个助手聊多个不同的话题。\n\n    ![](./fastmind/huati.jpg)\n\n6. **支持会员**\n\n    免费用户流量受限，购买会员后解锁更多功能。\n\n7. **管理后台**\n\n    配套的统一管理后台，包含助手管理、会话管理、用户管理、token管理、收入管理等\n\n    查看：[AI统一管理后台](/ai聊天统一后台)\n\n### 我的职责\n\n1. 产品UI设计。\n\n2. 前端页面开发。\n\n### 技术实现\n\n1. 前端使用React、Ant-Design、craco开发。\n\n2. 响应式设计，同时支持PC和手机浏览器。PC访问时默认展示应用官网、移动端访问时默认展示工作台。\n\n3. 可以切换暗黑/明亮两种主题。\n\n4. 接入微信支付，支持购买会员计划。\n\n5. 用户登录、信息查询等接入[用户中心服务](/用户中心服务)，使用Express开发。\n\n6. AI大模型部分接入gpt3.5。\n\n7. 聊天消息渲染使用react-markdown。\n\n### PC截图\n\n![官网](./fastmind/capture_1.jpg)\n![购买会员](./fastmind/capture_2.jpg)\n![登录](./fastmind/capture_3.jpg)\n![助手详情](./fastmind/capture_4.jpg)\n![知识库](./fastmind/capture_5.jpg)\n![邀请好友](./fastmind/capture_6.jpg)\n\n### H5截图\n\n![首页](./fastmind/capture_1_m.jpg)\n![助手详情](./fastmind/capture_2_m.jpg)\n![会话列表](./fastmind/capture_3_m.jpg)\n![我的](./fastmind/capture_4_m.jpg)\n![我的会员](./fastmind/capture_5_m.jpg)","slug":"/fast-mind"},{"id":"a6c3f1fe-f10b-575f-b142-839e2acef21b","title":"HandWritingRecognize【手写识别】","tags":["Android端","AI","库","开源","图像处理"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAZVNjNAUH//EABwQAAEDBQAAAAAAAAAAAAAAABIAAgMBESMxMv/aAAgBAQABBQIWFjGMLO1TiJf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAfEAACAQIHAAAAAAAAAAAAAAAAATECchESIjJRgcH/2gAIAQEABj8Cb1Sx45o4HukV1R16VXH/xAAdEAEAAgICAwAAAAAAAAAAAAABABEhMWHhUbHw/9oACAEBAAE/IUdS3tHPcVY/A08nMItb7YJ9LmJc2+qe1P/aAAwDAQACAAMAAAAQww//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAEBAAICAwEAAAAAAAAAAAABEQAhQbExUZHR/9oACAEBAAE/EKDLQVWDxaHB5bkJSsDUAOmTgNodagzTiZVjc9wjt+uI6RG25JRrX88//9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/08353f3a232a8a07db9ed373733b5356/9b034/hwr_cover.jpg","srcSet":"/leon-blog/static/08353f3a232a8a07db9ed373733b5356/6a7d5/hwr_cover.jpg 160w,\n/leon-blog/static/08353f3a232a8a07db9ed373733b5356/15957/hwr_cover.jpg 320w,\n/leon-blog/static/08353f3a232a8a07db9ed373733b5356/9b034/hwr_cover.jpg 640w","sizes":"(min-width: 640px) 640px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/08353f3a232a8a07db9ed373733b5356/d1de0/hwr_cover.avif 160w,\n/leon-blog/static/08353f3a232a8a07db9ed373733b5356/c45e3/hwr_cover.avif 320w,\n/leon-blog/static/08353f3a232a8a07db9ed373733b5356/5da5e/hwr_cover.avif 640w","type":"image/avif","sizes":"(min-width: 640px) 640px, 100vw"},{"srcSet":"/leon-blog/static/08353f3a232a8a07db9ed373733b5356/93092/hwr_cover.webp 160w,\n/leon-blog/static/08353f3a232a8a07db9ed373733b5356/33439/hwr_cover.webp 320w,\n/leon-blog/static/08353f3a232a8a07db9ed373733b5356/87cad/hwr_cover.webp 640w","type":"image/webp","sizes":"(min-width: 640px) 640px, 100vw"}]},"width":640,"height":320},"body":"---\ntitle: \"HandWritingRecognize【手写识别】\"\ncover: images/hwr_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"手写识别\"\ndatePublished: \"2018-09-11 09:12:11\"\ndateModified: \"2018-09-11 09:12:11\"\ncategory: \"框架工具\"\ntags:\n  - Android端\n  - AI\n  - 库\n  - 开源\n  - 图像处理\n---\n\n## HardwritingRecognition\nAndroid端手写识别组件，目前主要实现手写数字识别方面。支持单数字和多数字。\n\ngitee仓库：https://gitee.com/missmess/HardwritingRecognition\n\n技术实现：通过opencv对输入图像进行拆分/缩放/归一化等处理，送入推理框架推理取得分值最高的结果。\n\n> 当前已支持pytorch、tensorflow lite框架，如果需要支持其他推理框架，请自行实现接口。\n\n---\n\n  * [主要功能简介](#主要功能简介)\n  * [添加到项目中](#添加到项目中)\n  * [主要API](#主要API)\n\n---\n\n### 主要功能简介\n  * 单个数字识别\n  * 多个数字组合识别\n\n### 添加到项目中\n\na. 在根目录下的build.gradle下添加远程仓库地址:\n```java\nallprojects {\n    repositories {\n        google()\n        jcenter()\n        maven { url \"http://10.2.1.12:8081/repository/cloudlearning-release/\" }\n    }\n}\n```\n\nb. 在app的build.gradle里添加远程库的依赖:\n```java\nimplementation 'com.xes.hardwritingrecognition:hardwritingrecognition:1.2.0'\n```\n\n**从1.2.0开始，改为使用输入笔画的方式来识别，替代了之前版本中输入整个bitmap的方式。**\n\n### 主要API\n##### 1. 使用HWRecognizer的构造方法创建实例，第二个参数是识别库需要使用到的Model文件。（对应的tensorflow则使用的是pb文件）。\n```java\nHWRecognizer recognizer = new HWRecognizer(this, \"mnist_1207.pb\");\n```\n\n##### 2. 每手写一个笔画，将path输入到HWRecognizer。\n```java\nrecognizer.addPath(path);\n```\npath以画布的左上角为原点，参考[demo](app/src/main/java/com/xes/recognitiondemo/HandWriteView.java)中path的获取。\n\n##### 3. 调用识别方法，将会处理已输入的所有笔画，并返回字符串的结果\n```java\nString result = recognizer.start();\n```\n\n##### 4. 新一轮识别前，需要清空已输入的paths。\n```java\nrecognizer.clearPaths();\n```\n\n##### 5. 在合适的地方关闭，释放资源。\n```java\nrecognizer.destroy();\n```\n\n##### 此外，如果需要查看日志和图片切割过程。请在创建实例前打开debug模式。\n```java\nHWRecognizer.DEBUG_MODE = true;\n```\ndebug模式下，会生成日志，并在sd卡中app目录下按时间生成图片处理多个流程的生成图像，方便调试。\n\n","slug":"/hand-writing-recognize【手写识别】"},{"id":"3c1ee94e-9e9e-58bf-8163-da26d9464281","title":"心动天气","tags":["Android端","kotlin","组件化"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBP/EABUBAQEAAAAAAAAAAAAAAAAAAAAD/9oADAMBAAIQAxAAAAHQN0nJQf/EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEAAQUCX//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AUf/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwFX/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGBAAAgMAAAAAAAAAAAAAAAAAABEBICH/2gAIAQEAAT8hpiFB/9oADAMBAAIAAwAAABB8/wD/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxCKf//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/EKh//8QAGhABAAIDAQAAAAAAAAAAAAAAAQARECFhkf/aAAgBAQABPxCBYuK4QvR0zoeT/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/726a1/cover.jpg","srcSet":"/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/b40c6/cover.jpg 122w,\n/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/a3667/cover.jpg 244w,\n/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/726a1/cover.jpg 488w,\n/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/e6eeb/cover.jpg 976w","sizes":"(min-width: 488px) 488px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/c83aa/cover.avif 122w,\n/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/ffb23/cover.avif 244w,\n/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/9f936/cover.avif 488w,\n/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/a894c/cover.avif 976w","type":"image/avif","sizes":"(min-width: 488px) 488px, 100vw"},{"srcSet":"/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/f61a6/cover.webp 122w,\n/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/02b4e/cover.webp 244w,\n/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/e4341/cover.webp 488w,\n/leon-blog/static/74d25cd1a75c31ca54c1239893f6d185/71dbb/cover.webp 976w","type":"image/webp","sizes":"(min-width: 488px) 488px, 100vw"}]},"width":488,"height":368.00000000000006},"body":"---\ntitle: \"心动天气\"\ncover: weather/cover.jpeg\ncoverAlt: \"封面\"\ndescription: \"心动天气\"\ndatePublished: \"2021-05-30 09:08:40\"\ndateModified: \"2021-05-30 09:08:40\"\ncategory: \"应用项目\"\ntags:\n  - Android端\n  - kotlin\n  - 组件化\n---\n\n心动天气是一款主打天气预报，集热点新闻、日历提醒为一体的生活服务类app。\n\n---\n\n#### 技术特点\n\n1. 整体使用kotlin语言开发。部分控件使用java开发。\n\n2. 使用ARouter实现组件化开发。组件可单独运行、调试。\n\n3. 使用glide加载图片，图片缓存/优化。\n\n4. 使用OkHttp作为请求框架，使用Retrofit注解式定义接口，使用RxJava处理接口数据流。\n\n5. **【corelib】**module包含：业务无关的基础依赖、基础UI框架、事件总线RxBus、基础请求框架、常用弹窗、常用工具类。\n\n6. **【cmpt】**module包含：业务相关的基础依赖、BaseActivity/BaseFragment、页面路由定义、业务请求封装、基础控件、一些常量。\n\n7. **【app】**module包含：Application基类，启动页。（仅作为app壳子）。\n\n8. 其他业务模块：如home、mine、live，各个模块包含自己独立的业务代码。这部分代码包含：\n\n    - 页面，activity/fragment/view\n    - bean model\n    - 接口类\n    - 业务资源\n\n#### 抽离脚手架\n\n心动天气是一个比较完善的```组件化+kotlin+Retrofit+Glide+MessUi```的实践项目。可以作为Android项目的启动脚手架使用。\n\n注意，如果要作为脚手架，遵循以下三步：\n\n1. 删除业务模块。\n\n2. 修改cmpt模块，它是业务基础module，这里面需要根据自己的业务规范和UI风格来相应调整。\n\n3. corelib不需要修改，它是业务无关的基础module\n\n#### 截图\n\n![首页](./weather/home.jpg)","slug":"/心动天气"},{"id":"480d6930-907f-5337-afa1-85993a4b4861","title":"云流","tags":["前端","Vue2","ElementUI","低代码"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdi0qoC//8QAFhAAAwAAAAAAAAAAAAAAAAAAAxAz/9oACAEBAAEFAgyQpL//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAACEHH/2gAIAQEABj8CCMI//8QAGxAAAQQDAAAAAAAAAAAAAAAAEAABIbExcaH/2gAIAQEAAT8hhq0suOLR/9oADAMBAAIAAwAAABC/z//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAAMAAAAAAAAAAAAAAAAAAAEQMf/aAAgBAgEBPxA1f//EABsQAAMAAgMAAAAAAAAAAAAAAAERIQAQQVHw/9oACAEBAAE/EACa7xzGIMVE1Pjjf//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/b81b450d344d4380aa1e14c693215564/4bfa0/dashboard.jpg","srcSet":"/leon-blog/static/b81b450d344d4380aa1e14c693215564/891f5/dashboard.jpg 176w,\n/leon-blog/static/b81b450d344d4380aa1e14c693215564/e8926/dashboard.jpg 353w,\n/leon-blog/static/b81b450d344d4380aa1e14c693215564/4bfa0/dashboard.jpg 705w,\n/leon-blog/static/b81b450d344d4380aa1e14c693215564/62351/dashboard.jpg 1410w","sizes":"(min-width: 705px) 705px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/b81b450d344d4380aa1e14c693215564/94818/dashboard.avif 176w,\n/leon-blog/static/b81b450d344d4380aa1e14c693215564/e6b06/dashboard.avif 353w,\n/leon-blog/static/b81b450d344d4380aa1e14c693215564/a9331/dashboard.avif 705w,\n/leon-blog/static/b81b450d344d4380aa1e14c693215564/99654/dashboard.avif 1410w","type":"image/avif","sizes":"(min-width: 705px) 705px, 100vw"},{"srcSet":"/leon-blog/static/b81b450d344d4380aa1e14c693215564/76df1/dashboard.webp 176w,\n/leon-blog/static/b81b450d344d4380aa1e14c693215564/21f4f/dashboard.webp 353w,\n/leon-blog/static/b81b450d344d4380aa1e14c693215564/51247/dashboard.webp 705w,\n/leon-blog/static/b81b450d344d4380aa1e14c693215564/aa183/dashboard.webp 1410w","type":"image/webp","sizes":"(min-width: 705px) 705px, 100vw"}]},"width":705,"height":368},"body":"---\ntitle: \"云流\"\ncover: yunliu/dashboard.jpg\ncoverAlt: \"云流工作台\"\ndescription: \"云流是低代码B端数据平台\"\ndatePublished: \"2023-03-11 09:40:09\"\ndateModified: \"2023-03-11 09:40:09\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - Vue2\n  - ElementUI\n  - 低代码\n---\n\n**云流**是低代码的B端管理后台+数据平台产品。\n\n访问地址：http://114.55.92.229/backstage/\n\n参考：[yudao源码](https://gitee.com/y_project/RuoYi-Vue)。\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n1. **常见后台管理功能**\n\n  - 平台用户管理\n  - 部门/组织架构/岗位管理\n  - 菜单管理，菜单全动态配置，支持n级树状菜单\n  - 角色/权限管理，管理菜单、数据权限\n  - 通知公告\n\n2. **流程管理**\n\n  可以自己创建流程应用。\n  ![创建应用](./yunliu/app-create.jpg)\n  \n  创建应用后可以设计流程表单，图形化拖动方式。支持全部常用组件。\n  ![表单设计](./yunliu/app-form.jpg)\n  \n  可以使用流程设计器（bpmn），图形化拖动来设置流程。\n  ![流程设计](./yunliu/app-bpmn.jpg)\n\n  流程应用调整设置后，可以发布，后续员工可以使用该流程。\n  ![流程发布](./yunliu/app-set.jpg)\n\n3. **nocodb数据管理**\n\n  nocodb服务作为一个子服务，云流内嵌nocodb的GUI作为项目下的数据管理功能。\n\n  员工申请流程后，也可以在数据表格中进行数据管理。\n\n### 我的职责\n\n1. 产品UI调整。\n\n2. 管理后台UI开发。\n\n3. nocodb对接协议设计、开发。\n\n### 技术实现\n\n1. 云流使用vue2、element-ui开发。\n\n2. 流程设计器使用bpmn-js。\n\n3. 表单设计器使用form-generator。\n\n4. 富文本使用quill，表格使用echarts。\n\n### 截图\n\n![登录](./yunliu/login.jpg)\n![项目](./yunliu/project.jpg)","slug":"/云流"},{"id":"78843eb5-ca22-58dd-bfb4-4ddc46dd732b","title":"【造轮子】async/await实现原理","tags":["前端","造轮子"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAUCAwT/xAAWAQEBAQAAAAAAAAAAAAAAAAACAQP/2gAMAwEAAhADEAAAAa4YjMsBeOf/xAAaEAACAwEBAAAAAAAAAAAAAAAAAQIDEhMR/9oACAEBAAEFAn1mcrEO66s1I3I9bP/EABYRAQEBAAAAAAAAAAAAAAAAAAABEv/aAAgBAwEBPwFqv//EABkRAAIDAQAAAAAAAAAAAAAAAAABAgMhQf/aAAgBAgEBPwHUKuPUf//EABsQAAICAwEAAAAAAAAAAAAAAAABETICIZGh/9oACAEBAAY/ApeZf0htMsyz6bP/xAAdEAEAAgAHAAAAAAAAAAAAAAABABEQITFBYYGR/9oACAEBAAE/ISYEEuhSW9vaVF0LFJVkemCtQleZ/9oADAMBAAIAAwAAABA8L//EABgRAQADAQAAAAAAAAAAAAAAAAEAESGx/9oACAEDAQE/ELHXsQcZ/8QAGBEAAwEBAAAAAAAAAAAAAAAAAAERcSH/2gAIAQIBAT8QnBSYNqouH//EABwQAQACAwADAAAAAAAAAAAAAAEAESFBYTFR8f/aAAgBAQABPxAYagQBL8BCwAxqzjzpNjWAUtOeoHoQwA8T7SKdFWrZ/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/fff17/async_await.jpg","srcSet":"/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/9fa5a/async_await.jpg 184w,\n/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/63e75/async_await.jpg 368w,\n/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/fff17/async_await.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/9d028/async_await.avif 184w,\n/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/c6ee4/async_await.avif 368w,\n/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/b4627/async_await.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/ef27d/async_await.webp 184w,\n/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/4ae45/async_await.webp 368w,\n/leon-blog/static/ad40318728e46b7272991eba3d6d28eb/20e6b/async_await.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"【造轮子】async/await实现原理\"\ncover: ../static/assets/async_await.jpeg\ncoverAlt: \"封面图\"\ndescription: \"async/await是ES7的新特性，是一种异步编程的解决方案\"\ndatePublished: \"2022-12-27 18:47:13\"\ndateModified: \"2022-12-27 18:47:13\"\nslug: \"async-await-intro\"\ncategory: \"经验总结\"\ntags:\n  - 前端\n  - 造轮子\n---\n\nasync/await是ES7的新特性，它是处理异步操作的一种语法糖，主要是为了使异步代码更加简洁和直观。\n\n#### async/await基础知识\n\n`async`用在函数上，声明这个函数是异步函数。异步函数会返回一个Promise对象。\n\n`await`用在一个返回Promise的表达式前面，它会等待这个Promise的结束，并获取Promise的结果值（如果包含error，需要try catch）。`await`只能用在异步函数内，即和`async`搭配使用。如下：\n\n```javascript\nasync function asyncFunc() {\n    ...\n    // anotherAsyncFunc返回Promise，result是它的结果值\n    const result = await anotherAsyncFunc()\n    ...\n}\n```\n\n`async/await`的出现，让异步代码编写很类似于同步代码的风格，比起`Promise`的写法，代码可读性要高很多。\n\n本次主要扒一下`async/await`的底层实现，它是一个语法糖，所以它可以转为老的代码写法：它可以使用`generator`和`Promise`实现一样的功能。\n\n#### generator（生成器）\n\n`generator`是ES6的新特性，它是一种特殊的函数，可以通过`yield`关键字来控制函数的执行流程。它能实现代码的暂停和恢复执行，所以它可以用于实现异步编程、状态机等比较复杂的控制流程。\n\n`generator`函数使用`function*`声明，调用`generator`函数后，它不会立即执行，而是返回一个迭代器对象`iterator`。调用`iterator`的`next`方法，会逐步执行`generator`函数中的代码，并执行到`yield`语句时暂停，将`yield`后的表达式的值作为`next`方法的返回值。`next`方法的参数值，会作为上一个`yield`语句的返回值。`generator`函数执行结束后，`iterator`的`done`会返回true。示例：\n\n```javascript\nfunction* generatorFunc() {\n    console.log('Start')\n    const data1 = yield 'state 1';\n    console.log('return 1', data1);\n    const data2 = yield 'state 2';\n    console.log('return 2', data2);\n}\n\nconst iterator = generatorFunc();\nconsole.log(iterator.next()); // 会依次打印：Start、{ done: false, value: 'state 1' }\nconsole.log(iterator.next(\"张三\"));  // 会依次打印：return 1 张三、{ done: false, value: 'state 2' }\nconsole.log(iterator.next(\"李四\"));  // 会依次打印：return 2 李四、{ done: true, value: undefined }\n```\n\n`generator`一个典型的用途就是搭配对象的`[Symbol Iterator]`迭代器属性，让任意对象实现`for..of`迭代。\n\n#### generator实现async/await\n\n比如如下使用了`async/await`的函数：\n```javascript\n// async/await的写法\nconst doAsync = async () => {\n    console.log(\"start await\");\n    const data1 = await asyncFunc(\"asyncFunc 1\");\n    console.log(\"middle await\", data1);\n    const data2 = await asyncFunc(data1);\n    console.log(\"end await\", data2);\n};\n```\n\n该函数调用方法为：`doAync()`，返回Promise\n\n要转成`generator`，让`generator`函数内的写法和该方法类似。\n\n```javascript\n// generator的写法\nfunction* generator() {\n    console.log(\"start generator\");\n    const data1 = yield asyncFunc(\"asyncFunc 1\");\n    console.log(\"middle generator\", data1);\n    const data2 = yield asyncFunc(data1);\n    console.log(\"end generator\", data2);\n}\n```\n\n因为`yield`会暂停执行代码，所以使用`yield`也实现了类似`await`的效果。有了`generator`函数，需要调用函数后获取`iterator`，让`iterator`全部执行并直到结果done为true。\n\n```javascript\n// 通用的generatorRunner，将yield全部执行，并且获取异步函数返回值\n// 效果就是类似于async/await\nconst generatorRunner = (genFunc: () => Generator) => {\n  const iterator = genFunc();\n  // 连续调用next方法，直到done为true\n  return (function run(arg?: any): any {\n    const result = iterator.next(arg);\n    if (result.done) {\n      return result.value;\n    }\n    return Promise.resolve(result.value).then(run);\n  })();\n};\n```\n\n看代码，因为`yield`后面跟的是一个`Promise`，所以需要使用`Promise.resolve`来处理value。然后在`then回调`里递归调用`run()`。直到done为true。\n\n这个`generatorRunner`是通用的，参数是`generator`函数，会将`generator`函数内的语句按顺序执行完，遇到`Promise`会等待resolved，最终返回`generator`函数的返回值。\n\n`generatorRunner`和`generator`函数都写好了，调用方法：`generatorRunner(generator)`，也是返回Promise。\n\n#### babel或ts是怎么转译的\n\n前面我们使用`generator`+`Promise`的方式，实现了同`async/await`一模一样的效果。现在看一下babel或ts对`async/await`是怎么处理的。\n\n周所周知，一些老的浏览器是没法运行es新特性的，所以才需要ts、babel之类的工具来转译代码。还是上面的`async/await`函数的例子，我们看一下它被typescript从es7代码转为es6代码后，变成了什么样子。\n\n> 怎么操作：在webpack.config.js中，关闭sourcemap，ts代码配置用ts-loader加载，在tsconfig.json中配置target为'es6'\n\n![es6转译后代码](../static/assets/async-await-转译.jpg)\n\n可以看到`async/await`函数转为了```()=>__awaiter(this, ..., function* () { ... })```。\n即\\__awaiter函数加`generator`函数，其中`generator`函数代码，和我们上面的例子的代码一模一样。这么推算的话，那\\__awaiter函数估计就和我们上面的例子里的`generatorRunner`功能差不多啦。看看\\__awaiter函数：\n\n![__awaiter函数](../static/assets/async__awaiter.jpg)\n\n可以看到差不太多，只不过多做了一些适配。都是返回Promise，递归处理result，知道done为true。\n\n再往下看的话，比如将代码转为es6之前，会看到`Promise`和`generator`也被转成了低版本的实现，而`async/await`仍然使用同样的代码。或者使用babel去转译，也是一样的。\n\n所以说`async/await`就是个语法糖，它的底层实现就是`Promise` + `generator`，但是耐不住它真的很香，代码非常简洁直观。","slug":"/async-await-intro"},{"id":"9ff8ee79-bdc5-5c17-9c36-0a011d2cc994","title":"用户中心服务","tags":["后端","Node.js","Express"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMEBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe5HRMsD/8QAGhAAAgMBAQAAAAAAAAAAAAAAAQIAAyEQEv/aAAgBAQABBQJsFVvsw7FRV5//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAZEAACAwEAAAAAAAAAAAAAAAABEQACEFH/2gAIAQEABj8CNuRLEYwM/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARIRBB/9oACAEBAAE/IWVloiPjl3fADwY3iXOf/9oADAMBAAIAAwAAABDwD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAQEAAgMBAAAAAAAAAAAAAAERADEQIUFR/9oACAEBAAE/EIoou5iCiA9lHXnDUKET6YgGTsXXH//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/bab3e/login.jpg","srcSet":"/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/51d7e/login.jpg 116w,\n/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/4da4e/login.jpg 231w,\n/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/bab3e/login.jpg 462w,\n/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/0e461/login.jpg 924w","sizes":"(min-width: 462px) 462px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/90c2f/login.avif 116w,\n/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/92e94/login.avif 231w,\n/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/3c154/login.avif 462w,\n/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/996b8/login.avif 924w","type":"image/avif","sizes":"(min-width: 462px) 462px, 100vw"},{"srcSet":"/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/96fa7/login.webp 116w,\n/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/cf0b0/login.webp 231w,\n/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/64ac3/login.webp 462w,\n/leon-blog/static/40575cbc31aaba230ae784aaf2316a48/bcd0c/login.webp 924w","type":"image/webp","sizes":"(min-width: 462px) 462px, 100vw"}]},"width":462,"height":368},"body":"---\ntitle: \"用户中心服务\"\ncover: user-center/login.jpg\ncoverAlt: \"登录方式\"\ndescription: \"用户中心服务提供用户登录、注册、认证、用户信息管理等功能\"\ndatePublished: \"2023-05-08 14:28:03\"\ndateModified: \"2023-05-08 14:28:03\"\ncategory: \"应用项目\"\ntags:\n  - 后端\n  - Node.js\n  - Express\n---\n\n**用户中心服务**提供统一的用户登录、认证服务。\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n\n### 主要功能\n\n1. **登录/注册**\n\n  支持邮箱注册、邮箱验证码、邮箱用户名jwt登录、修改密码。\n  \n  支持关注微信公众号注册/登录、微信扫码注册/登录。\n\n  支持google登录。\n\n2. **用户信息**\n\n  提供对外的api接口，查询、修改、删除用户信息。\n\n3. **扩展认证方式**\n\n  使用passport实现用户认证，可以通过添加passport子组件任意添加其他认证方式。\n\n### 我的职责\n\n1. 用户中心服务开发。\n\n2. API接口设计，遵循RESTful规范。\n\n### 技术实现\n\n1. 使用Express开发服务。\n\n2. 使用passport实现用户认证。\n\n3. db部分使用knex，实现可对接多种类型数据库，同时方便管理库表升级。\n\n4. 发送email设计为plugin模式，方便替换email服务提供商。\n\n5. 使用ioredis添加redis缓存支持。","slug":"/用户中心服务"},{"id":"ec83f676-43bb-51b7-8a66-3a185d4034bb","title":"1h手撸一个PC批量混剪软件","tags":["Node.js","Electron","视频处理"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABg0lEQVQoz6WS20oCURSGfaJeo+foKuiuLiSoq7qoi0AIJCiKyg4XSWlGo2QnKzVFG6c56IyT0AFtRiXoAb6YbSZWBNXFv9f+WXv9rP2v5SuXGlSUZ8qlOoZcp8c78bfwdYurepta+eVDrIf6J/49unU+77DUJtdnCkfxDJr8hKk4VG4d8cjSW5i3LqbWxFRdAUtrirypdqLHu6I+rwNLbROY8uMfHOA4dIBtvlJKVzGKT+SSMkrGRr4032OFYspALzz24rneE6yqLrkrm8XpMaTJYU524ij5e6LBDbJSntWJWaTlXcJzSyTWY+zNr7EbWCEa3GRlfJqMlGd/YYuyXO8I3hktzpI66dAI9uEQ4fU1jBuHi0gKLX9PcitONlHgeDshcBlLk5FyXMXSgnsde9z7uvCw02GNo9AMSngUaSeCpb1gqp6HDlWjLbzyvLS0lrgLH/WWyH142T8Ul0L2gdSpjVF67p+0/MOUP+X61sZSHWzNpaI0/ryD71NufNm9/yz2Gx1gsvwt+Cz1AAAAAElFTkSuQmCC"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/f945c/bing-tool.png","srcSet":"/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/6c0e0/bing-tool.png 184w,\n/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/b5bc4/bing-tool.png 368w,\n/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/f945c/bing-tool.png 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/9d028/bing-tool.avif 184w,\n/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/c6ee4/bing-tool.avif 368w,\n/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/b4627/bing-tool.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/ef27d/bing-tool.webp 184w,\n/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/4ae45/bing-tool.webp 368w,\n/leon-blog/static/f9d31144dbb404d3b15d6b8b17ace9d9/20e6b/bing-tool.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"1h手撸一个PC批量混剪软件\"\ncover: images/bing-tool.png\ncoverAlt: \"封面\"\ndescription: \"小饼混剪助手\"\ndatePublished: \"2023-10-09 17:05:11\"\ndateModified: \"2023-10-09 17:05:11\"\ncategory: \"经验总结\"\ntags:\n  - Node.js\n  - Electron\n  - 视频处理\n---\n\n本文将介绍怎么样使用`electron + ffmpeg`在**1小时内**快速开发一个运营人常用的工具：视频批量混剪工具。\n\n> 混剪工具就是将一个长视频，按照设定的时间，分割成一段一段的视频切片的工具。\n\n### 准备工作\n\n准备好基础环境：\n\n- 安装Node.js（推荐安装nvm，使用nvm安装Node.js，方便后续随时切换Node.js版本）\n- 安装VS code\n- 学习一下javascript语言和ffmpeg知识\n\nDONE！🀄️\n\n### 运行启动模版\n\n使用Electron启动模版快速创建一个桌面端软件。启动模版仓库地址：https://github.com/missmess/electron-template\n\n```shell\n# 进入到要存储项目代码的文件夹内\n# 执行该命令拷贝启动模版到本地\n# (my-project-name)要替换为自己想要的项目名称\nnpx degit missmess/electron-template (my-project-name)\n```\n\n创建完成后如何使用，请参考README。\n\n### 写代码\n\n分析一下需求，需求就是将单个视频按照时间长度，切割成视频切片。单个视频做完之后，批量就简单了，for循环一下就行。\n\n##### ffmpeg命令\n\n首先单个视频如何切片？视频处理我们常用的工具是`ffmpeg`。为了在软件中切片，我们也使用`ffmpeg`去做处理。我们需要知道直接使用ffmpeg程序如何对进行视频切片。\n\n```shell\n# -ss 从视频某位置开始 -t 时长 -i 输入文件 -c copy 复制输入文件的视频格式\n# starttime-切片的开始时间 gap-切片时长 input.mp4-输入视频文件 output.mp4-输出视频文件\nffmpeg -ss (starttime) -t (gap) -i (input.mp4) -c copy (output.mp4)\n```\n\n知道了ffmpeg怎么处理单个视频的切片，后面我们需要将这段代码移植到Node.js上。\n\n##### Node.js上使用ffmpeg\n\nNode.js上比较好用的一个ffmpeg开源库是[Fluent-ffmpeg](https://github.com/fluent-ffmpeg/node-fluent-ffmpeg)。在桌面端代码根目录下，执行`shell`命令安装Fluent-ffmpeg：`npm install fluent-ffmpeg`。\n\nFluent-ffmpeg默认需要电脑上已安装好ffmpeg，并设置好系统环境变量。不过它也支持手动指定ffmpeg的二进制运行库的位置，这才是我们需要的。因为我们不能保证用户电脑上已经安装ffmpeg，所以我们要把ffmpeg打包到我们的软件中。\n\n然后就是安装ffmpeg和ffprobe（ffprobe是一个查询音视频文件基础信息的工具）。在node上希望安装对应系统的ffmpeg和ffprobe工具，也可以使用开源库实现，这样就不需要自己手动下载安装了。\n\n[@ffmpeg-install](https://github.com/kribblo/node-ffmpeg-installer#readme)：自动安装当前系统的ffmpeg运行库，也可以手动安装希望软件可以支持的系统对应的ffmpeg运行库。\n\n[@ffprobe-installer](https://github.com/SavageCore/node-ffprobe-installer#readme)：同上面的`@ffmpeg-install`。用法一模一样。\n\n都安装好后，在`javascript`代码中引入ffmpeg！我们选择在`src/core/eventHandler`中引入，因为我们将在这里接收渲染线程发送过来的“请求切割”事件。也可以新建一个js文件，这样代码规整些。\n\n```javascript\n// eventHandler.js\n...\nconst ffmpegPath = require(\"@ffmpeg-installer/ffmpeg\").path;\nconst ffprobePath = require(\"@ffprobe-installer/ffprobe\").path;\nvar ffmpeg = require(\"fluent-ffmpeg\");\nffmpeg.setFfmpegPath(ffmpegPath);\nffmpeg.setFfprobePath(ffprobePath);\n...\n```\n\nffmpeg和ffprobe现在就可以使用了。接着简单做一下用户界面。\n\n##### 写webUI\n\n按理说，用户界面要写的好看、功能清晰才行，毕竟是软件的门面。不过为了演示我就随便加几个按钮，能演示功能就行。\n\n在/webapps/vue3-webapp/src/views/HomeView中，编辑一下页面内容：一个logo、一个选择批量待处理视频目录的按钮、一个选择保存处理好的视频切片目录的按钮、一个选择切片时长的输入框、一个开始按钮。\n\n对应的按钮操作和文本展示，写在script中：\n\n```html\n<script setup lang=\"ts\">\nimport { ref } from 'vue';\nimport service from '@/NativeService';\n\nconst inputPath = ref(\"\")\nconst outputPath = ref(\"\")\nconst gapValue = ref(5)\n\nvar chooseInputDir = () => {\n  service.chooseDir().then((paths: any) => {\n    if (paths[0]) inputPath.value = paths[0];\n  })\n}\nvar chooseOutputDir = () => {\n  service.chooseDir().then((paths: any) => {\n    if (paths[0]) outputPath.value = paths[0];\n  })\n}\nvar startProcess = () => {\n  console.log('调用混剪功能', inputPath.value, outputPath.value, gapValue.value);\n  if (!inputPath.value || !outputPath.value) {\n    alert('未选择输入文件或输出目录')\n  } else {\n    service.handleVideos(inputPath.value, outputPath.value, gapValue.value)\n  }\n}\n</script>\n\n<template>\n  <div class=\"flex-col flex-middle flex-justify-center container\">\n    <div class=\"content\">\n      <ElDescriptions title=\"🫓 小饼混剪助手\" border :column=\"1\">\n        <ElDescriptionsItem labelClassName=\"label\">\n          <template #label>\n            <ElButton type=\"primary\" style=\"padding: 0;\" text @click=\"chooseInputDir\">源视频目录</ElButton>\n          </template>\n          {{ inputPath || '-' }}\n        </ElDescriptionsItem>\n        <ElDescriptionsItem labelClassName=\"label\">\n          <template #label>\n            <ElButton type=\"primary\" style=\"padding: 0;\" text @click=\"chooseOutputDir\">切片保存目录</ElButton>\n          </template>\n          {{ outputPath || '-' }}\n        </ElDescriptionsItem>\n        <ElDescriptionsItem label=\"视频切片时长\" labelClassName=\"label\">\n          <ElInput v-model=\"gapValue\" placeholder=\"输入视频切片时长\">\n            <template #append>秒</template>\n          </ElInput>\n        </ElDescriptionsItem>\n      </ElDescriptions>\n\n      <div class=\"flex mt-16\">\n        <ElButton type=\"primary\" @click=\"startProcess\">开始混剪</ElButton>\n      </div>\n    </div>\n  </div>\n</template>\n\n<style>\n.container {\n  height: 100vh;\n  background: linear-gradient(180deg, #fcf0ff, #fff 30%);\n}\n.content {\n  width: 520px;\n}\n</style>\n```\n\n其中`service.handleVideos`方法是启动模版里没有的，需要在`/webapps/vue3-webapp/src/types/index`和`/src/wins/preload`中分别添加该方法。并在`/src/core/eventHandler`中注册监听。\n\n```javascript\nipcMain.handle(\"handle-videos\", async (event, data) => {\n  // 执行批量剪辑\n}\n```\n\nUI做完后效果如下：\n\n![](./images/bing-tool-home.jpg)\n\n##### node-ffmpeg实现单视频剪辑\n\n先实现单视频剪辑，分为两步：\n\n1. **获取视频总时长**\n\n    通过node-ffprobe获取视频信息，并根据时长递归的处理视频切割。\n\n    ```javascript\n    function handleSingleFile(finput, foutput, gap) {\n      ffmpeg.ffprobe(finput, function (err, metadata) {\n        const duration = metadata.format.duration;\n        console.log(\"获取到视频时长\", duration);\n\n        let index = 0;\n        while (index * gap < duration) {\n          videoSplit(index, gap);\n          index++;\n        }\n      });\n      ...\n    }\n    ```\n\n2. **切割视频**\n\n    前面我们知道了怎么使用ffmpeg命令进行视频切片，现在我们将命令转译到node上。\n\n    ```javascript\n    function videoSplit(index, gap) {\n      console.log(\"剪辑片段：\", index, gap);\n      const start = gap * index;\n      ffmpeg(finput)\n        .inputOptions([`-ss ${start}`, `-t ${gap}`])\n        .outputOptions(\"-c copy\")\n        .output(foutput + `/output-${index + 1}.mp4`)\n        .on(\"progress\", function (progress) {\n          console.log(\"正在执行: \", progress);\n        })\n        .on(\"end\", function () {\n          console.log(\"执行结束\");\n        })\n        .run();\n    }\n    ```\n\n到此，单个视频切割已经ok。👌\n\n##### 实现批量\n\n批量就比较简单，只需要读取输入目录下，全部文件即可。\n\n```javascript\n// 监听并处理批量切割\nipcMain.handle(\"handle-videos\", async (event, { inputDir, outputDir, gap }) => {\n  // 通过fs读取目录\n  const files = fs.readdirSync(inputDir);\n  // 循环执行\n  for (let i = 0; i < files.length; i++) {\n    const file = files[i];\n    const fname = file.substring(0, file.lastIndexOf(\".\"));\n    const output = `${outputDir}/${fname}`\n    fs.mkdirSync(output)\n    await handleSingleFile(`${inputDir}/${file}`, output, gap);\n  }\n});\n```\n\n### 打包\n\n利用启动模版的打包命令即可打包成最终的桌面软件啦～\n\n```shell\n# 打包webUI\nnpm run webBuild\n# 打包软件\nnpm run make\n```\n\n### 优化建议\n\n到这里，一个基础的批量混剪工具就完成啦！\n\n不过整个软件目前也只是能正常跑通流程，还是有很多bug和优化需要去解决。比如：\n\n1. 单视频文件分割，还可以使用`segment muxer`来实现。比递归切割效率要高一些。\n\n2. 输入目录下不一定全部都是视频文件，非视频文件需要过滤掉\n\n3. 如果处理过程出现任何异常，应该通知到界面上。\n\n4. 界面需要实时显示处理进度。处理视频比较耗时，如果不显示进度，会让人误以为软件卡死了。\n","slug":"/1-h手撸一个-pc批量混剪软件"},{"id":"19929436-e74a-569d-8c7f-a821831d3edd","title":"优优小班-日志sdk","tags":["Android端","Java","iOS端","Hybrid","库","架构"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHJakCLBf/EABYQAAMAAAAAAAAAAAAAAAAAAAARIP/aAAgBAQABBQKUf//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABQQAQAAAAAAAAAAAAAAAAAAACD/2gAIAQEABj8CX//EABkQAAEFAAAAAAAAAAAAAAAAABAAARFBUf/aAAgBAQABPyE2IYy//9oADAMBAAIAAwAAABDPz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/ECf/xAAdEAACAQQDAAAAAAAAAAAAAAAAASExcYGRQVFh/9oACAEBAAE/EEpV+jjJPukhU3FTAmqdR//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/d86fc/bmlog.jpg","srcSet":"/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/f79c9/bmlog.jpg 150w,\n/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/97f4b/bmlog.jpg 300w,\n/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/d86fc/bmlog.jpg 600w","sizes":"(min-width: 600px) 600px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/5d94b/bmlog.avif 150w,\n/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/33d17/bmlog.avif 300w,\n/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/509fc/bmlog.avif 600w","type":"image/avif","sizes":"(min-width: 600px) 600px, 100vw"},{"srcSet":"/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/30e85/bmlog.webp 150w,\n/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/60d3f/bmlog.webp 300w,\n/leon-blog/static/fcfa9c1e84a0c2f547c59e039008a322/0534a/bmlog.webp 600w","type":"image/webp","sizes":"(min-width: 600px) 600px, 100vw"}]},"width":600,"height":300},"body":"---\ntitle: \"优优小班-日志sdk\"\ncover: banma/bmlog.jpg\ncoverAlt: \"封面\"\ndescription: \"用于优优小班的app内日志上传\"\ndatePublished: \"2020-05-08 13:02:01\"\ndateModified: \"2020-05-08 13:02:01\"\ncategory: \"框架工具\"\ntags:\n  - Android端\n  - Java\n  - iOS端\n  - Hybrid\n  - 库\n  - 架构\n---\n\n**用于优优小班课app内的日志收集及上报。**\n\n### 架构\n\nAndroid和iOS原生开发日志sdk。sdk实现功能大概列为：\n\n1. 日志sdk设计为单例模式。\n\n2. 支持字符串、文件、图片上报。\n\n3. 字符串支持tag和日志内容，自动追加时间戳和基础信息。字符串也会写入文件。\n\n4. 日志设计为三级缓存：\n\n    a. 内存缓存。日志push后先存入内存，达到一定数量或达到一定时间间隔或主动调用flush方法，刷入文件缓存。\n\n    b. 文件缓存。日志文件存储日志内容，调用upload方法上传oss。\n\n    c. oss存储。日志文件或其他文件或图片上报最终上传到oss。\n\n### 使用方法\n\n1. 初始化传入context，并设置oss参数\n\n```java\nBmLog.getInstance().init(context);\n\nBmLog.getInstance().setOssConfig(xxxx);\n```\n\n2. 写入日志或图片或文件\n\n```java\nBmLog.getInstance().push(\"TAG\", \"LOG\");\n```\n\n3. upload主动上传oss\n\n```java\nBmLog.getInstance().upload();\n```","slug":"/优优小班-日志sdk"},{"id":"cee941ee-f614-58f0-9509-f88100b2d6e1","title":"云学习","tags":["Android端","Java","组件化"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQT/xAAWAQEBAQAAAAAAAAAAAAAAAAACAwT/2gAMAwEAAhADEAAAAe7apnrAcR//xAAYEAADAQEAAAAAAAAAAAAAAAAAAQISMf/aAAgBAQABBQLCMoqULiK7/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAEC/9oACAEDAQE/AVy//8QAFhEBAQEAAAAAAAAAAAAAAAAAAAEC/9oACAECAQE/AU0//8QAFxAAAwEAAAAAAAAAAAAAAAAAABAxAf/aAAgBAQAGPwKEer//xAAbEAACAgMBAAAAAAAAAAAAAAAAATGREEFRcf/aAAgBAQABPyFcVDXpQi4VEBP1g//aAAwDAQACAAMAAAAQAw//xAAXEQADAQAAAAAAAAAAAAAAAAAAARFB/9oACAEDAQE/EE8KO0//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAECAQE/EG9IqQ//xAAdEAEAAQMFAAAAAAAAAAAAAAABABEh0TFBUYGh/9oACAEBAAE/ECBVbGzEwwxBIaXCeAiWosX9Z//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/483b8/xes_cloudlearning.jpg","srcSet":"/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/9fa5a/xes_cloudlearning.jpg 184w,\n/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/63e75/xes_cloudlearning.jpg 368w,\n/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/483b8/xes_cloudlearning.jpg 735w","sizes":"(min-width: 735px) 735px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/9d028/xes_cloudlearning.avif 184w,\n/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/c6ee4/xes_cloudlearning.avif 368w,\n/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/6f2e7/xes_cloudlearning.avif 735w","type":"image/avif","sizes":"(min-width: 735px) 735px, 100vw"},{"srcSet":"/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/ef27d/xes_cloudlearning.webp 184w,\n/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/4ae45/xes_cloudlearning.webp 368w,\n/leon-blog/static/e87c74bd9e24b7c44aacbd0adb49682c/51181/xes_cloudlearning.webp 735w","type":"image/webp","sizes":"(min-width: 735px) 735px, 100vw"}]},"width":735,"height":368},"body":"---\ntitle: \"云学习\"\ncover: xes/xes_cloudlearning.jpg\ncoverAlt: \"封面\"\ndescription: \"学而思云学习\"\ndatePublished: \"2018-05-29 10:22:31\"\ndateModified: \"2018-05-29 10:22:31\"\ncategory: \"应用项目\"\ntags:\n  - Android端\n  - Java\n  - 组件化\n---\n\n学而思云学习，包含在线答题，实时批改，错题订正，金币激励等。\n\n---\n\n#### 技术特点\n\n1. 使用Java语言开发。\n\n2. 使用ARouter实现组件化开发。组件可单独运行、调试。\n\n3. EventBus实现组件间通讯。\n\n4. 使用OkHttp作为网络请求框架。\n\n5. UI框架基于MessUi。","slug":"/云学习"},{"id":"38323471-62cd-5fc1-9041-440228886549","title":"优优小班-课件容器","tags":["前端","React","Hybrid","架构"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHsQvqoIh//xAAZEAEAAwEBAAAAAAAAAAAAAAABAAIxETP/2gAIAQEAAQUCZW70Yeppv//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/AWf/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAABBQEAAAAAAAAAAAAAAAAAAQIRMXEQ/9oACAEBAAY/AlWCoKHZx2n/xAAZEAEBAAMBAAAAAAAAAAAAAAABEQAxQRD/2gAIAQEAAT8hrYHFwpduIWJru5ocj23/2gAMAwEAAgADAAAAEGDv/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAEx/9oACAEDAQE/ENJX/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQAx/9oACAECAQE/EDJL/8QAGxABAQADAQEBAAAAAAAAAAAAAREAIUExceH/2gAIAQEAAT8QVAsza1nScwAHFR1+43L00N0eYlQ3wcwDCCTDBNAtHwz/2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/c1f97/courseware_cover.jpg","srcSet":"/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/0fc87/courseware_cover.jpg 180w,\n/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/58413/courseware_cover.jpg 360w,\n/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/c1f97/courseware_cover.jpg 719w","sizes":"(min-width: 719px) 719px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/5b324/courseware_cover.avif 180w,\n/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/e560f/courseware_cover.avif 360w,\n/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/606dd/courseware_cover.avif 719w","type":"image/avif","sizes":"(min-width: 719px) 719px, 100vw"},{"srcSet":"/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/2ede6/courseware_cover.webp 180w,\n/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/8f3c2/courseware_cover.webp 360w,\n/leon-blog/static/a95f4a85b02d625c1a093ecf85fa3c2c/59b89/courseware_cover.webp 719w","type":"image/webp","sizes":"(min-width: 719px) 719px, 100vw"}]},"width":719,"height":368},"body":"---\ntitle: \"优优小班-课件容器\"\ncover: banma/courseware_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"优优小班H5课件容器\"\ndatePublished: \"2020-04-01 14:27:18\"\ndateModified: \"2020-04-01 14:27:18\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - Hybrid\n  - 架构\n---\n\n课件容器是一个用于**windows、Android、iOS、H5端**加载和控制**cocos游戏、ppt文档、h5课件、普通图片文档**的中间层。\n\n---\n\n### 架构\n\n![架构设计](./banma/courseware_arch.jpg)\n\n- 课件容器整体使用React开发，运行在各个端的webview或者iframe中\n\n- AppSocket处理与各端的双向通信问题\n\n- RoomSdk作为课件容器的sdk，供各类型课件的wb（白板）调用\n\n- 每种类型的课件有自己的wb（白板）实现类，在这里处理课件规范，并与课件双向通信\n\n### 为什么需要？\n\n课件需要呈现的端较多，研发课件的时候需要考虑如何去和每个端交互。\n\n端要支持的课件类型也很多，端研发的时候也要考虑每种类型的课件该如何处理。\n\n所以研发一个中间层：这个中间层解决与各个端的通信问题，统一交互规范；这个中间层需要支持各个类型课件，处理每种课件的交互方式，抹平差异，统一接口到端。\n也就是课件容器。\n\n### 项目价值\n\n1. 端研发不需要关心课件是什么，只需要：*a. 提供原生能力的api以供课件调用；b. 根据规范调用api操作课件。*\n\n2. 各个课件研发不需要关心运行在哪里，只需要：*a.根据规范实现接口，实现课件控制；b. 调用原生能力api实现自己的需求。*\n\n3. 后续如果想新增端、或者支持新的课件类型，不需要修改任何端、任何课件，只需要在**课件容器**中修改即可。","slug":"/优优小班-课件容器"},{"id":"bce70e57-581e-5ac8-b4d2-5426d9e84872","title":"深杨跨境电商","tags":["小程序","云开发","后端","serverless"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAEDBAX/xAAUAQEAAAAAAAAAAAAAAAAAAAAC/9oADAMBAAIQAxAAAAHtSqI0hP8A/8QAGhABAAEFAAAAAAAAAAAAAAAAATEAAhAREv/aAAgBAQABBQKHrF8Abr//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPwFZ/8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQIBAT8Bp//EABgQAAIDAAAAAAAAAAAAAAAAABAxAAFR/9oACAEBAAY/Asjoof/EABsQAAMAAgMAAAAAAAAAAAAAAAABESExEEFx/9oACAEBAAE/Idzcrtsin6KmlVyQcN8f/9oADAMBAAIAAwAAABDMz//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPxBRyf/EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAgEBPxBwz//EABoQAQEBAQEBAQAAAAAAAAAAAAERACExYaH/2gAIAQEAAT8QV6aQ4n9wkCKwLiw4vzRSiilmufAJzxzv/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/ec858/cover.jpg","srcSet":"/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/d1ad9/cover.jpg 175w,\n/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/e1a35/cover.jpg 350w,\n/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/ec858/cover.jpg 700w","sizes":"(min-width: 700px) 700px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/bc552/cover.avif 175w,\n/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/ba093/cover.avif 350w,\n/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/c80ce/cover.avif 700w","type":"image/avif","sizes":"(min-width: 700px) 700px, 100vw"},{"srcSet":"/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/1bd3c/cover.webp 175w,\n/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/69899/cover.webp 350w,\n/leon-blog/static/ae707a7ca16e85ebd6410c1a0297374e/0a01d/cover.webp 700w","type":"image/webp","sizes":"(min-width: 700px) 700px, 100vw"}]},"width":700,"height":348},"body":"---\ntitle: \"深杨跨境电商\"\ncover: shenyang/cover.jpg\ncoverAlt: \"封面\"\ndescription: \"深杨跨境电商是一个招商小程序\"\ndatePublished: \"2022-03-25 16:30:20\"\ndateModified: \"2022-03-25 16:30:20\"\ncategory: \"应用项目\"\ntags:\n  - 小程序\n  - 云开发\n  - 后端\n  - serverless\n---\n\n**深杨跨境电商**是一个招商小程序。\n\n---\n\n### 技术实现\n\n1. 使用微信开发者工具开发。\n\n2. 使用微信官方语言js、wxss、wxml开发。\n\n3. 后端使用腾讯云开发，serverless，接口使用云函数，db使用云数据库。\n\n### 截图\n\n![添加商品](./shenyang/mine_add.jpg)\n![入住信息](./shenyang/mine_info.jpg)\n![商家入驻](./shenyang/company.jpg)\n![个人入驻](./shenyang/individual.jpg)","slug":"/深杨跨境电商"},{"id":"231b15b9-aae2-5a9f-9467-bca0faaa87d1","title":"天天花园","tags":["Unity","Android端","Java","游戏"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAIDBP/EABYBAQEBAAAAAAAAAAAAAAAAAAIABP/aAAwDAQACEAMQAAAB7VVZJamf/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAERAhL/2gAIAQEAAQUCqKhKnGTjIlF//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEREv/aAAgBAwEBPwFYIj//xAAYEQACAwAAAAAAAAAAAAAAAAAAAQISQf/aAAgBAgEBPwFuWFmf/8QAFhABAQEAAAAAAAAAAAAAAAAAEDEA/9oACAEBAAY/AmaH/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAERITGh/9oACAEBAAE/IdIW4iDBsbb6PIIgj//aAAwDAQACAAMAAAAQaw//xAAZEQACAwEAAAAAAAAAAAAAAAAAAREhMaH/2gAIAQMBAT8QeFzwbHWH/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAEhEf/aAAgBAgEBPxBusLKn/8QAHBABAQACAgMAAAAAAAAAAAAAAREAITFBUXGB/9oACAEBAAE/EJaLaHswDeQ1fOUHoxwEC8tuMXX6cJDAz//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/2b40b/cover.jpg","srcSet":"/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/2a0f7/cover.jpg 173w,\n/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/27865/cover.jpg 347w,\n/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/2b40b/cover.jpg 693w","sizes":"(min-width: 693px) 693px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/97b7c/cover.avif 173w,\n/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/7b270/cover.avif 347w,\n/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/5a984/cover.avif 693w","type":"image/avif","sizes":"(min-width: 693px) 693px, 100vw"},{"srcSet":"/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/a378c/cover.webp 173w,\n/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/51f2b/cover.webp 347w,\n/leon-blog/static/8f8e3cc986ad2a11461468d610071b53/c61dc/cover.webp 693w","type":"image/webp","sizes":"(min-width: 693px) 693px, 100vw"}]},"width":693,"height":368},"body":"---\ntitle: \"天天花园\"\ncover: dailygarden/cover.jpg\ncoverAlt: \"封面\"\ndescription: \"天天花园是一款种花网赚类休闲游戏\"\ndatePublished: \"2021-07-09 10:18:23\"\ndateModified: \"2021-07-09 10:18:23\"\ncategory: \"应用项目\"\ntags:\n  - Unity\n  - Android端\n  - Java\n  - 游戏\n---\n\n天天花园是一款种花网赚类休闲游戏。\n\n---\n\n### 主要功能\n\n- 种花玩法，为花浇水、投入阳光。一定时间后可升级花。不断升级得现金奖励。\n\n- 累计经验值可提升王冠等级，升级后可得现金奖励。\n\n- 现金转盘等其他玩法。\n\n- 现金奖励累积到一定程度可以提现。支持微信支付。\n\n- app内会出现开屏广告、插屏广告、激励广告。\n\n### 我的职责\n\n1. 负责项目研发。\n\n2. 负责Android端的开发。\n\n3. 负责部分unity游戏内容的开发。\n\n4. 接入Gromore sdk广告sdk，实现广告播放逻辑。\n\n### 技术实现\n\n1. 游戏本体使用unity开发，支持热更新。\n\n2. Android端使用原生开发。包含开屏页、隐私协议、设备权限、开屏广告、防沉迷认证、检查更新、微信登录等。\n\n3. unity导出资源后，在Android容器中运行，在隐私等条款弹窗结束后，合适的时机初始化。\n\n4. unity点击提现，调用Android暴露的接口，唤起微信支付sdk。\n\n5. 广告部分接入Gromore。\n\n### 截图\n\n![](./dailygarden/garden.jpg)\n![](./dailygarden/plants.jpg)\n![](./dailygarden/task.jpg)","slug":"/天天花园"},{"id":"b525e969-331d-58e8-8693-44e1ca8c94e5","title":"和平守护者","tags":["跨平台","Android端","iOS端","Flutter","dart","游戏","Koa","Node.js"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFQABAQAAAAAAAAAAAAAAAAAAAgD/xAAWAQEBAQAAAAAAAAAAAAAAAAABBAX/2gAMAwEAAhADEAAAAWjV54nJ/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAECERIg/9oACAEBAAEFAkkZgVx//8QAFREBAQAAAAAAAAAAAAAAAAAAEBH/2gAIAQMBAT8Bp//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABkQAAEFAAAAAAAAAAAAAAAAAAABICEyof/aAAgBAQAGPwKVLY3/xAAZEAACAwEAAAAAAAAAAAAAAAABIQAgQYH/2gAIAQEAAT8hPy5AhhU//9oADAMBAAIAAwAAABAY7//EABYRAQEBAAAAAAAAAAAAAAAAAAEQQf/aAAgBAwEBPxABk//EABcRAAMBAAAAAAAAAAAAAAAAAAABEVH/2gAIAQIBAT8Qd0p//8QAGhABAQACAwAAAAAAAAAAAAAAAREAIDFBUf/aAAgBAQABPxA5VYkCqd4pq7nxq//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/56675/cover.jpg","srcSet":"/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/9fa5a/cover.jpg 184w,\n/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/2a971/cover.jpg 367w,\n/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/56675/cover.jpg 734w","sizes":"(min-width: 734px) 734px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/9d028/cover.avif 184w,\n/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/fcbd2/cover.avif 367w,\n/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/61ef5/cover.avif 734w","type":"image/avif","sizes":"(min-width: 734px) 734px, 100vw"},{"srcSet":"/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/ef27d/cover.webp 184w,\n/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/6963a/cover.webp 367w,\n/leon-blog/static/3cd55b97749486bcd911c7844efc8d24/bce1f/cover.webp 734w","type":"image/webp","sizes":"(min-width: 734px) 734px, 100vw"}]},"width":734,"height":368},"body":"---\ntitle: \"和平守护者\"\ncover: defender/cover.jpg\ncoverAlt: \"封面\"\ndescription: \"和平守护者\"\ndatePublished: \"2021-09-03 10:49:39\"\ndateModified: \"2021-09-03 10:49:39\"\ncategory: \"应用项目\"\ntags:\n  - 跨平台\n  - Android端\n  - iOS端\n  - Flutter\n  - dart\n  - 游戏\n  - Koa\n  - Node.js\n---\n\nFlutter制作的跨平台小游戏。通过点击天空来的陨石来保护家园。\n\n---\n\n### 技术实现\n\n1. 使用flutter开发，material主题。\n\n2. 背景音乐使用audioPlayer。\n\n3. 动画使用AnimationController。\n\n4. server端使用koa2框架开发接口，mysql数据库。\n\n### 截图\n\n![](./defender/home.jpg)\n![](./defender/intro.jpg)\n![](./defender/game.jpg)","slug":"/和平守护者"},{"id":"1742f1d1-376d-5a10-8b2b-f70f1525608e","title":"dmp作业开发后台","tags":["前端","React","微前端","模块联邦"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQF/8QAFQEBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdVSQF//xAAXEAADAQAAAAAAAAAAAAAAAAABAgMg/9oACAEBAAEFArGiqlgwx//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABsQAAEEAwAAAAAAAAAAAAAAAAEAAxEgITGB/9oACAEBAAY/ApbytEcr/8QAGhAAAgIDAAAAAAAAAAAAAAAAAREAICExYf/aAAgBAQABPyFbgmwniMXcDV//2gAMAwEAAgADAAAAEITP/8QAFhEAAwAAAAAAAAAAAAAAAAAAEBEh/9oACAEDAQE/EFR//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGhABAQACAwAAAAAAAAAAAAAAAREQUQAhwf/aAAgBAQABPxAy0ffR2ORWKCYj6ZF3j//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/772ab/dmp.jpg","srcSet":"/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/08ce2/dmp.jpg 110w,\n/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/dc133/dmp.jpg 219w,\n/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/772ab/dmp.jpg 438w","sizes":"(min-width: 438px) 438px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/e00b2/dmp.avif 110w,\n/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/5e27a/dmp.avif 219w,\n/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/0c327/dmp.avif 438w","type":"image/avif","sizes":"(min-width: 438px) 438px, 100vw"},{"srcSet":"/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/42796/dmp.webp 110w,\n/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/b261e/dmp.webp 219w,\n/leon-blog/static/0b0799d7ce078d63ad3028f0e7bee7fa/e47f1/dmp.webp 438w","type":"image/webp","sizes":"(min-width: 438px) 438px, 100vw"}]},"width":438,"height":220},"body":"---\ntitle: \"dmp作业开发后台\"\ncover: lixiang/dmp.jpg\ncoverAlt: \"封面\"\ndescription: \"理想汽车大数据作业开发平台\"\ndatePublished: \"2023-01-09 08:44:38\"\ndateModified: \"2023-01-09 08:44:38\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - 微前端\n  - 模块联邦\n---\n\n理想汽车大数据作业开发平台，目标用户是大数据工程师，通过在线编辑sparksql、hive等作业的代码，参与到后续的调度等流程中。\n\n### 主要功能\n\n- 支持sparksql、hive、shell、sparkJar等类型的作业，在编辑器中在线编辑、测试、调试并实时显示日志。\n\n- 支持各类型作业编辑作业信息、调度信息、查看历史版本、发布上线。\n\n- 支持其他业务如数据调度、数据查询等提供的组件，显示在内容区的某个tab下。\n\n### 技术特点\n\n- 基于React、craco开发。\n\n- 项目中使用到的很多组件来自于公共组件、或其他项目中的组件。通过使用module federation方案实现组件共享，页面微前端。\n\n- 作业开发页面，使用mosaic组件，实现类似于vscode的交互，页面元素分区域、可拖动、可隐藏。\n\n- 作业内容区域，需要展示各种标签页，这些标签页除了作业开发内的组件，通过mf方案，可以加载其他项目提供的组件。\n\n- 所有的tab相关数据都在本地存储，使用zustand实现全局workbench状态共享，针对作业的任何信息编辑都是编辑状态。\n\n- 使用rxdb实现本地数据库（原来使用的是localStorage），zustand的变化也会延迟同步到rxdb中。\n\n- 使用monaco实现编辑器部分，并添加了sparksql、log等语言的语法支持、高亮、错误提示等。并支持语言服务懒加载。\n\n- 使用ramda函数式编程规范。","slug":"/dmp作业开发后台"},{"id":"19c978cc-7318-546d-86d1-153654d275d3","title":"袋鼠小班后台系统","tags":["前端","Vue2","ElementUI"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAYBAv/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHjaFZOKMf/xAAXEAADAQAAAAAAAAAAAAAAAAAAAxQg/9oACAEBAAEFAp2E7CduP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/Aar/xAAXEAADAQAAAAAAAAAAAAAAAAAAATIg/9oACAEBAAY/AoZDIx//xAAcEAABBAMBAAAAAAAAAAAAAAABABEhYSBBcZH/2gAIAQEAAT8hDssUQoNvQrXow//aAAwDAQACAAMAAAAQ1x//xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxCI/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxAP/8QAHhAAAQMEAwAAAAAAAAAAAAAAAAERsRAhMUGRwfD/2gAIAQEAAT8QnuEi4lttl+T1ndEFP//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/ecb29/dsxb_back_cover.jpg","srcSet":"/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/3281a/dsxb_back_cover.jpg 186w,\n/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/3f3c9/dsxb_back_cover.jpg 372w,\n/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/ecb29/dsxb_back_cover.jpg 744w","sizes":"(min-width: 744px) 744px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/1043a/dsxb_back_cover.avif 186w,\n/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/75542/dsxb_back_cover.avif 372w,\n/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/069c4/dsxb_back_cover.avif 744w","type":"image/avif","sizes":"(min-width: 744px) 744px, 100vw"},{"srcSet":"/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/b2901/dsxb_back_cover.webp 186w,\n/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/f2d3a/dsxb_back_cover.webp 372w,\n/leon-blog/static/2a10ed019f78bcc49b090ea3441825df/2064b/dsxb_back_cover.webp 744w","type":"image/webp","sizes":"(min-width: 744px) 744px, 100vw"}]},"width":744,"height":368},"body":"---\ntitle: \"袋鼠小班后台系统\"\ncover: banma/dsxb_back_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"袋鼠小班后台系统\"\ndatePublished: \"2019-04-15 16:20:27\"\ndateModified: \"2019-04-15 16:20:27\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - Vue2\n  - ElementUI\n---\n\n袋鼠小班/优优小班后台管理系统。包括课程、课堂、班级、课时、订单、素材、转介绍、团购等等。\n\n---\n\n### 我的职责\n\n1. 负责技术选型、框架搭建、一期项目开发。\n\n2. 后续部分功能维护。\n\n3. 团队管理。\n\n### 技术点\n\n1. 基于webpack、vue2\n\n2. axios请求框架\n\n3. echarts图表绘制\n\n4. katex数学公式绘制\n\n5. lottie播放动效\n\n6. quill富文本编辑\n\n### 截图\n\n![登录](./banma/dsxb_back_login.png)\n\n![素材管理](./banma/dsxb_back_content.png)","slug":"/袋鼠小班后台系统"},{"id":"a7842ae7-d84d-5e9a-835b-628f0922adf9","title":"袋鼠小班","tags":["Android端","Java","iOS端","Windows端","Hybrid","React","组件化"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAQX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAAB7s1mQg5X/8QAGhABAAEFAAAAAAAAAAAAAAAAAQACAxAREv/aAAgBAQABBQJ3O7koVM//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAXEAADAQAAAAAAAAAAAAAAAAAAICEx/9oACAEBAAY/AoYVP//EABkQAAIDAQAAAAAAAAAAAAAAAAARASAhMf/aAAgBAQABPyGT4g2SjD1T/9oADAMBAAIAAwAAABBbz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAQEBAAAAAAAAAAAAAAAAAAEQEf/aAAgBAgEBPxAMn//EAB0QAQABAwUAAAAAAAAAAAAAAAERACFBIDFRYXH/2gAIAQEAAT8QsKgiVYzVyI9hTv3igYhNGCM6P//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/483b8/dsxb_cover.jpg","srcSet":"/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/9fa5a/dsxb_cover.jpg 184w,\n/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/63e75/dsxb_cover.jpg 368w,\n/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/483b8/dsxb_cover.jpg 735w","sizes":"(min-width: 735px) 735px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/9d028/dsxb_cover.avif 184w,\n/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/c6ee4/dsxb_cover.avif 368w,\n/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/6f2e7/dsxb_cover.avif 735w","type":"image/avif","sizes":"(min-width: 735px) 735px, 100vw"},{"srcSet":"/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/ef27d/dsxb_cover.webp 184w,\n/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/4ae45/dsxb_cover.webp 368w,\n/leon-blog/static/6813b8dedf0ef785634fc21ad7ef497a/51181/dsxb_cover.webp 735w","type":"image/webp","sizes":"(min-width: 735px) 735px, 100vw"}]},"width":735,"height":368},"body":"---\ntitle: \"袋鼠小班\"\ncover: banma/dsxb_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"K12教育直播课产品\"\ndatePublished: \"2019-05-08 09:43:48\"\ndateModified: \"2019-05-08 09:43:48\"\ncategory: \"应用项目\"\ntags:\n  - Android端\n  - Java\n  - iOS端\n  - Windows端\n  - Hybrid\n  - React\n  - 组件化\n---\n\n袋鼠小班是K12教育直播课产品。包含学生端和教师端。\n\n学生端为上课端，包含登录、课表、直播课堂页等。支持Android、iphone、ipad、Windows。\n\n教师端为授课端，包含登录、课程计划、直播课堂页、备课等。支持Windows。\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n1. 老师查看自己的课程计划，提前进入课堂备课，到点进入课堂授课。\n\n2. 学生查看自己的课表，到点可以进入课堂上课。\n\n3. 课堂形式支持1vs16的小班课，也支持大班课，大班课最多订阅16位学生的视频流。\n\n4. 老师支持所有课堂操作，包括控制学生音视频流静音关闭开启等、拖动学生上下台、发送奖杯、计时器、答题器、播放/切换课件、播放动画、允许学生操作课件、允许玩游戏等等。\n\n5. 学生端支持全部操作和组件的展示，支持部分组件的交互如答题器、玩游戏课件等等。\n\n6. 课件支持cocos课件、答题课件、其他h5课件、图片、ppt、word/pdf文档、音频课件、视频课件。\n\n7. 监课端为web端，可以支持查看课堂，具有全部的操作权限。\n\n### 我的职责\n\n1. 负责Android学生端、Windows学生端/教师端的开发工作。\n\n2. 负责三方音视频云服务的技术选型和技术对接工作。\n\n3. 项目中重难点技术方案的设计：\n\n    - 复杂交互组件答题器的设计。\n    - 发奖杯逻辑设计。\n    - 游戏课件交互规范。\n    - 游戏课件交互蒙层设计。\n    - 性能优化：学生音视频二路流优化。\n    - 等等。\n\n4. 负责开发团队的管理。\n\n### 技术实现\n\n1. Android端基于Java、MessUi、Retrofit等。\n\n2. Windows端基于Qt开发，套课web页面，核心功能为web开发，基于React。\n\n3. iOS端基于oc、pod。\n\n4. 学生/教师音视频相互订阅、流控制、信令服务使用talkcloud sdk。\n\n5. 直播课堂主要使用EventBus接收信令事件，并发送到各个组件。\n\n### 截图\n\n![学生手机端课表](./banma/xb_course_m.jpg)\n![学生手机端课堂](./banma/xb_class_m.jpg)\n![教师端登录页](./banma/xb_login.jpg)\n![教师端课程计划](./banma/xb_course_plan.jpg)\n![教师端Windows端课堂](./banma/xb_class_windows.jpg)\n![教师端画笔工具](./banma/xb_wb.jpg)","slug":"/袋鼠小班"},{"id":"cfe27eb1-a935-581a-a0d4-d7fa6f203e3f","title":"DV试验上位机","tags":["Electron","Node.js","Vue3","ElementUI","前端","Windows端","跨平台","Vite"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABnrxLs1A4P//EABwQAAIABwAAAAAAAAAAAAAAAAEDAAIEEBIUIf/aAAgBAQABBQJC1MjXp7yAYkd//8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQMBAT8BV//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAECAQE/AUf/xAAcEAABAwUAAAAAAAAAAAAAAAAAARAxAhETM6L/2gAIAQEABj8CXJXY29EtDf/EABsQAAICAwEAAAAAAAAAAAAAAAERADEQIUGh/9oACAEBAAE/IRFSlsBxFeErnCkpAcCf/9oADAMBAAIAAwAAABBTL//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/EKp//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERQf/aAAgBAgEBPxBLCT//xAAbEAEBAQEAAwEAAAAAAAAAAAABEQAhMYGhsf/aAAgBAQABPxBkNsG0Nr3IG9BeL8m5wn6cbyoIVmtflv/Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/483b8/dveol_cover.jpg","srcSet":"/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/9fa5a/dveol_cover.jpg 184w,\n/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/63e75/dveol_cover.jpg 368w,\n/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/483b8/dveol_cover.jpg 735w","sizes":"(min-width: 735px) 735px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/9d028/dveol_cover.avif 184w,\n/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/c6ee4/dveol_cover.avif 368w,\n/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/6f2e7/dveol_cover.avif 735w","type":"image/avif","sizes":"(min-width: 735px) 735px, 100vw"},{"srcSet":"/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/ef27d/dveol_cover.webp 184w,\n/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/4ae45/dveol_cover.webp 368w,\n/leon-blog/static/d5d158f7d6db31da11c49689fc3fe327/51181/dveol_cover.webp 735w","type":"image/webp","sizes":"(min-width: 735px) 735px, 100vw"}]},"width":735,"height":368},"body":"---\ntitle: \"DV试验上位机\"\ncover: lixiang/dveol_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"理想汽车DV试验上位机\"\ndatePublished: \"2021-10-14 17:57:09\"\ndateModified: \"2021-10-14 17:57:09\"\ncategory: \"应用项目\"\ntags:\n  - Electron\n  - Node.js\n  - Vue3\n  - ElementUI\n  - 前端\n  - Windows端\n  - 跨平台\n  - Vite\n---\n\nDV试验上位机是用于车机设备运行硬件测试的windows端应用。试验台通过mesh网络搜索车机设备，对车机设备上的硬件组件测试项进行串联/并联测试。\n\n---\n\n### 技术点\n\n1. 桌面端使用electron、Node.js实现跨平台开发。支持windows、linux、mac。\n\n2. 使用electron-forge打包应用程序。\n\n3. ui层使用vue3、vite、element-ui开发，打包静态应用后放入www目录。\n\n4. 遵循electron最新[process sandbox规则](https://www.electronjs.org/docs/latest/tutorial/sandbox)，防止安全性问题。ui与node层通过IPC通信。*（ui层无法访问node.js的api，preload.js暴露对象到ui层window，preload.js通过IpcRender与IpcMain进行通信）*\n\n5. 上位机通过limesh搜寻、连接、操作设备。\n\n6. node层通过crashReporter、log4j采集本地cpu、memory日志做性能分析。\n\n7. ui层使用el-table实现表格布局形式的测试界面。\n\n8. ui层使用html2canvas实现定期截屏测试项状态。\n\n### 截图\n\n![连接设备](./lixiang/dveol_home.jpg)\n![测试项测试](./lixiang/dveol_test.jpg)","slug":"/dv试验上位机"},{"id":"9a83e8b5-c74e-54c3-b594-c8d90d6d5cb9","title":"electron-template","tags":["Node.js","Electron","脚手架","开源","Vue3","Vite","跨平台"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAABAAF/8QAFwEAAwEAAAAAAAAAAAAAAAAAAQIDBP/aAAwDAQACEAMQAAABe0OixyI1bT//xAAbEAABBAMAAAAAAAAAAAAAAAABAAMEMwISIf/aAAgBAQABBQKKAW9QnOZwqE/d/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARIf/aAAgBAwEBPwFewGX/xAAZEQABBQAAAAAAAAAAAAAAAAAAAQIDITH/2gAIAQIBAT8BfokdH//EABsQAQAABwAAAAAAAAAAAAAAAAABAhARMXGB/9oACAEBAAY/ArsIu0m2/8QAGRABAQEAAwAAAAAAAAAAAAAAAREQADFx/9oACAEBAAE/IaOVqYlGMB50etb/2gAMAwEAAgADAAAAEH//AP/EABYRAQEBAAAAAAAAAAAAAAAAAAEAEf/aAAgBAwEBPxBlM4OX/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARIf/aAAgBAgEBPxDhluHb/8QAHBABAAICAwEAAAAAAAAAAAAAAQAxEWEhQfDx/9oACAEBAAE/ED+csctEaOQ7ZS4AZqe3qdRNr8E//9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/88917/electron-template-cover.jpg","srcSet":"/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/38847/electron-template-cover.jpg 185w,\n/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/2aba6/electron-template-cover.jpg 371w,\n/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/88917/electron-template-cover.jpg 741w","sizes":"(min-width: 741px) 741px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/e48a9/electron-template-cover.avif 185w,\n/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/cdfef/electron-template-cover.avif 371w,\n/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/6de04/electron-template-cover.avif 741w","type":"image/avif","sizes":"(min-width: 741px) 741px, 100vw"},{"srcSet":"/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/3edfa/electron-template-cover.webp 185w,\n/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/070ab/electron-template-cover.webp 371w,\n/leon-blog/static/e5329df06afc3b9b153a54b806b4d4ab/fedb0/electron-template-cover.webp 741w","type":"image/webp","sizes":"(min-width: 741px) 741px, 100vw"}]},"width":741,"height":368},"body":"---\ntitle: \"electron-template\"\ncover: images/electron-template-cover.jpg\ncoverAlt: \"封面\"\ndescription: \"electron启动脚手架\"\ndatePublished: \"2021-12-01 09:03:56\"\ndateModified: \"2021-12-01 09:03:56\"\ncategory: \"框架工具\"\ntags:\n  - Node.js\n  - Electron\n  - 脚手架\n  - 开源\n  - Vue3\n  - Vite\n  - 跨平台\n---\n\n使用electron开发桌面端应用的启动模版。这个项目包含了桌面端代码和web端代码，其中桌面端有两个窗口，web端包含两个页面。\n\ngitee仓库：https://gitee.com/missmess/electron-template\n\n---\n\n## 已包含功能\n\n### 桌面端\n\n- 已包含基础菜单配置：`src/core/appMenu`\n- 使用windowManager管理窗口，清晰易用，易配置：`src/WindowManifest`\n- 默认包含主窗口和一个设置窗口，满足80%的桌面端场景。\n- 支持webUI的本地/远程渲染模式，一键配置：`forge.config.js`\n- 默认启用沙盒模式，保护程序安全。\n- 已封装常用原生api，并导出到web端。\n\n### web端\n\n- 默认包含一个Vue3 + Element Plus的web项目\n- 包含了一个首页和一个设置页的基础ui\n- 已封装底层原生api，web端可直接引入调用：`@/src/NativeService`\n\n## 代码结构\n\nlibs - 存放三方js库\n\npkg - 打包相关icon资源等\n\nsrc - 桌面端主要代码\n\nwebapps - 存放webUI项目，可以有多个\n\nwww - 打包后的webUI代码，程序会加载这个目录下的html\n\nforge.config.js - [forge的配置文件，包括打包、编译插件等](https://www.electronforge.io/)\n\n## 如何使用\n\n### 调试\n\n1. 安装npm包。\n\n```shell\n# 桌面端安装npm包\nyarn\n# web端安装npm包\ncd webapps/vue3-webapp && yarn\n```\n\n2. 确保`forge.config.js`中，启用的是远程渲染模式\n\n```javascript\nmodule.exports = {\n  envConfig: {\n    localRender: false,\n    ...\n  },\n  ...\n}\n```\n\n3. 启动webUI。\n\n```shell\nyarn webDev\n```\n\n4. 打开应用窗口\n\n```shell\nyarn start\n```\n\n### 打包\n\n1. 确保`forge.config.js`中，启用的是本地渲染模式\n\n```javascript\nmodule.exports = {\n  envConfig: {\n    localRender: true,\n    ...\n  },\n  ...\n}\n```\n\n2. 打包webUI到`/www`目录。\n\n```shell\nyarn webBuild\n```\n\n3. 打包应用程序。（在mac上运行命令打包mac、在windows上运行命令打包windows）\n\n```shell\nyarn make\n```\n\n## 其他说明\n\n1. 如果不想把webUI打包到桌面应用中，或者UI频繁更新不想每次都打包。可以直接启用远程渲染模式，并修改baseUrl为自己的webUI访问地址。\n\n> 注意这种方式不适合离线应用或者对FCP要求高的，因为远程渲染依赖网络，需要下载资源的时间。常规应用最好是离线加载，实现一键更新功能。\n\n2. 注意主进程和渲染进程是隔离的，主进程和渲染进程通信使用`ipcMain`和`ipcRender`。`preload`脚本运行在渲染进程，并可以访问`Node.js`api。\n\n## 截图\n\n![首页](./images/electron-template.jpg)","slug":"/electron-template"},{"id":"33244462-0b5e-5a01-9236-1a277f6d11aa","title":"函数计算平台","tags":["前端","React","Antd","Node.js","Vite"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAEDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHJVEkygf/EABUQAQEAAAAAAAAAAAAAAAAAABEg/9oACAEBAAEFAmv/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAADAQADAAAAAAAAAAAAAAAAARFRMUFh/9oACAEBAAE/IeHZfWV6xpYRYRYf/9oADAMBAAIAAwAAABAP/wD/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxCq/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8QiP/EABwQAAICAgMAAAAAAAAAAAAAAAABUZERIUFh8f/aAAgBAQABPxDLRtnORvxYe4QlHUoUSj//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/761838330029d2692c054894a12fecc2/56675/faas_cover.jpg","srcSet":"/leon-blog/static/761838330029d2692c054894a12fecc2/9fa5a/faas_cover.jpg 184w,\n/leon-blog/static/761838330029d2692c054894a12fecc2/2a971/faas_cover.jpg 367w,\n/leon-blog/static/761838330029d2692c054894a12fecc2/56675/faas_cover.jpg 734w,\n/leon-blog/static/761838330029d2692c054894a12fecc2/cc34a/faas_cover.jpg 1468w","sizes":"(min-width: 734px) 734px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/761838330029d2692c054894a12fecc2/9d028/faas_cover.avif 184w,\n/leon-blog/static/761838330029d2692c054894a12fecc2/fcbd2/faas_cover.avif 367w,\n/leon-blog/static/761838330029d2692c054894a12fecc2/61ef5/faas_cover.avif 734w,\n/leon-blog/static/761838330029d2692c054894a12fecc2/8994a/faas_cover.avif 1468w","type":"image/avif","sizes":"(min-width: 734px) 734px, 100vw"},{"srcSet":"/leon-blog/static/761838330029d2692c054894a12fecc2/ef27d/faas_cover.webp 184w,\n/leon-blog/static/761838330029d2692c054894a12fecc2/6963a/faas_cover.webp 367w,\n/leon-blog/static/761838330029d2692c054894a12fecc2/bce1f/faas_cover.webp 734w,\n/leon-blog/static/761838330029d2692c054894a12fecc2/1814d/faas_cover.webp 1468w","type":"image/webp","sizes":"(min-width: 734px) 734px, 100vw"}]},"width":734,"height":368},"body":"---\ntitle: \"函数计算平台\"\ncover: lixiang/faas_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"理想汽车函数计算/边缘计算平台\"\ndatePublished: \"2022-01-30 11:22:01\"\ndateModified: \"2022-01-30 11:22:01\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - Antd\n  - Node.js\n  - Vite\n---\n\n函数计算平台的目标用户是车机系统研发人员，通过faas可实现远程在车机执行任意代码。函数计算平台包含**车机faas引擎**和**faas管理平台**。**车机faa引擎务**运行在车机系统中，用于通过mesh网络连接云端、下载和更新函数、运行函数进行边缘计算等。**faas管理平台**运行在云端，用于编辑函数代码、配置函数运行规则、通过mesh网络下发到车机faas引擎等。\n\n> faas服务为原limesh六大服务（uploader、downloader、configurator、vss、job、topic）外的第7个服务。\n\n---\n\n### faas管理平台功能\n\n1. 函数管理。包含函数列表crud、函数运行环境和规则编辑、函数代码编辑、函数在线测试、查看运行日志、函数版本管理、函数历史代码对比、函数运行监控、函数全量/批量下发、函数手动触发等。\n\n2. 函数操作记录。\n\n3. faas引擎版本管理、车机引擎信息查询等。\n\n### 车机faas引擎功能\n\n1. 引擎支持通过车机热更新服务更新、重启。\n\n2. 通过veh-job，获取函数、更新函数代码和函数规则，并将函数注册到引擎中。\n\n3. 根据函数规则或veh-job的主动通知，运行函数。\n\n4. 引擎提供基础原生能力供函数调用（如读写车机其他服务信号数据、读写车机本地数据库等，根据业务需求不断开放）。\n\n5. 引擎负责函数的性能监控并上报数据到云端。\n\n### 我的职责\n\n1. 负责管理平台的搭建，架构，开发工作。\n\n2. 负责faas引擎的部分功能开发。\n\n### 技术特点\n\n1. 函数平台基于React、vite、Ant-Design开发。\n\n2. 函数编辑使用monaco实现。基于不同语言提供语法高亮、错误提示、和原生api语法提示等。\n\n3. 函数代码测试使用websocket对接server端，实时展示测试日志。\n\n4. 函数代码比对使用monaco DiffEditor。\n\n5. 监控数据图表显示使用echarts。\n\n6. faas引擎使用Node.js开发。\n\n### 截图\n\n![函数在线编辑](./lixiang/faas_code.jpg)","slug":"/函数计算平台"},{"id":"635f2a88-7138-565a-aa58-62a5aee3fd89","title":"FaceRecognition【在框识别】","tags":["Android端","kotlin","AI","库","图像处理"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEEAgP/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB7PEbNYgr/8QAHBAAAQMFAAAAAAAAAAAAAAAAAgEDBBIhJDIz/9oACAEBAAEFAo41RAHKdscXg8So+e3/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPwEn/8QAHRAAAgEEAwAAAAAAAAAAAAAAABEBAhASISJhgf/aAAgBAQAGPwJdHFLHaJPChTMat//EABsQAQACAwEBAAAAAAAAAAAAAAEAESExQWHB/9oACAEBAAE/IaY7fqEYjYcvJQVMSHPUbMI0zfP/2gAMAwEAAgADAAAAEAcP/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAx/9oACAEDAQE/EDV//8QAFhEAAwAAAAAAAAAAAAAAAAAAARAx/9oACAECAQE/EIK//8QAHhABAQACAQUBAAAAAAAAAAAAAREAMZEhQXGBobH/2gAIAQEAAT8QpWKPW3y4HDQJREFcs5xjEsehe2IIiQj5xaYmqm94lu3X4Z//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/3023c/facerecog_cover.jpg","srcSet":"/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/47ac4/facerecog_cover.jpg 181w,\n/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/6fbf8/facerecog_cover.jpg 362w,\n/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/3023c/facerecog_cover.jpg 724w","sizes":"(min-width: 724px) 724px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/f6551/facerecog_cover.avif 181w,\n/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/48f1e/facerecog_cover.avif 362w,\n/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/a8935/facerecog_cover.avif 724w","type":"image/avif","sizes":"(min-width: 724px) 724px, 100vw"},{"srcSet":"/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/f7f9f/facerecog_cover.webp 181w,\n/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/283c9/facerecog_cover.webp 362w,\n/leon-blog/static/72a1e242d7dd5448328bf3383e71cfd6/e79f8/facerecog_cover.webp 724w","type":"image/webp","sizes":"(min-width: 724px) 724px, 100vw"}]},"width":724,"height":368},"body":"---\ntitle: \"FaceRecognition【在框识别】\"\ncover: images/facerecog_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"学生人脸在框识别\"\ndatePublished: \"2020-10-09 17:05:11\"\ndateModified: \"2020-10-09 17:05:11\"\ncategory: \"框架工具\"\ntags:\n  - Android端\n  - kotlin\n  - AI\n  - 库\n  - 图像处理\n---\n\n识别图片中是否包含正面面对屏幕的人脸。\n\n### 技术实现\n\n1. kotlin开发android library\n\n2. opencv处理图片，转矩阵/转换颜色空间等\n\n3. mtcnn模型pnet、rnet、onet依次预测，nms后处理\n\n4. 返回结果boxes\n\n5. 利用aspectj插桩对模型推理做耗时检测及优化\n\n### 如何使用\n\n在app module中引入库\n\n```\n// app下build.gradle\nimplementation project(\":facerecognition\")\n```\n\n初始化`MtcnnFaceDetector`，传入context、config、callback三个参数\n\n```kotlin\nlateinit var mtcnn: MtcnnFaceDetector\n...\nmtcnn = MtcnnFaceDetector(this, MtcnnFaceDetector.Config(\n    assets2File(\"pnet_1106.pt\"),\n    assets2File(\"rnet_1106.pt\"),\n    assets2File(\"onet_1106.pt\"),\n    0.6f, 0.7f, 0.7f, 20\n), object : MtcnnFaceDetector.Callback {\n    override fun p(boxes: Vector<Box>) {\n    }\n\n    override fun r(boxes: Vector<Box>) {\n    }\n\n    override fun o(boxes: Vector<Box>) {\n    }\n})\n```\n\n执行预测\n\n```kotlin\nval boxes = mtcnn.detectFace(imgRes)\n```","slug":"/face-recognition【在框识别】"},{"id":"6077fc29-038d-5315-8caa-30f10c5445b3","title":"智能练习小程序","tags":["小程序"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIEAwX/xAAVAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAABsToYwshYMf/EABoQAAIDAQEAAAAAAAAAAAAAAAABAgMRIjL/2gAIAQEAAQUCkmjWKvVPzUuT/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAECEv/aAAgBAwEBPwFWbZ//xAAYEQACAwAAAAAAAAAAAAAAAAAAAQIRE//aAAgBAgEBPwFwozR//8QAGRAAAwADAAAAAAAAAAAAAAAAAAEQESGB/9oACAEBAAY/AjeORin/xAAaEAEAAgMBAAAAAAAAAAAAAAABABEQMUFx/9oACAEBAAE/IUU7yC6+lHs1ANxcLWY//9oADAMBAAIAAwAAABDLL//EABgRAAIDAAAAAAAAAAAAAAAAAAABESFB/9oACAEDAQE/EGOKHmf/xAAYEQACAwAAAAAAAAAAAAAAAAAAAREhgf/aAAgBAgEBPxBaaKGz/8QAHRABAAICAgMAAAAAAAAAAAAAARExACEQUUFxgf/aAAgBAQABPxCNBEtoevmRQazZFL8VhVO9DgoWjZOJFiDr3x//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/483b8/mini_cover.jpg","srcSet":"/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/9fa5a/mini_cover.jpg 184w,\n/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/63e75/mini_cover.jpg 368w,\n/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/483b8/mini_cover.jpg 735w","sizes":"(min-width: 735px) 735px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/9d028/mini_cover.avif 184w,\n/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/c6ee4/mini_cover.avif 368w,\n/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/6f2e7/mini_cover.avif 735w","type":"image/avif","sizes":"(min-width: 735px) 735px, 100vw"},{"srcSet":"/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/ef27d/mini_cover.webp 184w,\n/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/4ae45/mini_cover.webp 368w,\n/leon-blog/static/384c8300d9e5d83d729a2bd65ca73b09/51181/mini_cover.webp 735w","type":"image/webp","sizes":"(min-width: 735px) 735px, 100vw"}]},"width":735,"height":368},"body":"---\ntitle: \"智能练习小程序\"\ncover: xes/mini_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"智能练习小程序\"\ndatePublished: \"2018-12-27 08:33:21\"\ndateModified: \"2018-12-27 08:33:21\"\ncategory: \"应用项目\"\ntags:\n  - 小程序\n---\n\n云学习智能练习小程序（阿来爱做题）。是学生在线做题，提交作业，老师在线判题反馈，分析做题情况的小程序。\n\n### 技术点\n\n1. 使用原生微信小程序语言开发。\n\n2. 复杂点是小程序canvas上绘图，贴图，画笔，以及天然的原生组件层级bug。\n\n3. 使用wxs在渲染层执行运算，减少与逻辑层通信。\n\n### 截图\n\n![选角色](./xes/mini_choose.jpg)","slug":"/智能练习小程序"},{"id":"f577efc1-b500-5e88-89b1-c4f1c735a6ec","title":"一文详解前端工程化基础架构","tags":["前端","架构","微前端","低代码","模块联邦","组件化"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHbIqwj/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAFxAAAwEAAAAAAAAAAAAAAAAAAAEREP/aAAgBAQABPyGEQtR//9oADAMBAAIAAwAAABCXP//EABYRAAMAAAAAAAAAAAAAAAAAAAEQEf/aAAgBAwEBPxCBf//EABcRAAMBAAAAAAAAAAAAAAAAAAABEVH/2gAIAQIBAT8Qj0j0/8QAHBAAAgICAwAAAAAAAAAAAAAAAAERMSGRQXHh/9oACAEBAAE/EGk8bOjYqj0aWRpTRQ//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/fff17/fe_infra.jpg","srcSet":"/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/9fa5a/fe_infra.jpg 184w,\n/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/63e75/fe_infra.jpg 368w,\n/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/fff17/fe_infra.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/9d028/fe_infra.avif 184w,\n/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/c6ee4/fe_infra.avif 368w,\n/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/b4627/fe_infra.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/ef27d/fe_infra.webp 184w,\n/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/4ae45/fe_infra.webp 368w,\n/leon-blog/static/a0de84897a621c2f46fec7062a4747f7/20e6b/fe_infra.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"一文详解前端工程化基础架构\"\ncover: ../static/assets/fe_infra.jpeg\ncoverAlt: \"封面\"\ndescription: \"详细介绍完整的前端工程化建设所包含的工具、模块、框架、库\"\ndatePublished: \"2023-01-10 22:20:40\"\ndateModified: \"2023-01-10 22:20:40\"\nslug: \"fe-infra\"\ncategory: \"经验总结\"\ntags:\n  - 前端\n  - 架构\n  - 微前端\n  - 低代码\n  - 模块联邦\n  - 组件化\n---\n\n在前端应用开发的整个生命周期过程中，离不开许许多多的框架、库、模块和工具。正是有了这一系列的基础设施，才能大大滴提升程序员们的开发效率、代码质量和可维护性。我们把这一系列基础设施，统一规划为`前端工程化`的范畴。在这里，我将按照生命周期的顺序详细介绍一下前端工程化的各个流程及其内容：\n\n<details>\n<summary style=\"margin: 16px 0; color: var(--color-primary)\">本文目录</summary>\n\n- [版本控制和代码托管](#版本控制和代码托管)\n- [包管理仓库](#包管理仓库)\n- [多包管理工具](#多包管理工具)\n- [构建工具](#构建工具)\n- [渐进式开发框架](#渐进式开发框架)\n- [UI组件库](#ui组件库)\n- [项目启动脚手架](#项目启动脚手架)\n- [模块化和组件化](#模块化和组件化)\n- [从微前端到微模块](#从微前端到微模块)\n- [mock和API管理](#mock和-api管理)\n- [低代码](#低代码)\n- [响应式设计](#响应式设计)\n- [代码规范和静态检查](#代码规范和静态检查)\n- [自动化测试](#自动化测试)\n- [性能检测和优化](#性能检测和优化)\n- [CI/CD](#ci-cd)\n- [生产部署](#生产部署)\n- [错误监控](#错误监控)\n\n</details>\n\n### 版本控制和代码托管\n\n版本控制和代码托管是实现开发的基石。目前公司内部最常用的组合是`git + gitlab`，而开源或个人首选的组合是`git + github`。\n\n版本控制需要提前定义好`分支规范` + `commit message规范`。`分支规范`是指使用的分支模型。比如常用的`master/develop/feature/hotfix`模型，或者支持多环境的`main/test/ontest/pre`模型。\n\n`commit规范`是针对代码提交的规范，包括commit频次、粒度、message的规范控制。\n\n> gitlab是开源代码管理工具，如果公司为了安全性可以考虑部署gitlab到自有服务器上，参考[gitlab安装帮助](https://about.gitlab.com/install/)。\n\n### 包管理仓库\n\n最流行最常用的公有仓库是[npm](https://www.npmjs.com/)。\n\n> 往往很多公司都希望搭建自己私有的npm仓库。目前很成熟的开源方案是[cnpmcore](https://github.com/cnpm/cnpmcore)，可以直接部署到自己公司的服务器上。\n\n### 多包管理工具\n\n公司中型以上的业务，或者一些基础框架，工具库等，都不会只有一个package。所以就存在了多个package之间，相互依赖的情况出现。这时候各个模块之间的依赖管理、调试等都会出现一些挑战。多包管理分为两种方式：`multirepo`和`monorepo`。\n\n**multirepo**\n\n`multirepo`就是将每个模块都单独放在自己的仓库内。独立管理、开发、测试、发布。最常见的方式就是`git+npm`，通过npm安装依赖的包，每个包都使用git管理。如果希望调试它的子依赖库的变更，那么可以通过`npm link`的方式将本地的子依赖库链接到主仓库上。\n\n另一个方案就是`git submodule`，由git提供。多个库之间仍然是独立管理的。但是通过`git submodule`将多个子仓库嵌入到主仓库中。可以直接在主仓库中查看各个子模块的代码，可以快速更新子模块。\n\n**monorepo**\n\n`monorepo`（单仓库）就是将多个模块都放在一个代码仓库里，使用同一个版本控制工具管理。它可以在一个仓库管理多个库，但是如果仓库越来越大，也可能导致编译性能下降。\n\n常用的一个方案是[Lerna](https://lerna.js.org/)，它是一个monorepo的管理工具。可以统一或分别管理多个包的版本和依赖。可以通过依赖提升和共享依赖来减少多包之间相同的依赖安装和更新（减少磁盘空间占用）。\n\n具体需要使用`multirepo`还是`monorepo`，需要根据实际情况来选择。一般来看，`monorepo`适用于那些多包之间依赖关系比较复杂和紧密的项目，比如基础库（li-mesh的node包仓库，非常多的包，且联系紧密，依赖复杂）。对于那些模块比较独立的项目，那可能选择`multirepo`会更合适。\n\n### 构建工具\n\n构建工具是前端工程化的核心，它能自动化的处理前端应用开发过程中比较繁琐但又常见的任务。*包括但不限于图片优化、代码压缩、css兼容、代码分包、treeshake、打包编译、dev服务、环境变量。*\n\n常见的构建工具有：[Webpack](https://www.webpackjs.com/concepts/)、[Vite](https://cn.vitejs.dev/guide/)。\n\n### 渐进式开发框架\n\n现在最主流的SPA框架是[React](https://react.dev/)和[Vue](https://cn.vuejs.org/)。\n\n当然还有越来越多人使用的SSR应用框架[Next](https://nextjs.org/)和[Nuxt](https://www.nuxtjs.cn/)。\n\n构建博客或文档站点的SSG应用框架[Gatsby](https://www.gatsbyjs.com/)、[Hugo](https://gohugo.io/)。\n\n基于你的经验和偏好选择合适的开发框架，它们不会局限你的想象力。\n\n### UI组件库\n\n几乎所有的前端应用都需要用到`组件库`，大型的前端应用几乎都会有自己的组件库。UI组件库就是一系列可以复用和组合的UI组件的合集，它们一起构建出优秀、美观的用户界面。\n\n主流的**PC端UI组件库**包含[ElementUI](https://element-plus.org/zh-CN/)、[Ant-Design](https://ant-design.antgroup.com/index-cn)、[MaterialUI](https://mui.com/material-ui/all-components/)。\n\n其次，**移动端UI组件库**有[Vant](https://vant-ui.github.io/vant/#/zh-CN/home)、[VUX](https://doc.vux.li/zh-CN/)（常用于微信端页面）。\n\n另外，**小程序UI组件库**有[WeUI](https://weui.io/)、[Vant Weapp](https://vant-ui.github.io/vant-weapp/#/home)；**Uniapp UI组件库**有[FirstUI](https://doc.firstui.cn/docs/started.html)、[uView](https://uviewui.com/)。\n\nBy the way: css预编译库也是前端必不可少的工具之一，它极大地提升了css开发效率。主流css预编译库有：[Sass](https://www.sass.hk/)、[Less](https://lesscss.cn/)、[UnoCSS](https://unocss.dev/interactive/)、[WindiCss](https://windicss.org/)、[Styled-Components](https://styled-components.com/docs)（比较特殊，它是一个`css-in-js`库）。*你可以脱离UI组件库只使用CSS库，但通常都推荐一起使用提升效率。*\n\n> 自建UI组件库，可以clone开源组件库。如[Ant-Design代码库](https://github.com/ant-design/ant-design)，已包含组件源码及基于dumi的组件库网站。我们在开源基础上进行样式重构、新增业务组件等。\n\n### 项目启动脚手架\n\n选好了构建工具和开发框架，然后就可以从`启动脚手架`开始你的编码生活（你也可以不使用任何启动脚手架，但是仅限于学习，工作中请不要这么做）。常用的开源启动脚手架：\n\n- [vite-reactts-antd-redux-starter](https://github.com/missmess/vite-reactts-antd-redux-starter/tree/master)：后台应用的话强烈推荐（是我做的😄），集成了常用的全生态三方库，并且已包含了后台基础页面布局。\n- [Vue Cli](https://cli.vuejs.org/zh/guide/)：官方出品Vue2 + webpack启动脚手架（已经停止维护）。\n- [create-vue](https://github.com/vuejs/create-vue)：新版cli工具，基于Vite，支持Vue2/Vue3。包含的[启动模版](https://github.com/vitejs/vite/tree/main/packages/create-vite)也很多。\n- [CRA](https://create-react-app.dev/docs/getting-started)（create-react-app）：React官方推荐（but作者支持Ukraine）。支持在社区自己找[启动模版](https://www.npmjs.com/search?q=cra-template-*)。通常搭配[craco](https://craco.js.org/docs/getting-started/)\n- [Umi](https://umijs.org/docs/introduce/introduce)：企业级应用框架，使用React。\n- [Ice](https://v3.ice.work/docs/guide/about)：与`Umi`比较类似，使用React。\n- [awesome-vite](https://github.com/vitejs/awesome-vite#templates)：一些Vite的各场景启动模版。\n- 或者在github找到不错的模版，直接使用[degit](https://github.com/Rich-Harris/degit)工具down下来。\n\n> 前端团队可以自己搭建自己的启动脚手架，包括`cli工具`和`脚手架模版`。`cli工具`是为了通过命令行的形式配置`脚手架模版`里的哪些模块放到最终生成的项目中。`cli工具`推荐直接使用node脚本开发。\n\n### 模块化和组件化\n\n**模块化**\n\n模块化开发时，尽量将不同功能拆分成独立的模块和文件。其他模块或文件使用时，通过import（ES6）和require（CommonJs）导入。\n\n**组件化**\n\n组件化强调的是，使用Vue、React等框架开发时，页面中相对独立的的一部分UI及其对应的逻辑代码，一起作为一个独立组件抽出，以达到代码复用和易维护性的优势。\n\n模块化和组件化开发方式，是前端工程化不可或缺的一部分。\n\n### 从微前端到微模块\n\n**微前端**\n\n微前端就是将一个大型应用拆分成一个一个小型的、且可独立运行/调试/发布的前端应用的技术。类似于后端的`微服务`、Android端的`组件化方案`。微前端架构中，各个小型应用（称为`微应用`）是松耦合的，通常会有一个`主应用`和N个`微应用`，相互之间通过框架或者[中间件](/limesh开放平台#技术点)交互。\n\n常见的微前端框架有[single-spa](https://single-spa.js.org/docs/getting-started-overview)、[qiankun](https://qiankun.umijs.org/)。qiankun比较成熟，api也比较多。\n\n> nextjs官方也有自己的微前端形式：[Multi Zones](https://nextjs.org/docs/pages/building-your-application/deploying/multi-zones)，还没有了解过。\n\n**微模块**\n\n[Module Federation](https://webpack.js.org/concepts/module-federation/)带来了一个更细粒度的微前端架构形式，在此之前的微前端架构解决了页面级别的独立和共享。MF方案真正的将这种独立和共享做到了模块级别，就像是引入一个js包。不过在现有项目上使用MF方案需要自己去处理一系列问题，包括：\n1. 需要花些时间处理shared公共依赖；\n2. 远程模块的版本控制是一个问题，它并不像一个npm包你可以选择升级，也明确知道它的改动。有时候远程模块改动了你可能不知道，运行时才抛出一个异常；\n3. 依赖模块貌似没发tree-shake，比如依赖了一个lodash，那就得加载整个lodash。\n4. ...\n\n> [hel-micro](https://tencent.github.io/hel/)是以sdk的形式支持MF技术的一个新的方案，官方宣传的特性是**模块联邦 sdk 化、免构建、热更新、工具链无关**。有机会可以试一试。\n\n> 截止到2023年1月，调研了一下Vite + React上使用MF方案，虽然有[vite-plugin-federation](https://github.com/originjs/vite-plugin-federation)插件，但实际测试有无法逾越的问题存在。\n\n### mock和API管理\n\n**mock**\n\n`mock`用于开发阶段，后端接口还无法提供数据时，或developer想要检查一下异常数据场景时，可以使用一些mock工具，让自己的业务组件代码只需少量或者无修改就能获取到这些假数据。前端常用的mock手段有以下几种：\n\n1. 在代码中mock：代表性的mock库是[mockjs](https://github.com/nuysoft/Mock/wiki/Getting-Started)。可以在项目中直接mock各种接口的返回数据，还能拦截XHR和fetch请求，返回你定义的数据。\n\n2. 浏览器插件：[Just Mock](https://just-mock.vercel.app/guide/getting-started.html)是一个chrome插件，可以在访问目标网址时，配置自定义的请求规则，修改response的返回数据。可以一键开启关闭。\n\n3. 在线mock网站：[JSONPlaceholder](https://jsonplaceholder.typicode.com/)是一个在线的mock数据网站，可以直接访问预定的接口。缺点是接口比较少，不能自定义。\n\n**API管理**\n\n`API管理`工具是开发阶段针对后端接口进行维护管理的工具，目标是为了提升前后端协作效率和减少扯皮。不过现在的`API管理工具`往往已经包含了`mock`能力。\n\n[Postman](https://www.postman.com/)是老牌的`API管理`软件，支持接口管理、分组、环境变量、调试、mock、脚本测试、共享等等。功能很完善。\n\n[Apifox](https://app.apifox.com/)是在线的`API管理`应用，功能和`Postman`对齐。\n\n[Swagger](https://swagger.io/)是java可用，优点是从代码注解直接生成。对于java开发者很方便。\n\nBTW：`Node.js`的`Express`框架可以用`swagger-jsdoc` + `swagger-ui-express`实现上面`Swagger`的功能。\n\n> 公司内部也可以创建自己的API管理平台，功能对标`Apifox`产品。可以附加一些额外的实用功能，比如各接口定义一键导出`typescript`定义文件。*（前端非常重复且耗时的一个工作就是写ts）*\n\n### 低代码\n\n低代码在前端领域的占比很大（而且只会越来越大），并且由于LLM的不断发展，低代码技术将会发生各种各样的新变革。它能很大程度上提升前端人员的开发效率。\n\n详细介绍了一下低代码：[低代码现状调研](/低代码现状调研)。\n\n> 比较推荐[Lowcode-Engine低代码平台](https://lowcode-engine.cn/)，实际使用后，完全可以满足商用产品和大型应用的部分重复性页面和简单页面，功能比较强大。但是相对的，配置也会繁琐很多。\n\n### 响应式设计\n\n一个优秀的前端应用必须能支持在不同屏幕下的页面展示体验。\n\n- 媒体查询\n\n    从css层处理的。在组件中，根据不同的设备屏幕大小来应用不同的css规则，来达到响应式的目标。\n\n- 路由页面组件适配\n\n    从逻辑层处理的。根据不同的屏幕大小，同一路由地址，使用不同的组件来渲染。适用于移动端页面和PC端页面相差较大的场景。\n\n### 代码规范和静态检查\n\n- **代码规范文档**：包括代码风格、‌命名规范等，目的是提高代码的可读性和可维护性。\n\n- **使用ESLint**：执行代码静态检查的一个工具，自动检测代码是否符合预设的代码规范。\n\n- **使用Prettier**：自动格式化代码，让团队保持一致的代码风格。\n\n### 自动化测试\n\n**单元测试**\n\n单元测试框架用于对组件或模块执行单元测试，确保它们的功能是没有bug的。单元测试可以使用[jest](https://github.com/jestjs/jest)，dom相关状态测试使用[jest-dom](https://github.com/testing-library/jest-dom)、React组件测试使用[@testing-library/react](https://github.com/testing-library/react-testing-library#readme)。\n\n**E2E测试**\n\n[Cypress](https://github.com/cypress-io/cypress)是一个前端E2E（end-to-end，端到端）测试工具。\n\n### 性能检测和优化\n\ntoC的应用几乎无法避开性能这个话题。性能不好的网站将会大大降低用户体验。\n\n开发阶段：常用的性能检测工具有`chrome devtools`、`lighthouse`、`vue devtools`、`react profiler`等等。\n\n生产阶段：[performance API](https://developer.mozilla.org/zh-CN/docs/Web/API/Performance)是浏览器内置的性能数据工具。[web-vitals](https://github.com/GoogleChrome/web-vitals)是基于performance的out-of-box库，可快速获取FCP、LCP、FID、CLS等常用性能指标并上报。\n\n**性能优化**\n\n性能优化方案是一个复杂的专题，跨域很多个纬度，大致的内容包含：\n\n1. 组件懒加载、图片懒加载：\n\n    - 只有在需要时才加载组件或图片，减少初始加载时间。\n    - 使用Intersection Observer API实现懒加载。\n\n2. 超长列表使用虚拟列表技术：\n\n    - 对于超长列表，使用虚拟列表技术（如React Virtualized）只渲染可见区域的元素，减少DOM节点数量。\n\n3. 合并资源减少HTTP请求次数：\n\n    - 将多个CSS、JavaScript文件合并为一个文件，减少HTTP请求次数。\n    - 使用工具如Webpack进行资源打包。\n\n4. 代码minify和gzip压缩：\n\n    - 使用工具如UglifyJS、Terser对JavaScript代码进行minify，减少文件大小。\n    - 在服务器端配置gzip压缩，减少传输文件的大小。\n\n5. 图像优化：\n\n    - 使用现代图像格式如WebP，减少图像文件大小。\n    - 使用图像压缩工具如TinyPNG。\n\n6. 缓存优化：\n\n    - 常用数据缓存到本地（如LocalStorage、IndexedDB），减少请求消耗。\n    - 配置HTTP缓存（Cache-Control和Expires），减少重复请求。\n\n7. 使用CDN：\n\n    - 将静态资源存储到CDN，利用CDN的分布式节点加速资源加载。\n\n8. Service Worker：\n\n    - 使用Service Worker实现接口缓存和离线支持，提高应用的可靠性和性能。\n\n9. 服务器端渲染（SSR）和静态站点生成（SSG）：\n\n    - 使用SSR和SSG技术提升首屏渲染速度，减少白屏时间。\n\n10. HTTP/2和HTTP/3：\n\n    - 使用HTTP/2或HTTP/3协议，利用多路复用、头部压缩等特性提高传输效率。\n\n11. 减少重排和重绘：\n\n    - 优化CSS和JavaScript，减少不必要的DOM操作，避免频繁的重排和重绘。\n\n12. 异步加载和预加载：\n\n    - 使用async和defer属性异步加载JavaScript文件。\n    - 使用`<link rel=\"preload\">`预加载关键资源。\n\n13. [Vue性能优化实践](https://cn.vuejs.org/guide/best-practices/performance.html)。\n\n14. [React性能优化指导](https://legacy.reactjs.org/docs/optimizing-performance.html)。\n\n> 通常一个大型项目内部，可以自己制作一个lightweight、用于线上的性能监控工具。监控一系列性能数据，并及时上报到`Sentry`。\n\n### CI/CD\n\nCI/CD即持续集成/持续部署。通过CI/CD工作流，能自动化的将开发人员提交的代码，进行编译、构建、检查、测试等环节，测试通过后自动部署到测试或生产环境中。\n\n通过开源工具[Travis-CI](https://www.travis-ci.com/)、[Jenkins](https://www.jenkins.io/)能方便实现CI/CD工作流。\n\n现在主流的代码托管仓库也都已经支持了CI/CD工作流。包括`github`、`gitee`、`gitlab`。\n\n### 生产部署\n\n前端应用最终是需要部署到服务器上，并且提供域名才能访问的。可以通过CI/CD或者手动部署。\n\n传统方式是公司购买自己的真实服务器，再通过内网部署应用到服务器上。目前大部分公司的主流方案是采用云服务器，即购买云服务厂商的服务器资源。再通过工具部署。\n\n对于个人网站或H5应用来说，部署的方案就更多一些。可以自己购买云服务器、购买带宽、安装nginx、安装jenkins、配置域名、配置https等等。\n\n此外，腾讯云提供的[云开发](https://cloud.tencent.com/document/product/876)服务可以更快速的完成前后端开发到部署上线，不需要买服务器和域名，以及处理一系列复杂的运维操作\n\n如果是静态站点，可以直接购买对象存储服务，将网站托管到对象存储服务里，并配置访问地址。市面上有很多免费的托管平台，比如[Netlify](https://app.netlify.com/)、[Github Pages](https://pages.github.com/)。\n\n> 很多公司会有自己的云资源管理平台。管理私有云、公有云资源。包括云主机、云存储、云数据库、域名服务等等。方便员工在线申请/编辑自己的应用所需要的云资源。\n\n### 错误监控\n\n错误监控就是收集应用在线上运行时发生的错误和异常。开源的错误监控工具有[Sentry](https://sentry.io/)。\n\n`Sentry`分为web界面和sdk。`Sentry`支持的sdk非常丰富，不仅仅支持前端技术栈。通常一个项目组或一个公司需要一个Sentry服务即可。web端界面可通过`docker`等部署到服务器上。\n\n### Ending\n\n前端工程化是一个复杂、重要、并且不断进化的技术课题，目的就是提升开发效率、提高质量和加强团队合作效率。随着技术的变迁、环境的变化，它包含的内容可能会发生翻天覆地的变化。我们要做的就是与时俱进，不断学习。\n","slug":"/fe-infra"},{"id":"30ea3716-8e0a-519e-82a2-896d50136980","title":"智能练习小游戏","tags":["小游戏","游戏"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAED/8QAFwEAAwEAAAAAAAAAAAAAAAAAAQIDBP/aAAwDAQACEAMQAAABuuEuCtC//8QAGRAAAgMBAAAAAAAAAAAAAAAAAAECESAh/9oACAEBAAEFAoxspD7j/8QAFhEBAQEAAAAAAAAAAAAAAAAAAAER/9oACAEDAQE/AZWv/8QAFxEAAwEAAAAAAAAAAAAAAAAAAQIREP/aAAgBAgEBPwF1Ntz/xAAaEAACAgMAAAAAAAAAAAAAAAABIQAgMVGR/9oACAEBAAY/AiUtzA7X/8QAGxABAAEFAQAAAAAAAAAAAAAAAREAECExQXH/2gAIAQEAAT8hgI4KBS4U3xUtvLdLf//aAAwDAQACAAMAAAAQKx//xAAWEQEBAQAAAAAAAAAAAAAAAAAAEUH/2gAIAQMBAT8QxU//xAAYEQEBAAMAAAAAAAAAAAAAAAABABEhMf/aAAgBAgEBPxBbGHINX//EABkQAQADAQEAAAAAAAAAAAAAAAEAETEhEP/aAAgBAQABPxABgcBIK52KVTAVhsSDoDFZLRKaioQ8dPP/2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/fff17/minigame_cover.jpg","srcSet":"/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/9fa5a/minigame_cover.jpg 184w,\n/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/63e75/minigame_cover.jpg 368w,\n/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/fff17/minigame_cover.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/9d028/minigame_cover.avif 184w,\n/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/c6ee4/minigame_cover.avif 368w,\n/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/b4627/minigame_cover.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/ef27d/minigame_cover.webp 184w,\n/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/4ae45/minigame_cover.webp 368w,\n/leon-blog/static/aeb4eba34d301f38fb46f05f13cbee28/20e6b/minigame_cover.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"智能练习小游戏\"\ncover: xes/minigame_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"智能练习小游戏\"\ndatePublished: \"2019-01-03 10:34:47\"\ndateModified: \"2019-01-03 10:34:47\"\ncategory: \"应用项目\"\ntags:\n  - 小游戏\n  - 游戏\n---\n\n智能练习小游戏（计算鸡大作战）。小一年级数学计算益智类小游戏。\n通过选择正确答案让计算鸡飞得更高。\n\n### 技术点\n\n1. 原生微信小游戏开发。\n\n2. spine实现计算鸡的骨骼动画。\n\n3. 纯js实现游戏背景、云彩、主角等元素每一帧动画的计算。\n\n### 截图\n\n![首页](./xes/minigame_home.jpg)","slug":"/智能练习小游戏"},{"id":"4a28f037-814a-5229-9433-a411d56d5eff","title":"Limesh开放平台","tags":["前端","React","微前端","架构","Vite"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAECAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHejYCGH//EABcQAQADAAAAAAAAAAAAAAAAAAEAESD/2gAIAQEAAQUCZbn/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAADAAAAAAAAAAAAAAAAAAAAIDL/2gAIAQEABj8CJX//xAAbEAEAAAcAAAAAAAAAAAAAAAABABEgITFRcf/aAAgBAQABPyFJgnF3TtP/2gAMAwEAAgADAAAAEMMP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAGBABAQEBAQAAAAAAAAAAAAAAARFRACD/2gAIAQEAAT8QArvLOHAs1Pn/2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/107f2/limesh_cover.jpg","srcSet":"/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/09c6f/limesh_cover.jpg 134w,\n/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/8fe70/limesh_cover.jpg 267w,\n/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/107f2/limesh_cover.jpg 534w","sizes":"(min-width: 534px) 534px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/2519c/limesh_cover.avif 134w,\n/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/648b3/limesh_cover.avif 267w,\n/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/ce20a/limesh_cover.avif 534w","type":"image/avif","sizes":"(min-width: 534px) 534px, 100vw"},{"srcSet":"/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/6b11c/limesh_cover.webp 134w,\n/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/217c6/limesh_cover.webp 267w,\n/leon-blog/static/a5a51e8f64680c45b382ac033d1300f3/3d4aa/limesh_cover.webp 534w","type":"image/webp","sizes":"(min-width: 534px) 534px, 100vw"}]},"width":534,"height":268},"body":"---\ntitle: \"Limesh开放平台\"\ncover: lixiang/limesh_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"理想汽车Limesh开发者开放平台\"\ndatePublished: \"2022-01-09 15:39:54\"\ndateModified: \"2022-01-09 15:39:54\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - 微前端\n  - 架构\n  - Vite\n---\n\nLi-Mesh开放平台的目标用户是使用Li-Mesh的开发者，在开放平台注册自己的应用后。可以在自己的应用授权范围内，接入Li-Mesh，使用该应用去设置Li-Mesh六大服务的资源、调用六大服务的能力、查询服务数据和操作记录等等。\n\n---\n\n### 我的职责\n\n1. 开放平台的架构设计、框架搭建，开发。\n\n2. 开放平台分开发者平台和管理员后台。\n\n3. 对接开发者平台和管理员后台的需求，并开发上线。\n\n### 技术点\n\n1. 和[车云服务系统](/车云服务系统)使用相同的架构设计。项目基于[vite-reactts-starter](/vite-reactts-starter)脚手架开发，基于qiankun实现微前端。\n\n2. 使用licar相同的样式规范。\n\n3. 使用redux在多个模块之间实现数据共享。\n\n4. 主应用和微应用、微应用和微应用之间的redux状态共享。使用了我自己开发的**appshare中间件**：即在任何一个应用中使用`useSharedState`获取的`state`，它是响应任何来源（包括当前应用，也包括其他应用）的变更的。同理，`setState`也是会触发其他应用的state变更。\n\n### 截图\n\n![开放平台首页](./lixiang/limesh_home.jpg)\n![VSS path管理](./lixiang/limesh_vss.jpg)","slug":"/limesh开放平台"},{"id":"031b4110-08fd-51ee-876a-38d32941d345","title":"车云服务系统","tags":["前端","React","微前端","架构","后端","Node.js","低代码","Vite","Koa"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMBBP/EABYBAQEBAAAAAAAAAAAAAAAAAAADBf/aAAwDAQACEAMQAAAB50s0I1SH/8QAGBABAAMBAAAAAAAAAAAAAAAAAQAREiD/2gAIAQEAAQUCyVkiHH//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQEf/aAAgBAgEBPwGH/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEREjIg/9oACAEBAAY/ApujaNLj/8QAGRAAAgMBAAAAAAAAAAAAAAAAAREAICFB/9oACAEBAAE/ISqy1nRAlzDOEp//2gAMAwEAAgADAAAAEBzv/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFxEAAwEAAAAAAAAAAAAAAAAAABFRAf/aAAgBAgEBPxBqLaf/xAAbEAEAAgIDAAAAAAAAAAAAAAABADERIRBRYf/aAAgBAQABPxAIswHfZankpA9YYApbBjz/AP/Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/fff17/licar_cover.jpg","srcSet":"/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/9fa5a/licar_cover.jpg 184w,\n/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/63e75/licar_cover.jpg 368w,\n/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/fff17/licar_cover.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/9d028/licar_cover.avif 184w,\n/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/c6ee4/licar_cover.avif 368w,\n/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/b4627/licar_cover.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/ef27d/licar_cover.webp 184w,\n/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/4ae45/licar_cover.webp 368w,\n/leon-blog/static/f48fd1c025cebe1c919f9aafeea45b76/20e6b/licar_cover.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"车云服务系统\"\ncover: lixiang/licar_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"理想汽车车辆云端管理平台\"\ndatePublished: \"2021-10-21 09:00:03\"\ndateModified: \"2021-10-21 09:00:03\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - 微前端\n  - 架构\n  - 后端\n  - Node.js\n  - 低代码\n  - Vite\n  - Koa\n---\n\n车云服务系统（li-car）是车辆云端业务管理平台，包含车辆管理、车机应用配置管理、车控、分组管理、信号管理等几个大模块。产品目标是方便业务人员和开发人员在云端处理车辆相关的业务。\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n1. crud管理车型、车辆、根据车机号(vin)查询车辆。\n\n2. 车机应用管理，低代码形式编辑/发布车机应用配置，追溯历史版本，查看操作记录。\n\n3. 车辆分组、车辆信号管理。\n\n4. 远程车控、车云工具箱、审计。\n\n5. 车辆告警、行程、远程拍照。\n\n6. 平台菜单配置管理。\n\n7. 权限：角色菜单权限、角色数据权限管理。\n\n### 我的职责\n\n1. 车云服务系统web端架构设计，框架搭建。\n\n2. 业务需求对接、前端开发。\n\n3. 车云服务平台server端接口开发。（菜单、按钮、权限、服务转发等）\n\n### 技术实现\n\n1. 车云服务系统为微前端架构，分为veh-cloud（主应用）、licar-micro（子应用，车辆相关业务）、common-config（子应用，应用配置中心）。使用qiankun、[vite-qiankun-plugin](/vite-plugin-qiankun)实现。\n\n2. 主应用基于[vite-reactts-starter](/vite-reactts-starter)开发，包含基础外壳（顶部栏+菜单栏+内容区）。\n\n3. 路由菜单通过接口动态配置和获取，菜单路由页支持**内部组件、内部组件string path、ifame页、外链、子应用路径**\n\n    ```typescript\n    export type RouteMenu = {\n      name: string; // 名称，展示到菜单、面包屑位置\n      path: string; // 路径，可填入http(s)链接或相对路径，支持动态路由和url参数。\n      component?: React.ComponentType | 'iframeView' | 'mircroAppView' | 'externalUrl' | string; // 组件/iframeView/mircroAppView/externalUrl\n      icon?: ReactNode | string;\n      desc?: string; // 菜单描述\n      routes?: RouteMenu[];\n      hideInMenu?: boolean;\n      meta?: SupportMetas; // 额外信息，用于路由页面控制父级样式\n      scope?: string; // 该路由需要权限\n      remark?: string; // 备注信息\n    };\n    ```\n\n4. 主应用通过idaas实现全局登录token获取、根据scope菜单显隐；子应用也通过idaas获取token，根据权限scope控制操作权限。\n\n5. 子应用只包含业务页面，可独立运行，支持嵌入其他系统中。\n\n6. 应用配置中心采用低代码形式，使用[FormRender](https://xrender.fun/form-render)实现拖拽式生成jsonSchema，方便不同业务方自己生成自己的配置表单。\n\n7. 应用配置中心也支持代码式配置jsonSchema。代码编辑器使用monaco。\n\n8. 车云服务平台server使用Node.js、Koa2开发。数据库使用mysql。\n\n9. 车云服务平台通过apollo服务获取网站配置。\n\n### 截图\n\n![首页](./lixiang/licar_home.jpg)\n![车型管理](./lixiang/licar_model.jpg)","slug":"/车云服务系统"},{"id":"5f317c12-7a6b-5491-8a3b-081a24c5b446","title":"灵境低代码平台","tags":["前端","React","后端","Node.js","Koa","低代码"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAwABBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHtm409tH//xAAaEAACAgMAAAAAAAAAAAAAAAABAgARAxAx/9oACAEBAAEFAnNKjW0PMYA1/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAGRAAAgMBAAAAAAAAAAAAAAAAEBEAASEx/9oACAEBAAY/AnFnGcof/8QAGhABAQADAQEAAAAAAAAAAAAAAREAECExQf/aAAgBAQABPyG1FmBwV8NEUJTLkDr4a//aAAwDAQACAAMAAAAQ0w//xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAwEBPxCH/8QAFxEBAAMAAAAAAAAAAAAAAAAAARARIf/aAAgBAgEBPxAMuP/EABoQAQACAwEAAAAAAAAAAAAAAAERIQAQQTH/2gAIAQEAAT8QJU8hwOiUHQTF6FknokmS6nKDuv/Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/483b8/lingjing_cover.jpg","srcSet":"/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/9fa5a/lingjing_cover.jpg 184w,\n/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/63e75/lingjing_cover.jpg 368w,\n/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/483b8/lingjing_cover.jpg 735w","sizes":"(min-width: 735px) 735px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/9d028/lingjing_cover.avif 184w,\n/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/c6ee4/lingjing_cover.avif 368w,\n/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/6f2e7/lingjing_cover.avif 735w","type":"image/avif","sizes":"(min-width: 735px) 735px, 100vw"},{"srcSet":"/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/ef27d/lingjing_cover.webp 184w,\n/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/4ae45/lingjing_cover.webp 368w,\n/leon-blog/static/e401181c11f8151a4ee4da27ddb9cd16/51181/lingjing_cover.webp 735w","type":"image/webp","sizes":"(min-width: 735px) 735px, 100vw"}]},"width":735,"height":368},"body":"---\ntitle: \"灵境低代码平台\"\ncover: lixiang/lingjing_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"理想汽车一站式低代码创建/发布平台\"\ndatePublished: \"2022-08-01 17:56:33\"\ndateModified: \"2022-08-01 17:56:33\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - 后端\n  - Node.js\n  - Koa\n  - 低代码\n---\n\n灵境低代码平台，是理想汽车前端低代码化一站式创建/发布平台。\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [仓库介绍](#仓库介绍)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n- 根据业务在应用中心创建自己的应用，以应用纬度管理项目。每个人只能管理自己的应用。\n\n- 在应用详情创建页面，创建后可进入低代码编辑页，拖动+配置+代码结合生成页面。\n\n- 低代码编辑页现已支持Ant-Design、ProComponents、Fusion的组件，可迅速搭建常见的管理后台页面。\n\n- 生成的页面可随时通过预览链接预览。页面发布后即生成正式链接，支持dev和prod两个环境，可用于生产使用。\n\n- 低代码页面中目前支持多环境变量、IDaas全局登录状态、公共代码等功能，不断增加新功能...\n\n- 支持将常用的组件及其子节点（组件树）保存为一个【区块】。将某个页面保存为【页面模版】。保存后可在【模版区块中心】查看，其他人也可直接使用。\n\n- 支持为某一个应用添加协作者。\n\n### 仓库介绍\n\n- 【lingjing-center】：灵境低代码平台的web ui项目。\n\n- 【lingjing-core】：低代码编辑页（`src/page/index`）、开发预览（`src/page/preview`）、测试环境访问（`src/page/dev`）、线上环境访问（`src/page/prod`）\n\n- 【lingjing-server】：低代码平台的server端项目。包含用户登录认证、权限、应用模块、页面模块、模版和区块模块等。\n\n- 【lowcode-engine】：低代码引擎源码。\n\n- 【lowcode-materials】：低代码物料库。目前包含antd、antd-pro、fusion的物料库。符合cfe-ui规范，部分组件进行优化，更易于使用。\n\n### 我的职责\n\n1. 参与低代码技术前期调研。\n\n2. 负责低代码平台部分业务模块的开发（web + server）。\n\n3. 参与部分低代码物料的开发、使用、测试。\n\n4. 参与低代码编辑页、预览、线上渲染页开发和优化。\n\n### 技术实现\n\n1. 底层框架基于[lowcode-engine](https://lowcode-engine.cn/)。\n\n2. web ui使用react、antd。\n\n3. server端使用egg.js、egg-redis、mysql数据库。\n\n### 截图\n\n![首页](./lixiang/lingjing_home.jpg)\n![应用详情](./lixiang/lingjing_app_detail.jpg)\n![模块区块中心](./lixiang/lingjing_materials.jpg)\n![低代码编辑页](./lixiang/lingjing_editor.jpg)","slug":"/灵境低代码平台"},{"id":"edf84ccb-a123-5201-bdfe-829f6e291543","title":"低代码现状调研","tags":["低代码"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAXAQADAQAAAAAAAAAAAAAAAAAAAQID/9oADAMBAAIQAxAAAAHn1ZZzwiC//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAIBEBExMv/aAAgBAQABBQJemMyRt6//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAWEAEBAQAAAAAAAAAAAAAAAAAQATH/2gAIAQEABj8CNIf/xAAaEAEAAwADAAAAAAAAAAAAAAABABEhEDFB/9oACAEBAAE/IcDuVHG73ICZBPBwXP/aAAwDAQACAAMAAAAQsM//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQMBAT8QtY//xAAWEQEBAQAAAAAAAAAAAAAAAAAAARH/2gAIAQIBAT8QrH//xAAcEAACAgIDAAAAAAAAAAAAAAABEQAhMWFBUXH/2gAIAQEAAT8QRUoUwfYNUQzYgIEDZi7gPW4IFQrjM2cz/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/8275e/default_img7.jpg","srcSet":"/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/fd641/default_img7.jpg 183w,\n/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/2a971/default_img7.jpg 367w,\n/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/8275e/default_img7.jpg 733w","sizes":"(min-width: 733px) 733px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/bd419/default_img7.avif 183w,\n/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/fcbd2/default_img7.avif 367w,\n/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/f8378/default_img7.avif 733w","type":"image/avif","sizes":"(min-width: 733px) 733px, 100vw"},{"srcSet":"/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/1be9d/default_img7.webp 183w,\n/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/6963a/default_img7.webp 367w,\n/leon-blog/static/f278a0a75dff4aa3c04b315102aba9cb/0eb16/default_img7.webp 733w","type":"image/webp","sizes":"(min-width: 733px) 733px, 100vw"}]},"width":733,"height":368},"body":"---\ntitle: \"低代码现状调研\"\ncover: images/default_img7.jpg\ncoverAlt: \"封面\"\ndescription: \"低代码的技术调研\"\ndatePublished: \"2022-10-10 22:07:49\"\ndateModified: \"2022-10-10 22:07:49\"\ncategory: \"经验总结\"\ntags:\n  - 低代码\n---\n\n> 🎯 在一个崇高的目标支持下，不停地工作，即使慢，也一定会获得成功。 —— 爱因斯坦\n\n### LowCode\n    \n低代码通常指aPaaS产品。aPaaS理解为PaaS的一种子形式。aPaaS的全称是application Platform as a Service，即应用程序平台即服务。  “aPaaS是基于PaaS（平台即服务）的一种解决方案”。\n\n![](./lowcode/apaas.jpg)\n\n| 名称 | 简介 | 代表产品 |\n| ---- | ---- | ----|\n| IaaS | 基于云的服务，按需付费，用于存储，网络和虚拟化等服务 | AWS，阿里云，腾讯云，华为云 |\n| PaaS | Internet上可用的硬件和软件工具 | Microsoft Azure，百度BAE、新浪SAE、京东云擎JAE |\n| SaaS | 可通过互联网通过第三方获得的软件 | 钉钉，企业微信，飞书 |\n| aPaaS | PaaS的一种子形式 nocode/lowcode/ 可扩展性 云服务 | 简道云、明道云、氚云伙伴云 OutSystems Redmine，Jira，Odoo，Smartsheet, Airtable Zoho Creator |\n\nPaaS 和aPaas都可以完成软件的开发和部署，都支持云端访问。而两者的差异主要体现在用户人群和使用环境不一样。\n\n| 名称 | 区别 |\n| ---- | ---- |\n| PaaS | PaaS包含所有平台级别的服务，**需要技术人员在本地完成应用程序的开发和数据提供**，然后部署到PaaS平台上，再分发给用户使用。 |\n| aPaaS | APaaS是PaaS的一种子形式，在APaaS模式下，**非技术人员**可以直接在**云端完成**应用程序的搭建、部署、使用、更新和管理。 |\n\n### 低代码行业现状\n\n> [艾瑞产业研究洞察-艾瑞咨询](https://www.iresearch.com.cn/Detail/report?id=3745&isfree=1)\n\n##### 企业应用场景\n\n![](./lowcode/changjing.jpg)\n\n##### 各企业的场景覆盖率\n\n![](./lowcode/fugailv.jpg)\n\n##### 近期融资情况\n\n艾瑞咨询预测：中国LCAP（低代码开发平台）市场**预计2025年达到131亿，未来5年复合增速为52.6%**。\n\n![](./lowcode/rongzi.jpg)\n\n![](./lowcode/changshang.jpg)\n\n### 低代码技术分类\n\n##### D2C\n\n即设计稿转代码（Desgin to Code）。输入设计稿，经过一系列算法，最终输出代码。\n\n![](./lowcode/d2c.jpg)\n\n代表技术：\n- 蚂蚁 [imgcook](https://www.imgcook.com/)\n- 京东 [deco](http://deco-preview.jd.com)\n- [CodeFun](https://code.fun/)\n\n##### 表单/表格/图表\n\n代表技术：\n- 阿里 [x-render](https://xrender.fun/)\n\n    用JsonSchema描述页面，并在页面中使用sdk渲染。FormRender支持表单设计、表单渲染；TableRender支持表格渲染；ChartRender支持图表渲染。\n\n- [form-generator](https://jakhuang.github.io/form-generator/#/)\n\n    Element UI表单设计及代码生成器。通过拖拽组件生成基于Element-UI的代码。\n\n- 阿里 [formilyjs](https://designable-antd.formilyjs.org/)\n\n    Formily表单设计器是基于[designable](https://github.com/alibaba/designable)而开发的扩展包，它在继承了 designable 的基础能力上，提供了 Formily 基础表单的搭建和配置能力。支持Ant Design和FussionUI。\n\n##### 前端页面搭建\n\n代表技术：\n- [阿里低代码引擎](https://lowcode-engine.cn/docV2/intro)\n\n    一套面向扩展设计的企业级低代码技术体系。\n\n- [百度amis](https://aisuda.bce.baidu.com/amis/zh-CN/docs/index)\n\n    强大的前端低代码框架，不受前端技术更新影响通过 JSON 配置就能生成各种页面。\n\n- [brick-design](https://brick-design.github.io/brick-design/)\n\n    全场景流式布局，可视化拖拽、随意嵌套组合、实时渲染、实时辅助线展示、支持逻辑渲染。\n\n##### 全栈低代码\n\n代表技术：\n- [JeecgBoot](http://www.jeecg.com/)\n\n    企业级低代码平台，可在页面创建表单，自动生成数据库表，增删改查页面等；也可生成代码并手动部署。\n    ![](./lowcode/jeecg.jpg)\n\n    > [jeecg-boot低代码平台调研](https://li.feishu.cn/docs/doccnMIlbbG0i7RxoxNnmkXL0Be)\n\n- [ELADMIN](https://eladmin.vip/)\n\n    B端管理后台项目框架。集成了通用前后端技术的框架，并自带了管理后台常用的通用功能模块。并支持代码生成的功能。\n\n##### 数据库转电子表格\n\n代表技术：\n- [NocoDB](https://github.com/nocodb/nocodb)\n\n    可以将 MySQL、PostgreSQL、SQL Server、SQLite 或 MariaDB等关系数据库转换为智能电子表格。\n\n    ![](./lowcode/nocodb1.jpg)\n    ![](./lowcode/nocodb2.jpg)","slug":"/低代码现状调研"},{"id":"d879747e-31bd-5dbd-8ebf-96b560ccef8e","title":"MessUi","tags":["Android端","Java","UI框架","开源"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAACaElEQVQoz22Sy0tUcQBG7zaCkArRJMOkt6amlZL2UtRMSpPSUiQrIopw0TZaBK2qhXlfvzt3hskWQQsLi5JerqKyh+N7Hjq+xplxtBw11ydmRmkW/QMfh+8cacnWzILtBvPWq/y2XmLO2kjIPE/QcpaApZppo5Ipo5wJo4Rx4whecYgRcRC3vg+XtpdhbTeD2jb61TT61M1Ii7abhK3XmLde4Ze1iVmzgRmzjqBZg99yCp/lJJNGKePGMcZEEaN6AR59P249B6eeyZC2kwE1nT51C71KClI83ayoI2ReICiq8BunmbZUMiVKmRDHo4Neo4gRkY9H5OHUMhlSdzCopNOvxegcShJS2LZCZzYSfnmXGXGGufZbBNsa8IlypqyVTJileNUDeOQs3EomTnkXLiMHp5nLkCWDPjWVXjWFHiUxMhihu8ysqGW5t4Pw+wcsfBL47efwWSv54+pkydVJqOsewQ93mH7dTODjbabeXGfmy0NG22twtCbiUDfxU9mIFPvuIrNmPeG39wl3tbDw1U7gaROTRhlLw6+ig8uTn1kYes784DMWve8IdbcQdr3A21FPz6MN9KhJ/JDXI8WbDT1uxK+VE3jSwLS9hglRzLhZjNc4zFhbBaP2YkbsR3HbC3G3FeFsK6BPT4t+F6H7LicgrdLNmLUEjGr8ZhU+UcakKGFcRMwWMqrn41azcSkZDCsrIuRUeluTcSjJ0e8idN/kdUj/7c5yIq67wmh3HpGLS89iWN/DoLadAW1rVIZDTY7RKQl0y2uRYt3VErSsdlcR607Ed5eHW8/GqWfEutP+dRdP1y2v4S+kziuUTIAqEAAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/f945c/messui_cover.png","srcSet":"/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/6c0e0/messui_cover.png 184w,\n/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/b5bc4/messui_cover.png 368w,\n/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/f945c/messui_cover.png 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/9d028/messui_cover.avif 184w,\n/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/c6ee4/messui_cover.avif 368w,\n/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/b4627/messui_cover.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/ef27d/messui_cover.webp 184w,\n/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/4ae45/messui_cover.webp 368w,\n/leon-blog/static/3fd3e1cf92e7feec10681d0ba29ff76e/20e6b/messui_cover.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"MessUi\"\ncover: images/messui_cover.png\ncoverAlt: \"封面\"\ndescription: \"Messui是一个高效的android平台页面框架\"\ndatePublished: \"2017-03-17 14:33:20\"\ndateModified: \"2017-03-17 14:33:20\"\ncategory: \"框架工具\"\ntags:\n  - Android端\n  - Java\n  - UI框架\n  - 开源\n---\n\nMessUi是一个高效的android平台页面框架。\n\ngithub仓库：https://github.com/missmess/Messui\n\n---\n\n### 如何使用\n\n1. build.gradle添加以下依赖：\n\n    ```java\n    implementation 'com.missmess.messui:messui:1.0.2'\n    ```\n2. Activity继承CoreActivity，并实现抽象方法：\n\n    ![](./messui/implements.jpg)\n\n### 有哪些功能？\n\n1. **默认包含最常见的Android页面布局。**\n\n    框架包含了Android上最常见的页面布局结构：*状态栏+标题栏+内容区*。\n\n    - 状态栏可修改任意颜色、融入背景、隐藏。\n\n    - 标题栏默认包含左侧返回+文字、居中标题、右侧按钮区。可任意定制。\n\n    - 内容区已默认包含加载中、加载失败、实际内容（加载成功）、下拉刷新、上拉加载。\n\n    ![DEMO](./messui/main.jpg)\n\n2. **链式调用，一秒设置页面元素**\n\n    通过BuilderKit链式调用的方式，轻松设置页面布局结构。\n\n    `kit.tb`为标题栏builder，控制标题栏；`kit.sb`为系统布局builder，控制状态栏和底部导航栏；`kit.lb`为loading builder，控制加载中、加载失败/成功；`kit.rb`为下拉刷新builder，控制下拉刷新和上拉加载。\n\n    `xx.enable()`代表启用该布局，启用后方可链式调用页面元素设置。\n\n    ```java\n    // 继承框架的CoreActivity\n    public class MainActivity extends CoreActivity<TitleBuilderRaw, LoadViewBuilderRaw, RefreshBuilderRaw> {\n\n        @Override\n        protected int getLayoutResId() {\n            // 只需要在layout定义加载成功的布局，并返回\n            return R.layout.activity_main;\n        }\n\n        @Override\n        public void buildLayout(BuilderKit<TitleBuilderRaw, LoadViewBuilderRaw, RefreshBuilderRaw, SystemUIBuilderRaw> kit) {\n            // 通过BuilderKit设置页面布局，链式调用\n            kit.tb.enable().title(\"您好啊，开发者\").bgColor(Color.GRAY)\n                    .navigateText(\"饭回\")\n                    .navigateTextColor(Color.GREEN)\n                    .titleColor(Color.BLACK);\n            kit.lb.enable().loadingTip(\"😊 稍等一下哦\");\n            kit.rb.enable().enableRefresh(new Runnable() {\n                @Override\n                public void run() {\n                    ((SwipeRefreshLayout) getRefreshLayout()).setRefreshing(false);\n                }\n            });\n            kit.sb.enable().statusBarColor(Color.BLACK).navigationBarColor(Color.RED);\n        }\n    }\n    ```\n\n3. **支持Activity和fragment**\n\n    同时支持activity和fragment，只需要集成`CoreActivity`、`CoreFragment`即可使用。\n\n4. **还不满足需求？可自定义主题**\n\n    框架本身包含很丰富的设置项，但是如果还是不满足需求，也支持自定义。\n\n    ```java\n    // 布局代理抽象为LayoutDelegate接口，默认布局使用的是DefaultLayoutDelegate\n    // 可自己继承LayoutDelegate接口实现新的布局\n    @Override\n    protected LayoutDelegate createLayoutDelegate() {\n        return new DefaultLayoutDelegate(this);\n    }\n    ```\n\n    继承LayoutDelegate接口实现即可。\n\n    并且如果只想替换其中某一部分（比如只换标题栏），也支持。实现接口时，其他部分仍使用Default实现即可。\n\n    ![内置布局factory](./messui/default_view.jpg)","slug":"/mess-ui"},{"id":"ccf76cb8-febf-57a7-9cdc-e027cf70f329","title":"秒聊","tags":["Android端","Uniapp","跨平台"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAABAAD/8QAFgEBAQEAAAAAAAAAAAAAAAAABAED/9oADAMBAAIQAxAAAAFpGmVoW0kT/8QAFxABAQEBAAAAAAAAAAAAAAAAAQIQIf/aAAgBAQABBQJOVLJl5//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAEDAQE/ASf/xAAWEQADAAAAAAAAAAAAAAAAAAACEDH/2gAIAQIBAT8BGr//xAAWEAADAAAAAAAAAAAAAAAAAAAAICH/2gAIAQEABj8CKv8A/8QAGhABAAIDAQAAAAAAAAAAAAAAAQARECFBUf/aAAgBAQABPyGyClGvXHIldsZ//9oADAMBAAIAAwAAABBvH//EABcRAAMBAAAAAAAAAAAAAAAAAAABMUH/2gAIAQMBAT8QXB0//8QAFhEAAwAAAAAAAAAAAAAAAAAAAAER/9oACAECAQE/EGqFP//EABkQAQADAQEAAAAAAAAAAAAAAAEAETEhQf/aAAgBAQABPxBkDXkERCwDX2K3GKQiDwWAvJ//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/b8370/cover.jpg","srcSet":"/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/fd641/cover.jpg 183w,\n/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/a7075/cover.jpg 365w,\n/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/b8370/cover.jpg 730w","sizes":"(min-width: 730px) 730px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/bd419/cover.avif 183w,\n/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/474b1/cover.avif 365w,\n/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/a15e0/cover.avif 730w","type":"image/avif","sizes":"(min-width: 730px) 730px, 100vw"},{"srcSet":"/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/1be9d/cover.webp 183w,\n/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/0eba5/cover.webp 365w,\n/leon-blog/static/5161908bbf11a18163ab53c3ac14a899/6127a/cover.webp 730w","type":"image/webp","sizes":"(min-width: 730px) 730px, 100vw"}]},"width":730,"height":366},"body":"---\ntitle: \"秒聊\"\ncover: miaoliao/cover.jpg\ncoverAlt: \"封面\"\ndescription: \"秒聊是附近陌生人交友APP\"\ndatePublished: \"2023-12-29 10:07:49\"\ndateModified: \"2023-12-29 10:07:49\"\ncategory: \"应用项目\"\ntags:\n  - Android端\n  - Uniapp\n  - 跨平台\n---\n\n**秒聊**主打附近陌生人聊天交友。秒聊牵线能为你智能推荐最匹配你的异性，同城交友秒连接。\n\nAPP下载：http://miaoliao.siyisea.com/appdl/index.html\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n**附近异性秒连接**\n\n  秒聊智能推荐附近你可能感兴趣的异性。秒聊小助手为你搭桥牵线。\n\n**真人交友**\n\n  秒聊推荐用户进行真人认证，通过认证才能获得优先推荐和积分奖励。\n\n**与TA互动**\n\n  看到喜欢的异性，可以和TA私聊，点赞/评论动态，发送礼物，发送喜欢。到达一定的亲密度，还能解锁语音/视频通话。\n\n**赢积分，可提现**\n\n  及时回复异性的搭讪，或者接听追求者的语音/视频通话，可以获得积分奖励，积分可提现。做任务也能获得丰富的积分奖励。\n\n**邀请好友**\n\n  邀请立得奖励，并且获得持续的积分返现。\n\n### 我的职责\n\n1. 负责秒聊APP的产品功能设计。\n\n2. 负责秒聊APP的风格、UI、交互设计。\n\n3. 秒聊APP开发，跨平台。\n\n4. 技术方案设计，im通信协议和全局弹窗规范。\n\n### 技术实现\n\n1. 使用uniapp开发app，支持Android、iOS。H5支持预览（很多功能无法正常使用）。\n\n2. 基础ui使用uview，主要页面为vue页面，复杂页面使用nvue开发。\n\n3. im聊天sdk使用wildfire uniapp sdk。\n\n4. 推送使用unipush。\n\n5. 一键登录使用aliyun号码认证sdk。\n\n6. 动画部分使用lottie，礼物特效使用svga。\n\n7. 部分页面使用webview加载h5页面。\n\n8. 秒聊已经做了很极致的性能优化，可惜uniapp能优化的空间很有限。\n\n   - 逻辑层与渲染层分离，导致通信有一定成本。实际测试css动画要比uni-transition，在低端机上流畅的多。\n\n   - Native.js虽然很强大，可以任意调用原生类和方法，无奈加载很慢。低端机无法使用，所以只能使用原生插件或uts插件，但是仍然有一定加载耗时。\n\n   - 在onLoad中执行耗时操作，直接导致白屏时间很长。\n\n   - vue的watch监听，使用immediate: true，会卡渲染。\n\n   - 等等等...\n\n### 截图\n\n![启动页](./miaoliao/splash.jpg)\n![登录](./miaoliao/login.jpg)\n![首页](./miaoliao/home.jpg)\n![动态广场](./miaoliao/posts.jpg)\n![我的](./miaoliao/mine.jpg)\n![聊天列表](./miaoliao/messages.jpg)\n![聊天](./miaoliao/chat.jpg)\n![用户详情](./miaoliao/user.jpg)\n![积分提现](./miaoliao/jifeng.jpg)\n![编辑信息](./miaoliao/edit-profile.jpg)","slug":"/秒聊"},{"id":"eafd57a3-9610-5cab-930d-51e582fda3cd","title":"秒聊-H5页","tags":["前端","Vue3","Vant","Vite"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMCBAX/xAAWAQEBAQAAAAAAAAAAAAAAAAACAwT/2gAMAwEAAhADEAAAAa82vq88DQ//xAAcEAABAwUAAAAAAAAAAAAAAAACAAEDEBEiMTL/2gAIAQEAAQUCBsjitSHQ8r//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREx/9oACAEDAQE/AVsKf//EABkRAAEFAAAAAAAAAAAAAAAAAAACAxESIf/aAAgBAgEBPwF1eyWP/8QAHBAAAQQDAQAAAAAAAAAAAAAAAQAQETECEiJx/9oACAEBAAY/AusZlbWKDFH1v//EABsQAQEBAAIDAAAAAAAAAAAAAAERACFRMUFx/9oACAEBAAE/IeFEGFwNdpHr7mjEm5W9JNytnlb3v//aAAwDAQACAAMAAAAQnP8A/8QAFxEBAAMAAAAAAAAAAAAAAAAAABEhof/aAAgBAwEBPxDBKj//xAAYEQADAQEAAAAAAAAAAAAAAAAAARFBYf/aAAgBAgEBPxCElqvYJz//xAAdEAEAAgICAwAAAAAAAAAAAAABABEhQTFxUWHB/9oACAEBAAE/ECowIOtoxECUG3lfPUNoI5HUaFWZDWNTA5Fee5ahKqte5//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/fff17/cover.jpg","srcSet":"/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/9fa5a/cover.jpg 184w,\n/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/63e75/cover.jpg 368w,\n/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/fff17/cover.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/9d028/cover.avif 184w,\n/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/c6ee4/cover.avif 368w,\n/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/b4627/cover.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/ef27d/cover.webp 184w,\n/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/4ae45/cover.webp 368w,\n/leon-blog/static/838e0e7a94d5a634e9ebbc9ef66b175a/20e6b/cover.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"秒聊-H5页\"\ncover: miaoliao-h5/cover.jpg\ncoverAlt: \"封面\"\ndescription: \"秒聊H5页包含微信分享、微信邀请、app下载、帮助与问答、在线客服等页面\"\ndatePublished: \"2023-12-20 13:18:20\"\ndateModified: \"2023-12-20 13:18:20\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - Vue3\n  - Vant\n  - Vite\n---\n\n秒聊-H5页是开发秒聊H5页面的项目，包含微信分享、微信邀请、app下载、帮助与问答、在线客服、H5活动等页面。\n\n访问地址：http://miaoliao.siyisea.com/share-for-user?id=i2gqmws2k&share_userid=82gqmws2k&from_client=android\n\n查看：[《秒聊》](/秒聊)\n\n---\n\n### 截图\n\n![分享用户](./miaoliao-h5/share.jpg)\n![帮助中心](./miaoliao-h5/help.jpg)\n![反馈](./miaoliao-h5/feedback.jpg)\n![APP下载](./miaoliao-h5/download.jpg)\n![星座控](./miaoliao-h5/constellation.jpg)","slug":"/秒聊-h-5-页"},{"id":"382ed567-3bfd-5a2c-9827-504be25afa85","title":"min-ruoyi","tags":["前端","Vue2","脚手架","开源","低代码"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAQF/8QAFgEBAQEAAAAAAAAAAAAAAAAAAgAB/9oADAMBAAIQAxAAAAGnREQ2/8QAGBAAAgMAAAAAAAAAAAAAAAAAAhEEIDL/2gAIAQEAAQUClNBmn//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABwQAAEDBQAAAAAAAAAAAAAAAAIAARESICExQf/aAAgBAQAGPwIYOlN3G7f/xAAbEAACAQUAAAAAAAAAAAAAAAABIQARIDFhcf/aAAgBAQABPyFKUm8Vm2jq3//aAAwDAQACAAMAAAAQCA//xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAwEBPxAn/8QAFhEAAwAAAAAAAAAAAAAAAAAAARAh/9oACAECAQE/EDV//8QAGxABAQADAAMAAAAAAAAAAAAAEQEAEDEhUXH/2gAIAQEAAT8QESXFqk9YBqfB4d0S9mGv/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/dba67/cover.jpg","srcSet":"/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/891f5/cover.jpg 176w,\n/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/19cc4/cover.jpg 352w,\n/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/dba67/cover.jpg 704w","sizes":"(min-width: 704px) 704px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/94818/cover.avif 176w,\n/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/bd4f6/cover.avif 352w,\n/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/2856f/cover.avif 704w","type":"image/avif","sizes":"(min-width: 704px) 704px, 100vw"},{"srcSet":"/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/76df1/cover.webp 176w,\n/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/d3e0a/cover.webp 352w,\n/leon-blog/static/0df1386c1ae5988f8bf01e978867242a/b4509/cover.webp 704w","type":"image/webp","sizes":"(min-width: 704px) 704px, 100vw"}]},"width":704,"height":368},"body":"---\ntitle: \"min-ruoyi\"\ncover: min-ruoyi/cover.jpg\ncoverAlt: \"封面\"\ndescription: \"ruoyi-vue优化后的最简版本，可以作为常用后台的脚手架\"\ndatePublished: \"2023-01-04 20:09:19\"\ndateModified: \"2023-01-04 20:09:19\"\ncategory: \"框架工具\"\ntags:\n  - 前端\n  - Vue2\n  - 脚手架\n  - 开源\n  - 低代码\n---\n\nmin-ruoyi是将ruoyi-vue优化后的最简版本，可以作为ruoyi后台管理项目的启动脚手架\n\ngitee仓库：https://gitee.com/missmess/min-ruoyi-vue2-ui-starter\n\n---\n\n### 有什么变化？\n\n官方的ruoyi-vue，包含了太多的测试页面和测试数据，并且样式有很多不合理、不好看的地方。\n\n*这个最简版本就是解决了这些问题*\n\n### 如何使用\n\n直接clone项目，对接RuoYi的server address后，即可使用。\n","slug":"/min-ruoyi"},{"id":"0740c402-a7b3-5b3f-8578-0beb8d068b9d","title":"云流-Nocodb应用","tags":["前端","Vue3","Nuxt","Antd","后端","Node.js","Express","Vite"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAEF/8QAFAEBAAAAAAAAAAAAAAAAAAAAAP/aAAwDAQACEAMQAAAB3gUH/8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQABBQJf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAFhABAQEAAAAAAAAAAAAAAAAAERAg/9oACAEBAAE/ISGP/9oADAMBAAIAAwAAABBwz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABsQAAMAAgMAAAAAAAAAAAAAAAABETFBEGGR/9oACAEBAAE/EMFXSLBPfppGuP/Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/1ced9/table-view.jpg","srcSet":"/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/891f5/table-view.jpg 176w,\n/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/19cc4/table-view.jpg 352w,\n/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/1ced9/table-view.jpg 703w,\n/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/e43cf/table-view.jpg 1406w","sizes":"(min-width: 703px) 703px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/94818/table-view.avif 176w,\n/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/bd4f6/table-view.avif 352w,\n/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/5627e/table-view.avif 703w,\n/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/df159/table-view.avif 1406w","type":"image/avif","sizes":"(min-width: 703px) 703px, 100vw"},{"srcSet":"/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/76df1/table-view.webp 176w,\n/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/d3e0a/table-view.webp 352w,\n/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/e41d2/table-view.webp 703w,\n/leon-blog/static/bedf946bb3ea01ec0e2c9cd95bb724c3/e0cda/table-view.webp 1406w","type":"image/webp","sizes":"(min-width: 703px) 703px, 100vw"}]},"width":703,"height":368},"body":"---\ntitle: \"云流-Nocodb应用\"\ncover: nocodb/table-view.jpg\ncoverAlt: \"多维表格模块\"\ndescription: \"Nocodb为云流提供数据展示能力\"\ndatePublished: \"2023-04-10 13:35:12\"\ndateModified: \"2023-04-10 13:35:12\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - Vue3\n  - Nuxt\n  - Antd\n  - 后端\n  - Node.js\n  - Express\n  - Vite\n---\n\n**云流-Nocodb应用**是类似于Airtable、飞书多维表格的数据生产力产品。\n\n访问地址：http://114.55.92.229:8080/dashboard/#/\n\n可以独立连接数据库使用，此时的Nocodb作为纯多维表格去使用。\n\n也可以嵌入到[云流](/云流)中，此时除了可以作为多维表格使用，创建的表格还可以当作流程表单中的数据关联。\n\n参考：[nocodb v0.100.2](https://github.com/nocodb/nocodb)。\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n1. **多维表格**\n\n    涵盖主流多维表格大部分功能，包括：\n\n    - 常用表格组件：文本、单选、多选、日期、时间、手机、邮箱、链接、上传附件、图片、货币、百分比、小数等30+\n    - 高级组件：数据关联、公式、汇总、JSON、数据库、查找等\n    - 排序、筛选、隐藏字段、表格内数据查询\n    - 支持表格、卡片、画廊、看板视图展示数据\n    - 支持快速导入xlsx、csv等常见文档\n    - 表格可添加评论\n\n2. **6种角色权限**\n\n  超级管理员、项目管理员、所有者、编辑者、评论者、查看者\n\n3. **组件可自定义**\n\n  支持新增组件，修改组件\n\n4. **AI扩展**\n\n  可以添加AI扩展，来对表格数据进行分析、修改、插入列等处理操作。\n\n  ![AI扩展](./nocodb/aiextension.jpg)\n\n5. **连接外部数据源**\n  - 能连接外部数据库创建项目\n  ![连接外部数据库](./nocodb/external.jpg)\n  - 可以导入外部数据到表格\n  ![导入外部数据](./nocodb/import.jpg)\n\n### 我的职责\n\n1. 产品UI调整。\n\n2. nocodb GUI研发、功能扩展。\n\n3. nocodb server端修改、扩展。\n\n### 技术实现\n\n1. GUI使用Nuxt、ant-design-vue、windicss开发。\n\n2. server端使用express开发。\n\n3. db部分使用knex抹平各数据库之间的差异。\n\n### 截图\n\n![登录](./nocodb/login.jpg)\n![项目](./nocodb/project.jpg)\n![表格](./nocodb/table-view.jpg)","slug":"/云流-nocodb应用"},{"id":"f640da73-51a0-5b70-b5ac-06d66d4b78a9","title":"procomponents-template","tags":["前端","React","脚手架","开源","低代码","Vite"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAMBBAX/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAdKLBooaR//EABgQAAIDAAAAAAAAAAAAAAAAAAAiARIg/9oACAEBAAEFAnHItj//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAYEAACAwAAAAAAAAAAAAAAAAAAQhEgIf/aAAgBAQAGPwJRTYp//8QAGhAAAQUBAAAAAAAAAAAAAAAAAAERICHw4f/aAAgBAQABPyHVj4U4kP/aAAwDAQACAAMAAAAQMO//xAAWEQADAAAAAAAAAAAAAAAAAAAAARH/2gAIAQMBAT8QrKz/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPxCI/8QAHBAAAgICAwAAAAAAAAAAAAAAAREAISAxQVGB/9oACAEBAAE/ECnYeIDlb8XaUFHdW1h//9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/fff17/procomponents_cover.jpg","srcSet":"/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/9fa5a/procomponents_cover.jpg 184w,\n/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/63e75/procomponents_cover.jpg 368w,\n/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/fff17/procomponents_cover.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/9d028/procomponents_cover.avif 184w,\n/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/c6ee4/procomponents_cover.avif 368w,\n/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/b4627/procomponents_cover.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/ef27d/procomponents_cover.webp 184w,\n/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/4ae45/procomponents_cover.webp 368w,\n/leon-blog/static/b8db5f68157645c122f55f49912c1e2a/20e6b/procomponents_cover.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"procomponents-template\"\ncover: lixiang/procomponents_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"ProComponents封装的低代码脚手架\"\ndatePublished: \"2021-12-02 10:50:54\"\ndateModified: \"2021-12-02 10:50:54\"\ncategory: \"框架工具\"\ntags:\n  - 前端\n  - React\n  - 脚手架\n  - 开源\n  - 低代码\n  - Vite\n---\n\n使用ProComponents封装的带页面模版的低代码脚手架。方便**后台开发人员**或**不熟悉React开发语言的开发者**，能自己轻松搭建常见后台的crud列表页及详情页。\n\ngitee仓库：https://gitee.com/missmess/pro-components-template.git\n\n---\n\n### 为什么是ProComponents\n\nProComponents提供了更高级的业务组件，覆盖中后台应用很大程度上的页面开发需求。比起Ant Design的组件，需要开发的工作量骤减。将写代码的工作转变为写json配置的工作。很适合做过开发但是不会React的程序员快速搭建高质量的页面。\n\n### 主要功能\n\n1. 使用ProLayout搭建顶层页面，包含*左侧可伸缩菜单栏+顶部标题栏+内容区*。\n\n2. 支持左侧菜单配置，在menus.tsx中修改即可。\n\n3. 支持面包屑。\n\n4. 自带骨架屏。过渡效果优秀。\n\n5. 默认template已包含crud列表页、和支持新增、编辑、详情展示的页面。需要新增页面时只需要拷贝整个目录再修改其中的代码。\n\n### 技术点\n\n1. 基于vite、React开发。\n\n2. 使用ProComponents开发页面。\n\n### 使用指南\n\n新增某个新业务的crud功能时，按照以下几个步骤即可：\n\n1. 在`src/menus.tsx`，增加路由的配置。\n\n2. 在`src/mapping.tsx`指定路由和组件的映射关系。\n\n3. 拷贝实例的`src/pages/car/sale`目录，生成新的业务目录。\n\n4. 新目录下的`index.tsx`为列表页，修改`columns`中的json数据，想要在表格中展示接口的什么字端，配置到`title`和`dataIndex`中。\n\n    ```javascript\n    // 示例\n    {\n      title: \"书籍名称\",\n      dataIndex: \"bookName\"\n    }\n    ```\n\n5. 修改查询接口、删除接口地址，修改跳转详情页的路由地址。\n\n6. 新目录下的`detail/index.tsx`为新增/编辑/详情页一体。修改查询详情接口、新增、编辑接口的地址。\n\n### 截图\n\n![主界面](./lixiang/procomponents_home.jpg)","slug":"/procomponents-template"},{"id":"027a1b71-1ca7-50c6-a83d-16dd075615d2","title":"麒小佑（小程序+后台）","tags":["小程序","前端","Vue3","ElementUI","Vite"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABUBAQEAAAAAAAAAAAAAAAAAAAAB/9oADAMBAAIQAxAAAAHdjUsYUP/EABgQAAIDAAAAAAAAAAAAAAAAAAACAxEg/9oACAEBAAEFAiNrz//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAABESAh/9oACAEBAAY/Ah7Nf//EABoQAAICAwAAAAAAAAAAAAAAAAABEBEhMVH/2gAIAQEAAT8hGcjBcUlpR//aAAwDAQACAAMAAAAQ8M//xAAWEQEBAQAAAAAAAAAAAAAAAAARAAH/2gAIAQMBAT8QdZv/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPxCI/8QAGhABAQADAQEAAAAAAAAAAAAAAREQMUEAIf/aAAgBAQABPxBVEN+sE1ucTeXAF+sN4//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/fff17/cover.jpg","srcSet":"/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/9fa5a/cover.jpg 184w,\n/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/63e75/cover.jpg 368w,\n/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/fff17/cover.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/9d028/cover.avif 184w,\n/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/c6ee4/cover.avif 368w,\n/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/b4627/cover.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/ef27d/cover.webp 184w,\n/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/4ae45/cover.webp 368w,\n/leon-blog/static/f2455473f22cc8340a7a5bdc81c107b1/20e6b/cover.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"麒小佑（小程序+后台）\"\ncover: qixiaoyou/cover.jpg\ncoverAlt: \"封面\"\ndescription: \"在线小儿推拿穴方生成小程序\"\ndatePublished: \"2023-12-17 11:21:43\"\ndateModified: \"2023-12-17 11:21:43\"\ncategory: \"应用项目\"\ntags:\n  - 小程序\n  - 前端\n  - Vue3\n  - ElementUI\n  - Vite\n---\n\n在线小儿推拿穴方生成、诊疗小程序。\n\n<video src=\"./qixiaoyou/video.MP4\" width=\"250\" autoplay muted controls />\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [小程序截图](#小程序截图)\n- [管理后台截图](#管理后台截图)\n\n### 主要功能\n\n1. 交互为AI助手对话形式。\n\n2. 根据病征智能生成穴方。\n\n3. 生成诊疗记录，可回访修改。\n\n4. 推拿师认证、申请。\n\n5. 【后台】管理推拿师、管理认证申请\n\n6. 【后台】管理穴方、管理病征\n\n### 我的职责\n\n1. 小程序UI设计。\n\n2. 小程序开发。\n\n3. 管理后台开发。\n\n### 技术实现\n\n1. 小程序使用原生开发。\n\n2. UI使用pixso设计。\n\n3. 助手对话过程为模拟对话，并非真实对话。抽象为aiSimulator驱动对话流程。\n\n4. 使用wxs优化wxml中的复杂计算。\n\n5. 后台基于[min-ruoyi](./min-ruoyi-2023-01.md)脚手架开发。\n\n### 小程序截图\n\n![](./qixiaoyou/login.jpg)\n![](./qixiaoyou/chat.jpeg)\n![](./qixiaoyou/create.jpeg)\n![](./qixiaoyou/end.jpeg)\n![](./qixiaoyou/mine.jpeg)\n![](./qixiaoyou/verify.jpg)\n\n### 管理后台截图\n\n![](./qixiaoyou/login2.jpg)\n![](./qixiaoyou/dashboard.jpg)","slug":"/麒小佑（小程序-后台）"},{"id":"3b77955a-3abb-59f7-b77c-05fad5dd7dc7","title":"React Fiber架构总览","tags":["前端","React","架构","造轮子"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABxpq1QP/EABYQAAMAAAAAAAAAAAAAAAAAAAABIP/aAAgBAQABBQIc/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAABEQAhIEGR/9oACAEBAAE/IQndxNAdx//aAAwDAQACAAMAAAAQS+//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAgEFAAAAAAAAAAAAAAABABEhEDFBYYH/2gAIAQEAAT8QYKKXkWrmPC7EzycaO8//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/da24c565e170845a9f10394ef98ce91a/38598/react-fiber.jpg","srcSet":"/leon-blog/static/da24c565e170845a9f10394ef98ce91a/3281a/react-fiber.jpg 186w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/3f3c9/react-fiber.jpg 372w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/38598/react-fiber.jpg 743w","sizes":"(min-width: 743px) 743px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/da24c565e170845a9f10394ef98ce91a/1043a/react-fiber.avif 186w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/75542/react-fiber.avif 372w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/4b780/react-fiber.avif 743w","type":"image/avif","sizes":"(min-width: 743px) 743px, 100vw"},{"srcSet":"/leon-blog/static/da24c565e170845a9f10394ef98ce91a/b2901/react-fiber.webp 186w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/f2d3a/react-fiber.webp 372w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/16c74/react-fiber.webp 743w","type":"image/webp","sizes":"(min-width: 743px) 743px, 100vw"}]},"width":743,"height":368.00000000000006},"body":"---\ntitle: \"React Fiber架构总览\"\ncover: ../static/assets/react-fiber.jpg\ncoverAlt: \"封面\"\ndescription: \"介绍React16带来的全新fiber架构，它的设计总览\"\ndatePublished: \"2023-02-09 11:20:41\"\ndateModified: \"2023-02-09 11:20:41\"\nslug: \"react-fiber-struct\"\ncategory: \"经验总结\"\ntags:\n  - 前端\n  - React\n  - 架构\n  - 造轮子\n---\n\n众所周知，React团队耗时2年多在React16发布了全新重构版本的Fiber架构，替代了原来的`Stack Recociler + Renderer`的架构组合。重构的主要升级目标就是，将老架构的**同步更新**，替换为**异步可中断的更新**模式，并由此带来了一系列新特性。本文会从总体的角度讲一下整个Fiber架构的工作流程。\n\n### 老架构\n\n在了解新架构之前，先来看看在此之前的老架构是什么样的，存在什么问题。React15的架构可以分为：\n\n- Reconciler（协调器）：负责对虚拟DOM使用Diff算法找出发生变化的组件\n- Renderer（渲染器）：负责根据组件的变化更新渲染到页面上\n\n> 老React的具体渲染流程可以看[我之前的文章](/vue-react-render)\n\n简单来说，**Reconciler**会在每次渲染流程中：\n\n1. 生成内部组件实例。函数组件或类组件调用render方法，将JSX转化为虚拟DOM。\n2. 新生成的虚拟DOM与上次的的进行对比。\n3. 找到可以复用的不用重新创建DOM，将变化通过**Renderer**渲染到页面上。\n4. 找不到可复用的，通过**Renderer**操作页面DOM。\n5. 对children递归处理，重复以上步骤。\n\n而**Renderer**则会去操作DOM节点的移动、更新、删除，这个过程是同步的。即**Reconciler**与**Renderer**是交替工作的，**Reconciler**发现变化就通知**Renderer**立即去渲染。直到整个渲染流程结束。\n\n> *React支持跨平台，主要体现在可以针对不同的平台有不同的Renderer*。我们最熟悉的是Renderer是[ReactDOM](https://www.npmjs.com/package/react-dom)，除此之外，还有大名鼎鼎的[React Native](https://www.npmjs.com/package/react-native)。\n\n**老架构的缺点**\n\n递归协调工作一旦开始，就无法结束，必须等待协调过程结束。如果节点太多，处理耗时太长（超过了16ms），则可能会导致页面出现掉帧、卡顿。\n\n### 新架构\n\n新架构不再使用内部组件来处理虚拟DOM的diff，而改为使用Fiber节点。每个Fiber节点既是一个独立工作单元，也是一个树节点，与其他Fiber节点共同组成Fiber树，同时也记录着动态的数据和状态。Fiber节点可以认为和每一个JSX节点一一对应。新架构下，不再是同步的实时更新，而是异步的可中断更新。\n\n新Fiber架构的设计分为：\n\n- Reconciler（协调器）：负责对Fiber节点进行对比，找出其中的变化\n- Renderer（渲染器）：负责根据组件的变化更新渲染到页面上\n- Scheduler（调度器）：调度任务的优先级，对更新任务的时间切片\n\n其中Fiber树还用到了“双缓存”的技术。\n\n**双缓存Fiber树**\n\n双缓存Fiber树就是React中存在两棵Fiber树，一棵是当前渲染在屏幕上的，叫**current**，另一棵是在内存中正在构建操作的，叫**workInProgess**。一旦构建完成，原来的current丢弃，current指向workInProgress，即完成了Fiber树的替换。\n\n在这样的架构模式下，工作模式变成了：\n\n1. Scheduler接收到更新，判断优先级，通知Reconciler开始工作。\n\n2. Reconciler进入render阶段。开始构建workInProgress树。进入workLoop（工作循环）。\n\n3. 对每一个工作单元（Fiber）进行beginWork（创建Fiber，diff和标记变化）。beginWork结束后，执行completeWork（创建DOM，children Append等）。\n\n4. 每完成一个工作单元，通过Scheduler判断是否要中断render阶段。\n\n5. render阶段结束后，进入commit阶段。开始对发生变化的节点提交DOM操作。\n\n6. 完成后，将current树指向workInProgress树。\n\n接下来就具体讲一下每个工作步骤。\n\n### 触发更新\n\n这些方法会触发一次渲染更新流程：`ReactDOM.render`、`this.setState`、`this.forceUpdate`、`useState`、`useReducer`等。每个更新具有不同的优先级。根据优先级的不同，会触发一次同步更新或异步调度的更新。\n\n同步更新执行后或者异步更新调度执行后，会进入render阶段。代码类似于：\n\n```javascript\nfunction performSyncWorkOnRoot(root) {\n  // render阶段\n  renderRootSync(root);\n  // commit阶段\n  commitRoot(root);\n}\n```\n\n### render阶段\n\nrender阶段从`FiberRoot`开始，创建第一个`workInProgress`。然后进入workLoop（工作循环）。针对每一个workInProgress工作单元，都对其执行`beginWork`和`completeWork`。类似于下面这段代码：\n\n```javascript\nfunction workLoop(root) {\n  let workInProgress = createWorkInProgress(root);\n  // 循环工作循环\n  while (workInProgress != null) {\n    let unitOfWork = workInProgress;\n\n    beginWork(unitOfWork);\n\n    if (unitOfWork.child !== null && !shouldYield()) {\n      workInProgress = unitOfWork.child;\n      continue;\n    }\n\n    let completedWork = unitOfWork;\n\n    do {\n      completeWork(completedWork)\n\n      const returnFiber = completedWork.return;\n      const siblingFiber = completedWork.sibling;\n      if (siblingFiber != null) {\n        workInProgress = siblingFiber;\n        break;\n      }\n\n      completedWork = returnFiber;\n      workInProgress = completedWork;\n    } while (completedWork != null);\n  }\n}\n```\n\n在工作循环中，会挨个处理每一个fiber节点，对每个fiber节点都会执行一次`beginWork`和`completeWork`，但是它们的执行时机不同。`beginWork`会以深度优先的方式，往子孙树从上往下执行。而`completeWork`是在每一个节点及其子孙都执行完`beginWork`后，往祖先树从下往上执行。\n\n*另外，工作循环是可中断和恢复的，即如果上面的`shouldYield()`返回true，那么`render阶段`就退出了。等待下次重新启动渲染流程，由于记录了workInProgress，所以可以恢复。React中的异步可中断更新就是中断的render阶段。*\n\n> 工作循环的具体设计思路，后续会补充一篇文章单独讲解。\n\n#### beginWork\n\n`beginWork`是协调器里最重要的一个方法。它是从上往下执行的，我们从`FiberRoot`开始只有一个新fiber节点，即第一个workInProgress，执行`beginWork`的目的是为了构建完整的workInProgress树。可以猜到`beginWork`的主要功能就是对比新旧fiber，协调出新的children fiber并链接到workInProgress上。具体步骤为：\n\n1. 判断workInProgress是否可以复用旧的fiber，可以复用（props和context都未变化），则克隆children fiber并挂到workInProgress树。跳过2、3步。\n\n2. 如果不可复用，则重新执行渲染函数（类组件或函数组件）获取newChildren或从props.children获取（Host组件）。\n\n3. 获取到newChildren后，和旧的fiber链表进行协调。协调过程就是diff，并标记变化（effectTag，后续根据这个判断如何变更DOM）到新fiber上。\n\n4. beginWork完成，返回child作为下一个工作单元。如果没有child，则进入`completeWork`。\n\n#### completeWork\n\n`completeWork`是在当前workInProgress fiber的子孙全部协调结束后执行的。它可以执行一些收尾工作。例如对于`HostComponent`，它执行了：\n\n1. 如果是update时（即存在旧fiber-current），处理变化的props，存储到`workInProgress.updateQueue`（会在commit阶段渲染到页面上）。\n\n2. 如果是mount时，为当前fiber创建对应的DOM节点。并将children的DOM节点插入进来。\n\n其他类型的组件处理的工作并不相同。到这里`completeWork`工作就结束了。\n\n#### effectList串联\n\n之前我们提到`beginWork`里会在fiber上标记变化，即effectTag。后续`commit`阶段需要用于变更DOM。为了方便后续该操作，React在`completeWork`完成后，额外执行了一个串联effectList的工作。\n\neffectList挂载在fiber上，其实就是一个单向链表，以`fiber.firstEffect`为第一个，`fiber.lastEffect`为最后一个，前一个的`nextEffect`指向后一个。\n\n1. 每个fiber判断自己是否有effectTag，如果有，把自己串到父fiber的effectList最后。\n\n2. 和`completeWork`一样，往祖先级从下往上执行，所以最终`rootFiber`上的effectList就是整棵树全部的effect了。\n\n### commit阶段\n\n`render阶段`结束后，直接进入`commit阶段`。顾名思义，就是将`render阶段`发生的effect，在该阶段提交到页面上。注意，不同于`render阶段`可以中断。`commit阶段`是同步执行的，不可中断。\n\nReact将`commit阶段`又分为三个小阶段。\n\n#### before mutation阶段\n\n`before mutation`是在执行具体的DOM操作之前。在这个阶段可以做一些准备工作。包括：\n\n1. 处理渲染/删除节点的focus/blur状态。\n\n2. 调用`getSnapshotBeforeUpdate`。（commit阶段是同步的所以该方法不会多次调用，`UNSAFE_componentWillReceiveProps`在render阶段被调用所以不安全）。\n\n3. 异步调度`useEffect`回调函数。\n\n它主要通过遍历effectList链表，来对有effect的节点进行这些处理。\n\n#### mutation阶段\n\n`mutation`是实实在在的执行DOM操作的阶段。\n\n它也是遍历effectList链表，然后对不同的effect进行处理，主要包含3种effect：\n\n**Placement**\n\n代表该fiber所复用的DOM节点需要更换位置。\n\n1. 如果有下一个稳定的兄弟DOM，则插入到兄弟DOM之前。这里有三个理解难点：\n\n    - 一是为什么要插入到下一个兄弟DOM之前？因为在之前`render阶段`的diff算法原理是遍历newChildren时，总是标记需要右移的fiber。这个fiber的下一个兄弟一定在它右边，所以fiber对应的dom一定在下一个兄弟dom的左边。\n    \n    - 二是查找兄弟DOM需要跨层级搜索，因为兄弟fiber不一定有兄弟DOM。兄弟dom可能就是它的sibling，但也有可能在它的父fiber的sibling树下，也有可能在它的sibling树下。\n\n    - 三是为什么要找稳定的兄弟？稳定是指没有被Placement标记的。因为如果兄弟被Placement标记了，那它对应的dom一定也会被移动，所以不能直接插入它前面。\n\n    （这里的逻辑比较复杂，后续会补充一篇文章，专门讲解一下整个Diff算法和mutation逻辑）\n\n2. 如果没有稳定的兄弟DOM，则插入到队尾。这个好理解。\n\n**Update**\n\n代表该fiber需要更新。对于不同的fiber，需要不同的处理。\n\n对于函数组件，执行`useLayoutEffect`的销毁函数。\n\n对于Host组件，会将之前`render阶段`-`completeWork`中赋值的`updateQueue`更新到dom上，其实就是更新dom属性。\n\n**Deletion**\n\n代表该fiber对应的dom需要被移除。当然包括它的子孙fiber节点。\n\n该方法主要处理几个操作：\n\n1. 递归处理fiber和它的子孙fiber。\n\n2. 移除对应的DOM节点。\n\n3. 解绑ref。\n\n4. 如果是类组件，调用`componentWillUnmount`生命周期。\n\n#### layout阶段\n\n`layout`阶段，是所有DOM修改完成后才执行的，这时候js代码或者在这个阶段触发的生命周期，都已经可以访问到修改后的DOM了。\n\n在这个阶段，也是遍历effectList列表。主要做了三件事：\n\n1. 对于有**Update**的fiber，如果是类组件，则触发生命周期componentDidMount或componentDidUpdate。\n\n2. 对于有**Update**的fiber，如果是函数组件，则同步执行useLayoutEffect的回调函数、异步调度useEffect的销毁函数与回调函数。\n\n3. 绑定ref。\n\n至此，layout阶段也完成了。替换一下workInProgress树，那么整个渲染更新流程就结束啦！\n\n```javascript\nroot.current = finishedWork;\n```\n\n### Scheduler调度器\n\n接着讲一下`Scheduler`，它在React中是一个独立的包。它的功能是作为任务调度器，用于控制任务执行时机。它主要包含两部分功能：**时间切片**和**优先级调度**。\n\n#### 时间切片\n\n时间切片的功能很像[requestIdleCallback](https://developer.mozilla.org/zh-CN/docs/Web/API/Window/requestIdleCallback)，即在浏览器每一帧中给予一定的时间去处理渲染逻辑，如果时间超出了，则中断渲染，控制权交还给浏览器。从而保持整个界面和交互的流畅。\n\n那为什么不直接用`requestIdleCallback`和`requestAnimationFrame`呢？\n\n一是`requestIdleCallback`调用时机不确定；\n\n二是各个浏览器对`requestIdleCallback`和`requestAnimationFrame`的实现不一样，有兼容性问题；\n\n三是React希望能实现更精细的任务优先级控制和执行时间控制。\n\nReact的Scheduler基于[MessageChannel](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L228-L234)，如果浏览器不支持`MessageChannel`，则fallback为[setTimeout](https://github.com/facebook/react/blob/1fb18e22ae66fdb1dc127347e169e73948778e5a/packages/scheduler/src/forks/SchedulerHostConfig.default.js#L47-L55)。\n\n联想到之前render阶段，在工作循环中，有一个`shouldYield()`方法。这个方法就是Scheduler提供的，用于判断下一个任务是否需要中断执行。\n\n它的原理就是在Scheduler中，会为任务执行分配一个时间。如果执行任务的耗时超过了分配的时间，则中断执行。等待到下一个时间切片再重新执行。\n\n#### 优先级调度\n\nScheduler提供了一个`scheduleCallback`方法，当需要优先级异步调度某个回调函数时，就调用这个方法。在`render阶段`和`commit阶段`，很多地方使用了这个方法来调度，比如渲染入口函数的异步调度、useEffect回调的异步调度等。\n\nScheduler设置了5种**优先级**，来控制任务的执行时机，不同的优先级有不同的过期时间。实现原理简单说来就是，Scheduler会将任务放在优先级队列中，队列中的任务按照过期时间排序，最快过期的在最前。每来一个新任务，就根据优先级计算过期时间，然后放入队列中重新排序。最终，取出最快过期的任务立即执行。\n\n### Lane模型\n\nLane模型是React内部对更新优先级进行协调、合并和执行的一套规则。在整个渲染更新流程中，到处都是它的身影。React将更新根据其优先级被分配到相应的 Lane 中，高优先级的更新会优先处理。\n\n使用场景：\n\n- 为用户交互事件触发的更新，提供更高优先级，确保该更新能更快渲染到界面上。（原理是React在调用事件处理器之前，事先设置好了优先级，当调用setState等方法时，能获取到该优先级）\n\n- 被`useTransition()`包裹的回调中触发的更新，将会降低优先级。从而不影响重要的更新。\n\nLane什么时候被生产？\n\nLane在触发一个更新请求的时候，React就会为这个请求生产一个lane值。\n\nLane怎么被消费？\n\nLane会被分配到update对象上，并标记到fiber上。最终会在触发更新流程的函数上被消费。\n\n> Lane模型比较复杂，难懂，后续会单独介绍。\n","slug":"/react-fiber-struct"},{"id":"289c9eac-39ce-5ab4-b7ec-c50c4628825a","title":"React Fiber架构之工作循环","tags":["前端","React","架构","造轮子"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABYBAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAABxpq1QP/EABYQAAMAAAAAAAAAAAAAAAAAAAABIP/aAAgBAQABBQIc/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAaEAACAgMAAAAAAAAAAAAAAAABEQAhIEGR/9oACAEBAAE/IQndxNAdx//aAAwDAQACAAMAAAAQS+//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAEAAgEFAAAAAAAAAAAAAAABABEhEDFBYYH/2gAIAQEAAT8QYKKXkWrmPC7EzycaO8//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/da24c565e170845a9f10394ef98ce91a/38598/react-fiber.jpg","srcSet":"/leon-blog/static/da24c565e170845a9f10394ef98ce91a/3281a/react-fiber.jpg 186w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/3f3c9/react-fiber.jpg 372w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/38598/react-fiber.jpg 743w","sizes":"(min-width: 743px) 743px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/da24c565e170845a9f10394ef98ce91a/1043a/react-fiber.avif 186w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/75542/react-fiber.avif 372w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/4b780/react-fiber.avif 743w","type":"image/avif","sizes":"(min-width: 743px) 743px, 100vw"},{"srcSet":"/leon-blog/static/da24c565e170845a9f10394ef98ce91a/b2901/react-fiber.webp 186w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/f2d3a/react-fiber.webp 372w,\n/leon-blog/static/da24c565e170845a9f10394ef98ce91a/16c74/react-fiber.webp 743w","type":"image/webp","sizes":"(min-width: 743px) 743px, 100vw"}]},"width":743,"height":368.00000000000006},"body":"---\ntitle: \"React Fiber架构之工作循环\"\ncover: ../static/assets/react-fiber.jpg\ncoverAlt: \"封面\"\ndescription: \"介绍React16带来的全新fiber架构，其中的WorkLoop\"\ndatePublished: \"2023-04-06 19:58:30\"\ndateModified: \"2023-04-06 19:58:30\"\nslug: \"react-workloop\"\ncategory: \"经验总结\"\ntags:\n  - 前端\n  - React\n  - 架构\n  - 造轮子\n---\n\n在[React Fiber架构总览](/react-fiber-struct)中我们提到，React16的新Fiber架构，将老架构的**递归同步的更新**，替换为**异步可中断的更新**。这个异步可中断指的就是工作循环的执行中断。\n\n本次我们就主要讲一讲：为什么要使用workLoop（工作循环）？它是怎么实现可中断的？为什么之前的老架构不可以中断？\n\n带着这些问题，我会用一些简化的代码讲清楚这个知识点。\n\n### 老架构的递归工作模型\n\n在讲新架构之前，先分析一下老架构是怎么做的。前面也提到了，老架构是通过递归实现的。简化的代码就如同下面：\n\n```javascript\nexport function mountRootTree(root) {\n    // React.createElement获取到的element转化为内部组件\n    const rootComponent = new InnerComponent(root);\n    // 调用内部组件.mount\n    const node = rootComponent.mount();\n    // 渲染\n    callRender(node);\n}\n\nclass InnerComponent {\n    mount() {\n        // 从props.children或render()函数获取children elements\n        const children = getChildren()\n        // 创建node\n        const parent = createNode();\n        // 遍历children，并渲染\n        children.forEach((child) => {\n            const childComponent = new InnerComponent(child);\n            const node = childComponent.mount();\n            // 渲染\n            callRender(node, parent);\n        })\n        return parent;\n    }\n}\n```\n\n可以看到，从根元素开始，每个element创建一个内部组件，然后调用内部组件的`mount()`方法。内部组件的mount()方法里再继续获取children elements，并创建child内部组件，然后递归调用child内部组件的mount()方法...整个组件树的工作就这样完成了。\n\n> 以上代码非常简化，只是想说明老架构是如何去递归处理各个节点的。详细分析可见我写的另一篇文章：[渲染流程：Vue vs React](/vue-react-render)\n\n从代码可以看出，这种递归的处理方式一旦开始，就要从头执行到结束，无法中断。\n\n### 新架构的Fiber工作循环\n\n在上面介绍的老架构中，每个element（可以理解为每个jsx节点）都创建了一个内部组件。在新的Fiber架构中，取而代之的是Fiber对象。Fiber对象属性比较多，我们这次就只看它跟组件树构成有关系的属性：\n\n```javascript\nfunction FiberNode(...) {\n    // ...\n\n    this.child = null; // 第一个子节点\n    this.sibling = null; // 相邻的下一个兄弟节点\n    this.return = null; // 父节点\n\n    // ...\n}\n```\n\n可以看到，FiberNode有三个属性child、sibling、return。每个属性都链接了另一个fiber节点。由这三个属性构成了整颗fiber组件树。\n\n比如如下的一个JSX树结构：\n```html\n<App>\n  <h1>\n    <div></div>\n  </h1>\n  <Detail>\n    <button></button>\n  </Detail>\n</App>\n```\n\n构成的fiber树可以看下图：\n\n![fiber树](assets/fiber-node.jpg)\n\n有了这么一棵树，React是怎么实现树的遍历并且还可以中断呢。从React reconciler源码中，摘除掉只剩下关键部分，最后workLoop代码如下：\n\n```javascript\nlet workInProgress; // 当前工作节点\n\nfunction workLoopConcurrent() {\n  // 工作循环\n  while (workInProgress != null && !shouldYield()) {\n    performUnitOfWork(workInProgress);\n  }\n}\n\nfunction performUnitOfWork(unitOfWork) {\n  // 对当前工作单元进行beginWork\n  let next = beginWork(unitOfWork);\n\n  if (next == null) {\n    // 如果没有下一个，对当前工作单元进行completeUnitOfWork\n    completeUnitOfWork(unitOfWork);\n  } else {\n    // 如果有下一个，进入下一轮循环\n    workInProgress = next;\n  }\n}\n\nfunction beginWork(unitOfWork) {\n  // 模拟beginWork\n  console.log(`begin work on [${unitOfWork.tag}]`);\n\n  // 将自己的child作为下一个工作单元\n  return unitOfWork.child;\n}\n\nfunction completeUnitOfWork(unitOfWork) {\n  let completedWork = unitOfWork;\n  do {\n    // 模拟completeWork\n    console.log(`complete work on [${completedWork.tag}]`);\n\n    const returnFiber = completedWork.return;\n    const siblingFiber = completedWork.sibling;\n    // 如果有兄弟节点，将兄弟节点作为下一个工作单元\n    if (siblingFiber != null) {\n      workInProgress = siblingFiber;\n      return;\n    }\n\n    // 否则，父节点作为completedWork，继续循环\n    completedWork = returnFiber;\n    workInProgress = completedWork;\n  } while (completedWork != null);\n}\n\n// 是否需要中断\nfunction shouldYield() {\n  return false;\n}\n```\n\n代码中保留了源码中的命名。可以看到React使用workInProgress来记录工作进度，同时它也是fiber对象。当workInProgress不为空时while循环，每执行完一个工作，就修改workInProgress指向下一个fiber。\n\n执行具体工作时，每一个unitOfWork（工作单元），先执行beginWork*（这里把beginWork的内容去掉了只留下了console，实际上React在此做fiber树构建，children协调工作）*。beginWork做完后，如果有child就把child当作下一个工作单元。如果没有child，说明当前fiber的子树都做完了beginWork。则执行completeWork*（实际上React在此做DOM创建、effectList串联等工作）*。\n\ncompleteWork做完后，如果有兄弟节点sibling，则把sibling作为下一个工作单元。如果没有兄弟节点了，说明当前fiber的兄弟也全部做完了beginWork和completeWork。是时候返回父节点，并让父节点做completeWork了。\n\n要返回父节点但是不能将父节点作为下一个workInProgress，否则就死循环了。只需要让它走completeWork即可。所以React在这里又套了一个循环，将父节点作为completedWork单元，执行上面所说的逻辑。\n\n接下来，我们测试下这个workLoop的执行流程。首先用代码创建上图中示例的fiber树：\n\n```javascript\nfunction createFiber(tag) {\n  return { tag, return: null, child: null, sibling: null };\n}\n\n// 生成如下结构的fiber树\n// <App>\n//   <h1>\n//     <div></div>\n//   </h1>\n//   <Detail>\n//     <button></button>\n//   </Detail>\n// </App>\nfunction generateFiberTree() {\n  const app = createFiber(\"App\");\n\n  const h1 = createFiber(\"h1\");\n  app.child = h1;\n  h1.return = app;\n\n  const detail = createFiber(\"Detail\");\n  h1.sibling = detail;\n  detail.return = app;\n\n  const div = createFiber(\"div\");\n  h1.child = div;\n  div.return = h1;\n\n  const button = createFiber(\"button\");\n  detail.child = button;\n  button.return = detail;\n\n  return app;\n}\n```\n\n然后调用workLoop：\n\n```javascript\nlet root = generateFiberTree();\nworkInProgress = root;\nworkLoopConcurrent();\n```\n\n查看控制台日志：\n\n```shell\nbegin work on [App]\nbegin work on [h1]\nbegin work on [div]\ncomplete work on [div]\ncomplete work on [h1]\nbegin work on [Detail]\nbegin work on [button]\ncomplete work on [button]\ncomplete work on [Detail]\ncomplete work on [App]\n```\n\n一切OK。看结果它和老架构一样，是自上而下，深度优先的遍历方式，只不过它不是递归实现的，而是通过`while循环+修改fiber工作指针`的形式。发散一下，如果我们要用递归的形式实现又是什么样子？直接上代码：\n\n```javascript\n// 递归工作循环\nfunction workLoopRecursive(unitOfWork) {\n  // 模拟beginWork\n  console.log(`begin work on [${unitOfWork.tag}]`);\n\n  if (unitOfWork.child !== null) {\n    workLoopRecursive(unitOfWork.child);\n  }\n\n  // 模拟completeWork\n  console.log(`complete work on [${unitOfWork.tag}]`);\n\n  if (unitOfWork.sibling !== null) {\n    workLoopRecursive(unitOfWork.sibling);\n  }\n}\n// 运行测试\nlet root = generateFiberTree();\nworkLoopRecursive(root);\n```\n\nLook！递归的代码简单太多了，而且return都不需要了。因为递归自己知道怎么返回！可以运行一下测试，会发现结果和上面的一样。\n\n既然递归这么简单，为什么要费这么大劲呢？前面就说到了，因为一旦递归就不可中断。那现在这种形式，又如何实现中断？\n\n### 中断执行\n\n回到workLoopConcurrent方法里，while的条件里有一个`shouldYield()`方法。React里就是用这个方法实现的可中断，并且由于workInProgress记录了工作进度，下一次就可以恢复工作！\n\n我们测试一下， 目前shouldYield方法里，直接`return false`。实际上React会在这里根据下一个更新的优先级，可能在这里`return true`。我们测试的话，就加个count吧，比如我们处理3个节点后，就中断处理。修改shouldYield方法：\n\n```javascript\nlet count = 0;\n// 是否需要中断\nfunction shouldYield() {\n  if (count++ >= 3) {\n    return true;\n  }\n  return false;\n}\n```\n\n运行测试一下。结果为：\n\n```shell\nbegin work on [App]\nbegin work on [h1]\nbegin work on [div]\ncomplete work on [div]\ncomplete work on [h1]\n```\n\n可以看到，从根节点开始，执行了三个节点的work后就退出了。可能有同学要问了，为什么completWork执行了，但是只执行了两个？\n\n从上面的源码可以看到，completeWork是不中断的，只有beginWork的while循环才判断是否需要中断。所以只要工作单元及其子树的beginWork都做完了，就一定会执行它的completWork。只要没完全做完就不执行。所以App节点，因为它还没有处理完子树的beginWork，所以它的completeWork也就没有执行。从设计角度来说，这也是非常合理的。\n\n### 中断后恢复\n\n既然能中断，那就要能恢复。当前能在合适的时机下，再恢复工作进度吗？我们再改造一下shouldYield方法和测试代码，模拟一下中断然后立刻恢复：\n\n```javascript\nlet max = 3;\nlet count = 0;\n// 是否需要中断\nfunction shouldYield() {\n  if (count++ >= max) { //使用max控制中断时机\n    return true;\n  }\n  return false;\n}\n\nlet root = generateFiberTree();\nworkInProgress = root;\nworkLoopConcurrent(); // 第一次工作循环\n\nconsole.log(\"work loop break off\\n\"); \n\n// 将第二次工作的中断次数调高\nmax = 1000000;\nconsole.log(\"work loop restart\")\nworkLoopConcurrent();\n```\n\n查看输出结果为：\n\n```shell\nbegin work on [App]\nbegin work on [h1]\nbegin work on [div]\ncomplete work on [div]\ncomplete work on [h1]\nwork loop break down\n\nwork loop restart\nbegin work on [Detail]\nbegin work on [button]\ncomplete work on [button]\ncomplete work on [Detail]\ncomplete work on [App]\n```\n\n非常牛x！看来确实实现了在哪里中断，就在哪里恢复，没有漏运行任何一个工作。这样的话，再搭配React16的异步调度器Scheduler，就可以实现渲染过程的中断、恢复，高优先级更新打断前一次更新等各种操作了。\n\n> 本文所用到的源码在[codeSandbox上](https://codesandbox.io/p/devbox/xj625g)。\n","slug":"/react-workloop"},{"id":"2df9345b-68b2-5a48-a53a-5de8024e35b7","title":"【造轮子】qiankun详解和手写","tags":["前端","微前端","造轮子"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAQFAQP/xAAWAQEBAQAAAAAAAAAAAAAAAAADAQL/2gAMAwEAAhADEAAAAZdHtgMuNGL/AP/EABwQAAEDBQAAAAAAAAAAAAAAAAIAATIDERIUMf/aAAgBAQABBQLArjSEQ1hTxeI8/8QAGBEAAgMAAAAAAAAAAAAAAAAAAAECERL/2gAIAQMBAT8BUaZlH//EABoRAAICAwAAAAAAAAAAAAAAAAACAQMTIVH/2gAIAQIBAT8Ba2W0ZH6f/8QAGRABAAIDAAAAAAAAAAAAAAAAAQAgITFh/9oACAEBAAY/AtM6zK0//8QAGRAAAwEBAQAAAAAAAAAAAAAAAAExEUFh/9oACAEBAAE/IZJDvq228FyXhEdtNfCJ/9oADAMBAAIAAwAAABBHz//EABcRAQADAAAAAAAAAAAAAAAAAAABEWH/2gAIAQMBAT8QhuZv/8QAFhEAAwAAAAAAAAAAAAAAAAAAARBB/9oACAECAQE/EBkKf//EABwQAQADAAIDAAAAAAAAAAAAAAEAESExQVFxgf/aAAgBAQABPxAFtuTReRKSuHdPBh9lRbRsFYTNfbLQHHLEt7ed+5//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/1b638036549b6236251ed5e401e526ce/fff17/qiankun-cover.jpg","srcSet":"/leon-blog/static/1b638036549b6236251ed5e401e526ce/9fa5a/qiankun-cover.jpg 184w,\n/leon-blog/static/1b638036549b6236251ed5e401e526ce/63e75/qiankun-cover.jpg 368w,\n/leon-blog/static/1b638036549b6236251ed5e401e526ce/fff17/qiankun-cover.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/1b638036549b6236251ed5e401e526ce/9d028/qiankun-cover.avif 184w,\n/leon-blog/static/1b638036549b6236251ed5e401e526ce/c6ee4/qiankun-cover.avif 368w,\n/leon-blog/static/1b638036549b6236251ed5e401e526ce/b4627/qiankun-cover.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/1b638036549b6236251ed5e401e526ce/ef27d/qiankun-cover.webp 184w,\n/leon-blog/static/1b638036549b6236251ed5e401e526ce/4ae45/qiankun-cover.webp 368w,\n/leon-blog/static/1b638036549b6236251ed5e401e526ce/20e6b/qiankun-cover.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"【造轮子】qiankun详解和手写\"\ncover: ../static/assets/qiankun-cover.jpg\ncoverAlt: \"封面\"\ndescription: \"介绍一下qiankun解决微前端难题的方法，以及qiankun造轮子\"\ndatePublished: \"2022-07-29 22:23:40\"\ndateModified: \"2022-07-29 22:23:40\"\nslug: \"qiankun-demo\"\ncategory: \"经验总结\"\ntags:\n  - 前端\n  - 微前端\n  - 造轮子\n---\n\n说到微前端，现在最火的方案就是[qiankun](https://qiankun.umijs.org/zh/guide)。qiankun的特点是易用性和完备性很高。说白了就是能很方便、快速的接入，同时bug少，功能强大。\n\n- [介绍](#介绍)\n- [分析qiankun原理](#分析qiankun原理)\n- [自己造一个qiankun](#自己造一个qiankun)\n\n---\n\n### 介绍\n\n微前端已经火了一段时间了，就不介绍了，直接贴图得了。\n\n![](../static/assets/qiankun-intro.jpg)\n\n话不多少，本次主要做两件事情：\n\n1. 拆解和解析qiankun源码\n\n2. 尝试qiankun造轮子\n\n### 分析qiankun原理\n\n截止现在，有很多大神已经将qiankun剖析得一清二楚。从各个层面去讲的都有，参考资料如下：\n\n> [作者介绍qiankun](https://zhuanlan.zhihu.com/p/78362028)<br/>\n> [介绍Html Entry](https://juejin.cn/post/6885212507837825038)<br/>\n> [介绍JavaScript沙盒](https://segmentfault.com/a/1190000040224359)<br/>\n> [介绍CSS沙盒](https://segmentfault.com/a/1190000042018080)<br/>\n> [清除副作用](https://segmentfault.com/a/1190000039200142#item-4)<br/>\n> [应用间通信方案](https://segmentfault.com/a/1190000022583716)<br/>\n\n参考这么多的文档资料，以及自己阅读源码之后，我对qiankun主要功能的理解大概有这些：\n\n#### 基于single-spa\n\nqiankun基于[single-spa](https://single-spa.js.org/)，在它的基础上增加了很多功能。`single-spa`是基于`Js Entry`的方案的：需要将整个微应用打包成一个JS文件，包括图片、css等资源（缺点：体积庞大、无法并行加载资源、接入成本高）。而`Html Entry`则由于保留了html，通过html作为入口处理js、css等，天然的规避了这些问题。\n\nqiankun使用`single-spa`做了两件事情：\n\n- **注册和管理微应用（single-spa内部存储了apps信息）**\n\n    qiankun的app注册接口，会调用`single-spa`的`registerApplication`接口，保留它的路由规则和部分字段。`single-spa`的`registerApplication`接口，app参数需要传入一个包含生命周期函数的对象或工厂函数。\n    \n    ```javascript\n    registerApplication({\n      name: 'app1',\n      activeWhen: '/app1',\n      app: () => import(\"src/app1/main.js\") // 即Js Entry。其中main.js需要导出四个生命周期函数\n    })\n    ```\n\n    而qiankun由于不使用`Js Entry`，所以在`app()`异步函数里，qiankun不是来导入js文件，而是从`Html Entry`开始：*fetch html文件 => 创建和设置子应用dom => 创建沙盒 => 执行子应用js文件（此时可获取到子应用导出的lifecycles） => 包装lifecycles并返回 *。\n\n    > 参考代码：[qiankun调用single-spa注册app](https://github.com/umijs/qiankun/blob/master/src/apis.ts#L73)、[loadApp()里做了什么](https://github.com/umijs/qiankun/blob/master/src/loader.ts#L244)\n\n- **根据路由规则切换微应用（触发微应用状态变更，需要自己实现各个状态回调）**\n\n    `single-spa`已经实现了hash路由和history路由的监听，然后根据子应用的激活路由规则，来调用对应子应用的生命周期函数。qiankun就拿来直接用，反正最后都会进入前面我们提到的生命周期函数。\n\n#### 从Html Entry入手\n\n前面提到，qiankun在app()函数里不是导入js而是处理的`Html Entry`。qiankun作者将这一部分封装成了一个独立的库[import-html-entry](https://github.com/kuitos/import-html-entry)。这里面包括的功能有：\n\n- **fetch html文件**\n- **处理html内容转为template字符串**\n- **获取scripts，包括内部和外部scripts**\n- **对script进行包装，控制js在指定的window中运行（js沙箱的基础）**\n- **获取内部和外部样式表**\n\n可以看出这个库主要就是从`Html Entry`入手处理template、script和style，都只是处理，并没有执行，执行在qiankun源码中。不再细说，细节可以看它的源码或者其他大牛的解读。\n\n#### Js沙箱\n\n`Js沙箱`的目的是为了让子应用拥有自己私有的全局环境。防止子应用修改的全局变量影响到主应用或其他子应用。qiankun实现了三种`Js沙箱`：\n\n- **快照沙箱 - snapshotSandbox**\n\n    [snapshotSandbox](https://github.com/umijs/qiankun/blob/master/src/sandbox/snapshotSandbox.ts)是在不支持Proxy的浏览器环境下才会使用的。原理是在子应用挂载时，备份当前window存入snapshot（同时恢复上一次卸载时最后的状态）；卸载时恢复window为snapshot的状态（同时记录应用变更了哪些状态）。\n\n    由于它会遍历window对象，所以性能最差。同时它修改了window对象，所以它无法做到主应用和子应用的隔离，只做到了单个子应用相互之间的隔离，多个子应用同时加载时也不行。\n\n- **单例代理沙箱 - legacySandBox**\n\n    [legacySandBox](https://github.com/umijs/qiankun/blob/master/src/sandbox/legacy/sandbox.ts)是一个使用Proxy的沙箱。它的原理和快照沙箱一样是记录变更和恢复：创建一个window的proxy（子应用操作的是这个proxy），监听`set()`并收集更新（set仍然会同步window，get直接从window取）。在子应用挂载时，恢复window为上一次卸载时状态；卸载时恢复为挂载前状态。只不过由于使用了代理，它能准确知道哪些变量发生了变化，而不用像快照沙箱那样遍历整个window对象才能知道变化。\n\n    所以它的性能会好于快照沙箱，但是它仍然操作的是window全局对象，所以也无法做到主应用和子应用的隔离，多个子应用同时加载也一样有问题。\n\n- **多例代理沙箱 - proxySandBox**\n\n    [proxySandBox](https://github.com/umijs/qiankun/blob/master/src/sandbox/proxySandbox.ts)也是一个使用Proxy技术的沙箱。只不过它是完全代理了window并替代之。每个子应用都使用的是自己的proxy而不是全局的window。它的原理是创建一个window的proxy。把window的属性都拷贝上去，完全就是一个副本。每个子应用唯一。子应用操作的一直都是这个proxy，所以挂载和卸载都不需要做什么处理。\n\n    由于window全局属性太多，处理的异常也非常多，有的函数和变量还必须从原始window获取。所以这部分代码还是很复杂的，作者估计也是做了非常多的bugfix。\n\n    好处也是非常明显，主应用window不会被污染，子应用之间也完全隔离，多个子应用同时加载也互不影响。\n\n> 其中代理沙箱提供了proxy，子应用必须要让自己的js代码运行在这个proxy全局变量下（比如window、self、top、document、location等等）。这一部分是`import-html-entry`插件在[处理javascript脚本](https://github.com/kuitos/import-html-entry/blob/master/src/index.js#L70)时实现的。说白了就是`eval + function + with`让全局变量都从proxy中查询，并越过了严格模式的安全性错误。\n\n#### Css隔离\n\n`Css隔离`的目的是为了让子应用的Css与主应用或其他子应用的隔离开，防止相互影响。qiankun有三类隔离方式：\n\n- **默认方式**\n\n    qiankun的默认处理是将子应用的内部样式表、外部样式表、还有`css-in-js`技术在运行时创建的样式表，拦截并创建到子应用自己的dom树下，卸载时也一并移除。如果不做这个拦截处理，那子应用的样式表将会出现在根节点`<head>`标签下，`Shadom DOM`模式开启后子应用就找不到这些样式了。\n    \n    查看源码中函数调用关系：`[src/loader.ts].loadApp` => `[src/sandbox/index].createSandboxContainer` => `[src/sandbox/patchers/index].patchAtMounting`，查看[patchersInSandbox方法](https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/index.ts#L29)。对于`快照沙箱`和`单例代理沙箱`，使用[forLooseSandbox](https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/dynamicAppend/forLooseSandbox.ts)，对于`多例代理沙箱`，使用[forStrictSandbox](https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/dynamicAppend/forStrictSandbox.ts)。细节看源码即可。\n\n    默认方式不需要手动开启，它能保证单例场景子应用之间的样式隔离，但是无法保证主应用和子应用，及多实例时子应用之间的样式隔离。\n\n- **Shadom DOM**\n\n    qiankun支持使用`Shadom DOM`实现`严格样式隔离`，它会在子应用dom根节点创建`Shadow DOM`，就能确保子应用和主应用，子应用之间的样式污染问题。但是它并不是完美方案。缺点就是一些弹窗需要挂载到`document.body`下，这是就跳出了`Shadow DOM`边界，弹窗样式也就无法起作用了。\n\n    通过```start({ sandbox: { strictStyleIsolation: true } })```启用。\n\n- **样式转换**\n\n    qiankun会对子应用添加的样式改写，在子应用的根部dom节点增加一个`data-qiankun`属性，并对子应用的所有样式规则，添加一个`div[data-qiankun=\"xxx\"]`的属性选择器，这样子来保证只有子应用的dom树下，才能生效这些样式。能保证主应用和子应用，子应用之间的样式隔离。\n\n    通过```start({ sandbox: { experimentalStyleIsolation: true } })```启用。\n\n- **其他**\n\n    非qiankun框架提供。在项目中我们可以有其他确保样式隔离的方案：唯一的css命名前缀、css modules、CSS-in-js。\n\n#### 清除副作用\n\n子应用使用`window.addEventListener`或者`setInterval`等全局api时，如果子应用卸载时不移除掉，则会对其他应用带来副作用。\n\n代码是在`patchers`.[patchAtMounting](https://github.com/umijs/qiankun/blob/master/src/sandbox/patchers/index.ts#L22)方法中。调用`patchInterval`和`patchWindowListener`来清除副作用的。`patch`方法内部，拦截了原生的方法，每次调用时记录下来。`patch`方法返回`free()`函数，用于在子应用卸载时，[清除副作用](https://github.com/umijs/qiankun/blob/master/src/sandbox/index.ts#L105)。\n\n#### 通信方案\n\n- **官方Actions方案**\n\n官方是事件监听的形式，监听全局状态的变更。主应用初始化状态，通过`mount(props)`生命周期下发到子应用。子应用可以监听和set。\n\n实现原理是主应用负责初始化和存储全局states，提供接口到子应用，子应用添加listener，主应用管理listeners。在任意应用调用setState接口时，都触发listener回调。\n\n- **SharedState方案**\n\n更常见的情况是，项目中已经集成了状态管理库`Redux`、`Zustand`或其他。这时候就可以使用官方Actions方案当作桥梁，打通主应用、子应用的状态数据同步。并且子应用在独立运行的时候仍然使用自身的状态管理库获取数据，在嵌入主应用时，使用全局状态数据。主应用或子应用使用全局状态时，只需要使用一个hooks：\n\n```typescript\n// 获取和设置全局状态，响应式\nconst [app, setApp] = useSharedState('AppInfo');\n```\n\n实现原理就是主应用和子应用都可以创建自己的`SharedState`，即中间层，在这里去实现针对不同状态管理库的状态获取、设置和监听。子应用如果是在qiankun环境，则从主应用获取`SharedState`重载掉自己本地的。然后再提供一个Hooks Api。\n\n```typescript\n/**\n * 操作某一个共享状态的Hooks API。\n * 使用方法类似于React.useState，返回[state, setter]。\n */\nexport function useSharedState<K extends keyof SharedState>(stateName: K): readonly [StateTypeOf<SharedState[K]>, (d: StateTypeOf<SharedState[K]>) => void] {\n  const so: SharedState[K] = state[stateName];\n  // 使用useState，让其转为响应式的状态\n  const [d, setD] = useState(so.get());\n  // 监听主应用状态变化，并setState\n  useEffect(() => {\n    return so.subscribe(setD); // 组件销毁时，停止监听\n  }, [so]);\n  // 有共享状态时\n  return [d, so.set] as const;\n}\n```\n\n这里写得比较简单。有时间我再单独出一期方案详解。\n\n### 自己造一个qiankun\n\n**qiankun原理介绍就这些，下面我们开始正题！自己模仿造一个qiankun轮子出来，抛开健壮性不谈，至少能用！**\n\n#### 项目结构\n\n保持qiankun的功能模块设计，特拆分几个文件如下：\n\n```shell\n- qiankun.ts            # qiankun的主功能\n- single-spa.ts         # 类似于single-spa的功能\n- import-html-entry.ts  # 类似于import-html-entry的功能\n- sandbox               # 存放沙箱\n  - index.ts            # 沙箱容器，控制沙箱创建、加载、卸载\n  - LegacySandbox.ts    # 单例代理沙箱\n  - ProxySandbox.ts     # 多例代理沙箱\n  - SnapshotSandbox.ts  # 快照沙箱\n- patchers              # 存放副作用补丁\n  - intervals.ts        # intervals副作用补丁\n  - listeners.ts        # listeners副作用补丁\n- globalState.ts        # 全局state状态\n```\n\n#### single-spa.ts\n\n功能：管理注册应用、根据路由切换应用。写完后代码如下：\n\n```typescript\nexport function registerApplication(appConfig: AppConfig) {\n  _apps.push({\n    status: AppStatus.NOT_LOADED,\n    ...appConfig,\n  });\n}\n\nlet isStarted = false;\n\nexport function start() {\n  if (isStarted) return;\n\n  isStarted = true;\n  reroute();\n}\n\nlet _prevRoute: string, _nextRoute: string;\n\nfunction reroute() {\n  const tryFetchActiveApp = async (pathname: string) => {\n    _prevRoute = _nextRoute;\n    _nextRoute = pathname;\n    const prevApp = _apps.find((app) => _prevRoute?.startsWith(app.activeWhen));\n    // find the active app\n    const activeApp = _apps.find((app) => pathname.startsWith(app.activeWhen));\n    // if the previous app is the same as the active app, do nothing\n    if (prevApp && activeApp && prevApp.name === activeApp.name) return;\n\n    // unmount the previous app\n    if (prevApp) {\n      if (prevApp.status === AppStatus.MOUNTED)\n        prevApp.status = AppStatus.NOT_LOADED;\n        callOrArrayCall(prevApp.unmount, {});\n    }\n    // fetch the active app\n    if (activeApp) {\n      if (activeApp?.status === AppStatus.NOT_LOADED) {\n        activeApp.status = AppStatus.MOUNTING;\n        activeApp.app().then((lifeCycles) => {\n          Object.assign(activeApp, lifeCycles);\n          activeApp.status = AppStatus.MOUNTED;\n          callOrArrayCall(activeApp.bootstrap, {});\n          callOrArrayCall(activeApp.mount, {});\n        });\n      } else {\n        callOrArrayCall(activeApp.bootstrap, {});\n        callOrArrayCall(activeApp.mount, {});\n      }\n    }\n  };\n\n  function callOrArrayCall<ExtraProps extends any>(\n    func: LifeCycleFn<ExtraProps> | Array<LifeCycleFn<ExtraProps>> | undefined,\n    props: any\n  ) {\n    if (Array.isArray(func)) {\n      func.forEach((fn) => fn(props));\n    } else {\n      func?.(props);\n    }\n  }\n\n  // history.forward() or history.back() or history.go()\n  window.addEventListener(\"popstate\", () => {\n    tryFetchActiveApp(window.location.pathname);\n  });\n\n  window.history.pushState = new Proxy(window.history.pushState, {\n    apply(target, thisArg, args) {\n      const pathname = args[2];\n      tryFetchActiveApp(pathname);\n      // @ts-ignore\n      return target.apply(thisArg, args);\n    },\n  });\n\n  window.history.replaceState = new Proxy(window.history.replaceState, {\n    apply(target, thisArg, args) {\n      const pathname = args[2];\n      tryFetchActiveApp(pathname);\n      // @ts-ignore\n      return target.apply(thisArg, args);\n    },\n  });\n\n  // 首次加载\n  setTimeout(() => {\n    tryFetchActiveApp(window.location.pathname);\n  }, 400);\n}\n```\n\n#### import-html-entry.ts\n\n主要功能：导入html，加载css和javascript。写完后代码如下：\n\n```typescript\nexport async function importEntry(entry: string) {\n  return importHtml(entry);\n}\n\nasync function importHtml(entry: string) {\n  // fetch html entry of app\n  const response = await fetch(entry);\n  const text = await response.text();\n  const html = document.createElement(\"div\");\n  html.innerHTML = text;\n\n  // script will not be executed when html is appended to the DOM\n  // so we need to create script elements and append them to the DOM\n  const scripts = html.querySelectorAll(\"script\");\n  const scriptContents = await fetchScript(entry, ...scripts);\n\n  return {\n    template: html,\n    execScripts: (proxy: Window) => {\n      scriptContents.forEach((scriptContent) => {\n        const code = getExecutableScript(\n          scriptContent.src,\n          scriptContent.code,\n          { proxy }\n        );\n        evalCode(scriptContent.src, code);\n      });\n    },\n  };\n}\n\nasync function fetchScript(prefix: string, ...scripts: HTMLScriptElement[]) {\n  let scriptContents: { code: string; src: string }[] = [];\n  for (let i = 0; i < scripts.length; i++) {\n    const script = scripts[i];\n    if (script.textContent) {\n      scriptContents.push({ code: script.textContent, src: \"\" });\n      continue;\n    }\n    let src = script.attributes.getNamedItem(\"src\")?.value;\n    if (!src) continue;\n    if (\n      !src.startsWith(\"http\") &&\n      !src.startsWith(\"//\") &&\n      !src.startsWith(\"https\")\n    ) {\n      src = prefix + \"/\" + src;\n    }\n    const response = await fetch(src);\n    let scriptContent = await response.text();\n    scriptContents.push({ code: scriptContent, src });\n  }\n\n  return scriptContents;\n}\n\nfunction getExecutableScript(\n  scriptSrc: String,\n  scriptText: string,\n  opts: { proxy: Window }\n) {\n  const { proxy } = opts;\n\n  const sourceUrl = `//# sourceURL=${scriptSrc}\\n`;\n\n  const globalWindow = (0, eval)(\"window\");\n  globalWindow.proxy = proxy;\n  return `;(function(window, self, globalThis){with(window){;${scriptText}\\n}}).bind(window.proxy)(window.proxy, window.proxy, window.proxy);`;\n}\n\nconst evalCache: Record<string, any> = {};\n\nexport function evalCode(scriptSrc: string, code: string) {\n  const key = scriptSrc;\n  if (!evalCache[key]) {\n    const functionWrappedCode = `(function(){${code}})`;\n    evalCache[key] = (0, eval)(functionWrappedCode);\n  }\n  const evalFunc = evalCache[key];\n  evalFunc.call(window);\n}\n```\n\n#### sandbox/index.ts\n\n主要功能：创建沙箱容器，初始化、加载和卸载沙箱，清除副作用。写完后代码如下：\n\n```typescript\nimport { Freer, patchSideEffects } from \"../patchers\";\nimport LegacySandbox from \"./js/LegacySandbox\";\nimport ProxySandbox from \"./js/ProxySandbox\";\nimport SnapshotSandbox from \"./js/SnapshotSandbox\";\n\nexport type SandBox = {\n  /** 沙箱的名字 */\n  name: string;\n  /** 沙箱导出的代理实体 */\n  proxy: WindowProxy;\n  /** 沙箱是否在运行中 */\n  sandboxRunning: boolean;\n  /** latest set property */\n  latestSetProp?: PropertyKey | null;\n  /** 启动沙箱 */\n  active: () => void;\n  /** 关闭沙箱 */\n  inactive: () => void;\n};\n\nexport function createSandboxContainer(\n  appName: string,\n  globalContext: Window,\n  proxy: boolean = true,\n  multi: boolean = true\n) {\n  let sandbox: SandBox;\n  if (proxy) {\n    sandbox = multi\n      ? new ProxySandbox(appName, globalContext)\n      : new LegacySandbox(appName, globalContext);\n  } else {\n    sandbox = new SnapshotSandbox(appName);\n  }\n\n  let mountingFreers: Freer[] = [];\n\n  return {\n    instance: sandbox,\n    mount() {\n      // 1. 启动/恢复沙箱\n      sandbox.active();\n\n      // 2. 开启全局变量补丁\n      mountingFreers = patchSideEffects(sandbox.proxy);\n    },\n\n    unmount() {\n      // 1. 释放全局变量补丁\n      mountingFreers.forEach((free) => free());\n\n      // 2. 关闭沙箱\n      sandbox.inactive();\n    },\n  };\n}\n```\n\n#### sandbox/SnapshotSandbox.ts\n\n主要功能：快照沙箱。写完后代码如下：\n\n```typescript\nimport { SandBox } from \"..\";\n\nfunction iter(\n  obj: typeof window | Record<any, any>,\n  callbackFn: (prop: any) => void\n) {\n  // eslint-disable-next-line guard-for-in, no-restricted-syntax\n  for (const prop in obj) {\n    // patch for clearInterval for compatible reason, see #1490\n    if (obj.hasOwnProperty(prop) || prop === \"clearInterval\") {\n      callbackFn(prop);\n    }\n  }\n}\n\nexport default class SnapshotSandbox implements SandBox {\n  name: string;\n  proxy: WindowProxy;\n  sandboxRunning: boolean;\n\n  private windowSnapshot!: Window;\n\n  private modifyPropsMap: Record<any, any> = {};\n\n  private deletePropsSet: Set<any> = new Set();\n\n  constructor(name: string) {\n    this.name = name;\n    this.proxy = window;\n    this.sandboxRunning = false;\n  }\n\n  active() {\n    this.windowSnapshot = {} as Window;\n\n    // 保存当前window到快照\n    iter(window, (prop) => {\n      this.windowSnapshot[prop] = window[prop];\n    });\n\n    // 恢复上次的变更\n    Object.keys(this.modifyPropsMap).forEach((p: any) => {\n      window[p] = this.modifyPropsMap[p];\n    });\n\n    // 删除上次删除的属性\n    this.deletePropsSet.forEach((p: any) => {\n      delete window[p];\n    });\n\n    // active\n    this.sandboxRunning = true;\n  }\n\n  inactive() {\n    this.modifyPropsMap = {};\n    this.deletePropsSet.clear();\n\n    iter(window, (prop) => {\n      // 记录变更的属性到modifyPropsMap\n      if (window[prop] !== this.windowSnapshot[prop]) {\n        this.modifyPropsMap[prop] = window[prop];\n        // 恢复回去\n        window[prop] = this.windowSnapshot[prop];\n      }\n\n      delete this.windowSnapshot[prop];\n    });\n\n    iter(this.windowSnapshot, (prop) => {\n      // 记录删除的属性到deletePropsSet\n      if (!window.hasOwnProperty(prop)) {\n        this.deletePropsSet.add(prop);\n\n        window[prop] = this.windowSnapshot[prop];\n      }\n    });\n\n    // inactive\n    this.sandboxRunning = false;\n  }\n}\n```\n\n#### sandbox/LegacySandbox.ts\n\n主要功能：单例代理沙箱。写完后代码如下：\n\n```typescript\nimport { SandBox } from \"..\";\n\nconst callableFnCacheMap = new WeakMap();\nconst boundedMap = new WeakMap<CallableFunction, boolean>();\nconst fnRegexCheckCacheMap = new WeakMap<any | FunctionConstructor, boolean>();\n\nfunction isCallable(fn: any) {\n  if (callableFnCacheMap.has(fn)) {\n    return true;\n  }\n  const naughtySafari =\n    typeof document.all === \"function\" && typeof document.all === \"undefined\";\n  const callable = naughtySafari\n    ? typeof fn === \"function\" && typeof fn !== \"undefined\"\n    : typeof fn === \"function\";\n  if (callable) {\n    callableFnCacheMap.set(fn, callable);\n  }\n  return callable;\n}\n\nfunction isBoundedFunction(fn: CallableFunction) {\n  if (boundedMap.has(fn)) {\n    return boundedMap.get(fn);\n  }\n  /*\n   indexOf is faster than startsWith\n   see https://jsperf.com/string-startswith/72\n   */\n  const bounded =\n    fn.name.indexOf(\"bound \") === 0 && !fn.hasOwnProperty(\"prototype\");\n  boundedMap.set(fn, bounded);\n  return bounded;\n}\n\nexport function isConstructable(fn: () => any | FunctionConstructor) {\n  // prototype methods might be changed while code running, so we need check it every time\n  const hasPrototypeMethods =\n    fn.prototype &&\n    fn.prototype.constructor === fn &&\n    Object.getOwnPropertyNames(fn.prototype).length > 1;\n\n  if (hasPrototypeMethods) return true;\n\n  if (fnRegexCheckCacheMap.has(fn)) {\n    return fnRegexCheckCacheMap.get(fn);\n  }\n\n  /*\n    1. 有 prototype 并且 prototype 上有定义一系列非 constructor 属性\n    2. 函数名大写开头\n    3. class 函数\n    满足其一则可认定为构造函数\n   */\n  let constructable = hasPrototypeMethods;\n  if (!constructable) {\n    // fn.toString has a significant performance overhead, if hasPrototypeMethods check not passed, we will check the function string with regex\n    const fnString = fn.toString();\n    const constructableFunctionRegex = /^function\\b\\s[A-Z].*/;\n    const classRegex = /^class\\b/;\n    constructable =\n      constructableFunctionRegex.test(fnString) || classRegex.test(fnString);\n  }\n\n  fnRegexCheckCacheMap.set(fn, constructable);\n  return constructable;\n}\n\nexport function getTargetValue(target: any, value: any) {\n  /*\n    仅绑定 isCallable && !isBoundedFunction && !isConstructable 的函数对象，如 window.console、window.atob 这类。目前没有完美的检测方式，这里通过 prototype 中是否还有可枚举的拓展方法的方式来判断\n    @warning 这里不要随意替换成别的判断方式，因为可能触发一些 edge case（比如在 lodash.isFunction 在 iframe 上下文中可能由于调用了 top window 对象触发的安全异常）\n   */\n  if (\n    isCallable(value) &&\n    !isBoundedFunction(value) &&\n    !isConstructable(value)\n  ) {\n    const boundValue = Function.prototype.bind.call(value, target);\n    for (const key in value) {\n      boundValue[key] = value[key];\n    }\n    if (\n      value.hasOwnProperty(\"prototype\") &&\n      !boundValue.hasOwnProperty(\"prototype\")\n    ) {\n      Object.defineProperty(boundValue, \"prototype\", {\n        value: value.prototype,\n        enumerable: false,\n        writable: true,\n      });\n    }\n\n    return boundValue;\n  }\n\n  return value;\n}\n\nexport default class LegacySandbox implements SandBox {\n  name: string;\n  proxy: WindowProxy;\n  sandboxRunning = true;\n\n  globalContext: Window;\n  // 新增的属性\n  addedPropsMapInSandbox = new Map();\n  // 修改的属性\n  modifiedPropsOriginalValueMap = new Map();\n  // 始终记录的最新值\n  currentUpdatedPropsValueMap = new Map();\n\n  constructor(name: string, global: WindowProxy) {\n    this.name = name;\n\n    this.globalContext = global;\n    const rawWindow = global as any;\n    const fakeWindow = Object.create(null);\n\n    const {\n      addedPropsMapInSandbox,\n      modifiedPropsOriginalValueMap,\n      currentUpdatedPropsValueMap,\n    } = this;\n\n    const proxy = new Proxy(fakeWindow, {\n      set: (_, p, value) => {\n        if (this.sandboxRunning) {\n          if (!rawWindow.hasOwnProperty(p)) {\n            // 这是新增的属性，记录下来，用于inactive时删除\n            addedPropsMapInSandbox.set(p, value);\n          } else if (!modifiedPropsOriginalValueMap.has(p)) {\n            // 这个属性被修改了，记录原始值，方便inactive时恢复window\n            const originalVal = rawWindow[p];\n            modifiedPropsOriginalValueMap.set(p, originalVal);\n          }\n\n          // 总是记录最新的值，方便active时同步到真实window\n          currentUpdatedPropsValueMap.set(p, value);\n\n          rawWindow[p] = value;\n        }\n\n        return true;\n      },\n\n      get(_: Window, p: PropertyKey): any {\n        // avoid who using window.window or window.self to escape the sandbox environment to touch the really window\n        // or use window.top to check if an iframe context\n        // see https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L13\n        if (p === \"top\" || p === \"parent\" || p === \"window\" || p === \"self\") {\n          return proxy;\n        }\n\n        const value = (rawWindow as any)[p];\n        return getTargetValue(rawWindow, value);\n      },\n\n      has(_, p) {\n        //返回boolean\n        return p in rawWindow;\n      },\n\n      getOwnPropertyDescriptor(_, p) {\n        const descriptor = Object.getOwnPropertyDescriptor(rawWindow, p);\n        // 如果属性不作为目标对象的自身属性存在，则不能将其设置为不可配置\n        if (descriptor && !descriptor.configurable) {\n          descriptor.configurable = true;\n        }\n        return descriptor;\n      },\n    });\n\n    this.proxy = proxy;\n  }\n\n  active() {\n    if (!this.sandboxRunning) {\n      this.currentUpdatedPropsValueMap.forEach((value, key) =>\n        this.setWindowProp(key, value)\n      );\n    }\n    // active\n    this.sandboxRunning = true;\n  }\n\n  inactive() {\n    this.modifiedPropsOriginalValueMap.forEach((value, key) =>\n      this.setWindowProp(key, value)\n    );\n    this.addedPropsMapInSandbox.forEach((_, key) =>\n      this.setWindowProp(key, undefined, true)\n    );\n\n    // inactive\n    this.sandboxRunning = false;\n  }\n\n  private setWindowProp(prop: PropertyKey, value: any, toDelete?: boolean) {\n    if (value === undefined && toDelete) {\n      delete (this.globalContext as any)[prop];\n    } else {\n      (this.globalContext as any)[prop] = value;\n    }\n  }\n}\n```\n\n#### sandbox/ProxySandbox.ts\n\n主要功能：代理沙箱。写完后代码如下：\n\n```typescript\nimport { without } from \"lodash\";\n\nimport { SandBox } from \"..\";\nimport { getTargetValue } from \"./LegacySandbox\";\nimport { array2TruthyObject, nativeGlobal } from \"../../common\";\nimport { globalsInBrowser, globalsInES2015 } from \"../../globals\";\n\nconst frozenPropertyCacheMap = new WeakMap<any, Record<PropertyKey, boolean>>();\n\nexport function isPropertyFrozen(target: any, p?: PropertyKey): boolean {\n  if (!target || !p) {\n    return false;\n  }\n\n  const targetPropertiesFromCache = frozenPropertyCacheMap.get(target) || {};\n\n  if (targetPropertiesFromCache[p]) {\n    return targetPropertiesFromCache[p];\n  }\n\n  const propertyDescriptor = Object.getOwnPropertyDescriptor(target, p);\n  const frozen = Boolean(\n    propertyDescriptor &&\n      propertyDescriptor.configurable === false &&\n      (propertyDescriptor.writable === false ||\n        (propertyDescriptor.get && !propertyDescriptor.set))\n  );\n\n  targetPropertiesFromCache[p] = frozen;\n  frozenPropertyCacheMap.set(target, targetPropertiesFromCache);\n\n  return frozen;\n}\n\n// these globals should be recorded while accessing every time\nconst accessingSpiedGlobals = [\"document\", \"top\", \"parent\", \"eval\"];\nconst overwrittenGlobals = [\"window\", \"self\", \"globalThis\", \"hasOwnProperty\"];\nexport const cachedGlobals = Array.from(\n  new Set(\n    without(\n      globalsInES2015.concat(overwrittenGlobals).concat(\"requestAnimationFrame\"),\n      ...accessingSpiedGlobals\n    )\n  )\n);\n\nconst unscopables = array2TruthyObject(\n  without(cachedGlobals, ...accessingSpiedGlobals.concat(overwrittenGlobals))\n);\n\nconst useNativeWindowForBindingsProps = new Map<PropertyKey, boolean>([\n  ['fetch', true],\n  ['mockDomAPIInBlackList', process.env.NODE_ENV === 'test'],\n]);\n\nconst cachedGlobalsInBrowser = array2TruthyObject(\n  globalsInBrowser.concat(process.env.NODE_ENV === 'test' ? ['mockNativeWindowFunction'] : []),\n);\n\nfunction isNativeGlobalProp(prop: string): boolean {\n  return prop in cachedGlobalsInBrowser;\n}\n\nconst globalVariableWhiteList: string[] = [\n  // FIXME System.js used a indirect call with eval, which would make it scope escape to global\n  // To make System.js works well, we write it back to global window temporary\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/evaluate.js#L106\n  \"System\",\n\n  // see https://github.com/systemjs/systemjs/blob/457f5b7e8af6bd120a279540477552a07d5de086/src/instantiate.js#L357\n  \"__cjsWrapper\",\n];\n\n// 创建一个假的window对象，将window的属性拷贝到这个对象上。\n// 后续对window的操作，都通过这个假的window对象进行。不影响真实的window对象。\nfunction createFakeWindow(globalContext: Window, speedy: boolean) {\n  // map always has the fastest performance in has checked scenario\n  // see https://jsperf.com/array-indexof-vs-set-has/23\n  const propertiesWithGetter = new Map<PropertyKey, boolean>();\n  const fakeWindow = {} as any;\n\n  /*\n   copy the non-configurable property of global to fakeWindow\n   see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/getOwnPropertyDescriptor\n   > A property cannot be reported as non-configurable, if it does not exist as an own property of the target object or if it exists as a configurable own property of the target object.\n   */\n  Object.getOwnPropertyNames(globalContext)\n    .filter((p) => {\n      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n      return !descriptor?.configurable;\n    })\n    .forEach((p) => {\n      const descriptor = Object.getOwnPropertyDescriptor(globalContext, p);\n      if (descriptor) {\n        const hasGetter = Object.prototype.hasOwnProperty.call(\n          descriptor,\n          \"get\"\n        );\n\n        /*\n         make top/self/window property configurable and writable, otherwise it will cause TypeError while get trap return.\n         see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Proxy/handler/get\n         > The value reported for a property must be the same as the value of the corresponding target object property if the target object property is a non-writable, non-configurable data property.\n         */\n        if (\n          p === \"top\" ||\n          p === \"parent\" ||\n          p === \"self\" ||\n          p === \"window\" ||\n          // window.document is overwriting in speedy mode\n          (p === \"document\" && speedy)\n        ) {\n          descriptor.configurable = true;\n          /*\n           The descriptor of window.window/window.top/window.self in Safari/FF are accessor descriptors, we need to avoid adding a data descriptor while it was\n           Example:\n            Safari/FF: Object.getOwnPropertyDescriptor(window, 'top') -> {get: function, set: undefined, enumerable: true, configurable: false}\n            Chrome: Object.getOwnPropertyDescriptor(window, 'top') -> {value: Window, writable: false, enumerable: true, configurable: false}\n           */\n          if (!hasGetter) {\n            descriptor.writable = true;\n          }\n        }\n\n        if (hasGetter) propertiesWithGetter.set(p, true);\n\n        // freeze the descriptor to avoid being modified by zone.js\n        // see https://github.com/angular/zone.js/blob/a5fe09b0fac27ac5df1fa746042f96f05ccb6a00/lib/browser/define-property.ts#L71\n        Object.defineProperty(fakeWindow, p, Object.freeze(descriptor));\n      }\n    });\n\n  return {\n    fakeWindow,\n    propertiesWithGetter,\n  };\n}\n\nexport default class ProxySandbox implements SandBox {\n  name: string;\n  proxy: WindowProxy;\n  private document = document;\n  globalContext: Window;\n  sandboxRunning = true;\n\n  globalWhitelistPrevDescriptor: {\n    [p in (typeof globalVariableWhiteList)[number]]:\n      | PropertyDescriptor\n      | undefined;\n  } = {};\n\n  constructor(name: string, global: WindowProxy) {\n    this.name = name;\n    const globalContext = global;\n    this.globalContext = globalContext;\n\n    const { fakeWindow, propertiesWithGetter } = createFakeWindow(global, true);\n    const proxy = new Proxy(fakeWindow, {\n      set: (target, p, value) => {\n        if (this.sandboxRunning) {\n          if (\n            typeof p === \"string\" &&\n            globalVariableWhiteList.indexOf(p) !== -1\n          ) {\n            this.globalWhitelistPrevDescriptor[p] =\n              Object.getOwnPropertyDescriptor(globalContext, p);\n            // @ts-ignore\n            globalContext[p] = value;\n          } else {\n            // We must keep its description while the property existed in globalContext before\n            if (!target.hasOwnProperty(p) && globalContext.hasOwnProperty(p)) {\n              const descriptor = Object.getOwnPropertyDescriptor(\n                globalContext,\n                p\n              );\n              const { writable, configurable, enumerable, set } = descriptor!;\n              // only writable property can be overwritten\n              // here we ignored accessor descriptor of globalContext as it makes no sense to trigger its logic(which might make sandbox escaping instead)\n              // we force to set value by data descriptor\n              if (writable || set) {\n                Object.defineProperty(target, p, {\n                  configurable,\n                  enumerable,\n                  writable: true,\n                  value,\n                });\n              }\n            } else {\n              target[p] = value;\n            }\n          }\n        }\n        return true;\n      },\n\n      get: (target, p) => {\n        if (p === Symbol.unscopables) return unscopables;\n        // avoid who using window.window or window.self to escape the sandbox environment to touch the real window\n        // see https://github.com/eligrey/FileSaver.js/blob/master/src/FileSaver.js#L13\n        if (p === \"window\" || p === \"self\") {\n          return proxy;\n        }\n\n        // hijack globalWindow accessing with globalThis keyword\n        if (p === \"globalThis\") {\n          return proxy;\n        }\n\n        if (p === \"top\" || p === \"parent\") {\n          // if your master app in an iframe context, allow these props escape the sandbox\n          if (globalContext === globalContext.parent) {\n            return proxy;\n          }\n          return (globalContext as any)[p];\n        }\n\n        // proxy.hasOwnProperty would invoke getter firstly, then its value represented as globalContext.hasOwnProperty\n        if (p === \"hasOwnProperty\") {\n          return hasOwnProperty;\n        }\n\n        if (p === \"document\") {\n          return this.document;\n        }\n\n        if (p === \"eval\") {\n          return eval;\n        }\n\n        if (p === \"string\" && globalVariableWhiteList.indexOf(p) !== -1) {\n          // @ts-ignore\n          return globalContext[p];\n        }\n\n        const actualTarget = propertiesWithGetter.has(p)\n          ? globalContext\n          : p in target\n          ? target\n          : globalContext;\n        const value = actualTarget[p];\n\n        // frozen value should return directly, see https://github.com/umijs/qiankun/issues/2015\n        if (isPropertyFrozen(actualTarget, p)) {\n          return value;\n        }\n\n        // non-native property return directly to avoid rebind\n        if (\n          !isNativeGlobalProp(p as string) &&\n          !useNativeWindowForBindingsProps.has(p)\n        ) {\n          return value;\n        }\n\n        /* Some dom api must be bound to native window, otherwise it would cause exception like 'TypeError: Failed to execute 'fetch' on 'Window': Illegal invocation'\n           See this code:\n             const proxy = new Proxy(window, {});\n             // in nest sandbox fetch will be bind to proxy rather than window in master\n             const proxyFetch = fetch.bind(proxy);\n             proxyFetch('https://qiankun.com');\n        */\n        const boundTarget = useNativeWindowForBindingsProps.get(p)\n          ? nativeGlobal\n          : globalContext;\n        return getTargetValue(boundTarget, value);\n      },\n\n      has(target: any, p: string | number | symbol): boolean {\n        // property in cachedGlobalObjects must return true to avoid escape from get trap\n        return p in target || p in globalContext;\n      },\n\n      deleteProperty: (target: any, p: string | number | symbol): boolean => {\n        if (target.hasOwnProperty(p)) {\n          delete target[p];\n\n          return true;\n        }\n\n        return true;\n      },\n    });\n\n    this.proxy = proxy;\n\n    function hasOwnProperty(this: any, key: PropertyKey): boolean {\n      // calling from hasOwnProperty.call(obj, key)\n      if (this !== proxy && this !== null && typeof this === \"object\") {\n        return Object.prototype.hasOwnProperty.call(this, key);\n      }\n\n      return (\n        fakeWindow.hasOwnProperty(key) || globalContext.hasOwnProperty(key)\n      );\n    }\n  }\n\n  active() {\n    // active\n    this.sandboxRunning = true;\n  }\n\n  inactive() {\n    // inactive\n    this.sandboxRunning = false;\n  }\n}\n```\n\n#### patchers/index.ts\n\n主要功能：执行patcher清除副作用。写完后代码如下：\n\n```typescript\nimport patchIntervals from \"./intervals\";\nimport patchListeners from \"./listeners\";\n\nexport type Freer = () => void;\n\nexport type Patcher = (global: WindowProxy) => Freer;\n\nexport function patchSideEffects(global: WindowProxy) {\n  const patchers: Patcher[] = [patchIntervals, patchListeners];\n\n  return patchers.map((patch) => patch(global));\n}\n```\n\n#### patchers/intervals.ts\n\n主要功能：清除setInterval副作用。写完后代码如下：\n\n```typescript\nimport { Patcher } from \".\";\n\nconst rawSetInterval = global.setInterval;\nconst rawClearInterval = global.clearInterval;\n\nconst patch: Patcher = (global) => {\n  let intervals: number[] = [];\n\n  global.setInterval = (handler: Function, timeout: number, ...args: any[]) => {\n    const intervalId = rawSetInterval(handler, timeout, ...args);\n    intervals.push(intervalId);\n    return intervalId;\n  };\n\n  global.clearInterval = (intervalId: number) => {\n    rawClearInterval(intervalId);\n    intervals = intervals.filter((id) => id !== intervalId);\n  };\n\n  return function free() {\n    intervals.forEach((id) => rawClearInterval(id));\n    intervals = [];\n    global.setInterval = rawSetInterval;\n    global.clearInterval = rawClearInterval;\n  };\n};\n\nexport default patch;\n```\n\n#### patchers/listeners.ts\n\n主要功能：清除addListener副作用。写完后代码如下：\n\n```typescript\nimport { Patcher } from \".\";\n\nconst rawAddListener = global.addEventListener;\nconst rawRemoveListener = global.removeEventListener;\n\nconst patch: Patcher = (global) => {\n  let listeners: Map<string, EventListenerOrEventListenerObject[]> = new Map();\n\n  global.addEventListener = (\n    type: string,\n    listener: EventListenerOrEventListenerObject,\n    options?: boolean | AddEventListenerOptions\n  ) => {\n    rawAddListener(type, listener, options);\n    if (!listeners.has(type)) {\n      listeners.set(type, []);\n    }\n    listeners.get(type)!.push(listener);\n  };\n\n  global.removeEventListener = (type: string, listener: EventListenerOrEventListenerObject) => {\n    rawRemoveListener(type, listener);\n    if (listeners.has(type)) {\n      listeners.set(\n        type,\n        listeners.get(type)!.filter((l) => l !== listener)\n      );\n    }\n  }\n\n  return function free() {\n    listeners.forEach((ls, type) => {\n      ls.forEach((listener) => {\n        rawRemoveListener(type, listener);\n      });\n    });\n    listeners.clear();\n    global.addEventListener = rawAddListener;\n    global.removeEventListener = rawRemoveListener;\n  };\n};\n\nexport default patch;\n```\n\n#### globalState.ts\n\n主要功能：全局状态通信。写完后代码如下：\n\n```typescript\nimport { cloneDeep } from \"lodash\";\n\ndeclare type State = Record<string, any>;\ndeclare type Listener = (state: State, prev: State) => void;\n\nlet globalState: State = {};\nlet listenerMap: Record<string, Listener> = {};\n\nfunction emit(state: State) {\n  for (let key in listenerMap) {\n    listenerMap[key](state, cloneDeep(globalState));\n  }\n}\n\nexport function initGlobalState(state: State = {}) {\n  globalState = cloneDeep(state);\n\n  return getAppStateActions(`main-app`);\n}\n\nexport function getAppStateActions(id: string) {\n  return {\n    onGlobalStateChange: (callback: Listener, fireImmediately?: boolean) => {\n      listenerMap[id] = callback;\n      if (fireImmediately) {\n        callback(cloneDeep(globalState), {});\n      }\n    },\n    offGlobalStateChange: () => {\n      delete listenerMap[id];\n    },\n    setGlobalState: (state: State) => {\n      state = cloneDeep(state);\n      console.log(`[fake qiankun]global state set: ${JSON.stringify(state)}`);\n      let changedKeys: string[] = [];\n      for (let key in state) {\n        if (globalState[key] !== state[key]) {\n          changedKeys.push(key);\n        }\n      }\n      if (changedKeys.length > 0) {\n        emit(state);\n      }\n    },\n  };\n}\n```\n\n#### qiankun.ts\n\n最后就是`qiankun.ts`，它是一个全局协调者的角色，组装各个模块的功能，暴露接口供用户调用。\n\n主要功能：提供外部接口，内部使用`single-spa.ts`和`import-html-entry`，创建沙盘，管理全局状态，加载app。写完后代码如下：\n\n```typescript\nimport { registerApplication, start as startSingleSpa } from \"./single-spa\";\nimport { importEntry } from \"./import-html-entry\";\nimport { createSandboxContainer } from \"./sandbox\";\nimport { getAppStateActions } from \"./globalState\";\nexport { initGlobalState } from \"./globalState\"\n\nexport type AppConfig = {\n  name: string;\n  entry: string;\n  container: string;\n  activeRule: string;\n};\n\nexport function registerMicroApps(apps: AppConfig[]) {\n  apps.forEach((app) => {\n    registerApplication({\n      name: app.name,\n      activeWhen: app.activeRule,\n      app: async () => {\n        return loadApp(app);\n      },\n    });\n  });\n}\n\ndeclare type FrameworkConfiguration = {\n  proxy?: boolean;\n  multi?: boolean;\n  style?: boolean | { strict?: boolean; experiment?: boolean };\n};\nlet frameworkConfiguration: FrameworkConfiguration = {};\n\nexport function start(opts: FrameworkConfiguration) {\n  frameworkConfiguration = opts;\n  startSingleSpa();\n}\n\nasync function loadApp(app: AppConfig) {\n  const parent = document.querySelector(app.container);\n  if (!parent) throw new Error(\"container not found\");\n  parent.innerHTML = \"\";\n\n  const { template, execScripts } = await importEntry(app.entry);\n\n  const isStrictStyle =\n    typeof frameworkConfiguration.style === \"object\" &&\n    !!frameworkConfiguration.style.strict;\n\n  const isScopedStyle =\n    typeof frameworkConfiguration.style === \"object\" &&\n    !isStrictStyle &&\n    !!frameworkConfiguration.style.experiment;\n\n  console.log(\n    `[fake qiankun] ${\n      isScopedStyle ? \"scoped\" : isStrictStyle ? \"strict\" : \"none\"\n    } style isolation applied`\n  );\n\n  const appWrapperElement = createElement(\n    template,\n    isStrictStyle,\n    isScopedStyle\n  );\n\n  parent.appendChild(appWrapperElement);\n\n  let global: Window = window;\n\n  // sandbox\n  const sandboxContainer = createSandboxContainer(\n    app.name,\n    global,\n    frameworkConfiguration.proxy,\n    frameworkConfiguration.multi\n  );\n\n  global = sandboxContainer.instance.proxy;\n\n  beforeLoad(global, app.entry);\n\n  execScripts(global);\n\n  // @ts-ignore\n  const scriptExports = global[app.name];\n\n  const { bootstrap, mount, unmount } = scriptExports;\n\n  const appContainer = appWrapperElement.shadowRoot || appWrapperElement;\n\n  const stateActions = getAppStateActions(app.name);\n\n  return {\n    bootstrap,\n    mount: [\n      sandboxContainer.mount,\n      async () => mount({ name: app.name, container: appContainer, ...stateActions }),\n      () => console.log(`[fake qiankun] app mounted: 【${app.name}】`),\n    ],\n    unmount: [\n      () => beforeUnmountAddOns(global),\n      async () => unmount({ name: app.name, container: appContainer }),\n      sandboxContainer.unmount,\n      () => console.log(`[fake qiankun] app unmounted: 【${app.name}】`),\n    ],\n  };\n}\n\nfunction beforeLoad(global: any, publicPath = \"/\") {\n  global.__POWERED_BY_QIANKUN__ = true;\n  global.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ = publicPath;\n}\n\nfunction beforeUnmountAddOns(global: any) {\n  delete global.__POWERED_BY_QIANKUN__;\n  delete global.__INJECTED_PUBLIC_PATH_BY_QIANKUN__;\n}\n\n/** 创建app wrapper元素 */\nfunction createElement(\n  appElement: HTMLElement,\n  strictStyle: boolean,\n  scopedStyle: boolean\n) {\n  if (strictStyle) {\n    const { innerHTML } = appElement;\n    appElement.innerHTML = \"\";\n\n    const shadow = appElement.attachShadow({ mode: \"open\" });\n\n    shadow.innerHTML = innerHTML;\n  }\n\n  if (scopedStyle) {\n    const attr = appElement.getAttribute(\"data-qiankun\");\n    if (!attr) {\n      appElement.setAttribute(\"data-qiankun\", \"appid\");\n    }\n\n    const styleNodes = appElement.querySelectorAll(\"style\") || [];\n    styleNodes.forEach((stylesheetElement: HTMLStyleElement) => {\n      // css.process(appElement!, stylesheetElement, \"appid\");\n    });\n  }\n\n  return appElement;\n}\n```\n\n测试用例和贴图就先不加了，有时间补上。","slug":"/qiankun-demo"},{"id":"e8e1b1dc-f0aa-54e0-8e14-92deedd77c82","title":"社交百科","tags":["跨平台","Flutter","dart","Android端","iOS端"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB04rJUIOJ/8QAGBAAAgMAAAAAAAAAAAAAAAAAAQIRIDH/2gAIAQEAAQUCOJJr/8QAFhEBAQEAAAAAAAAAAAAAAAAAERAh/9oACAEDAQE/AXCf/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRAAAgMBAAAAAAAAAAAAAAAAAREAITEg/9oACAEBAAE/IQRLYRC7oHFcXH//2gAMAwEAAgADAAAAEHTP/8QAFxEBAQEBAAAAAAAAAAAAAAAAAQARMf/aAAgBAwEBPxAAsdsv/8QAFhEBAQEAAAAAAAAAAAAAAAAAEQEA/9oACAECAQE/EK2rnf/EABsQAQACAgMAAAAAAAAAAAAAAAEAERAhMVFx/9oACAEBAAE/EEQLAodsPmHcNSuyecc4/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/a7277484fc3f474a421690674c09c3e8/1a18e/cover.jpg","srcSet":"/leon-blog/static/a7277484fc3f474a421690674c09c3e8/38847/cover.jpg 185w,\n/leon-blog/static/a7277484fc3f474a421690674c09c3e8/0b64e/cover.jpg 369w,\n/leon-blog/static/a7277484fc3f474a421690674c09c3e8/1a18e/cover.jpg 738w,\n/leon-blog/static/a7277484fc3f474a421690674c09c3e8/6f66e/cover.jpg 1476w","sizes":"(min-width: 738px) 738px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/a7277484fc3f474a421690674c09c3e8/e48a9/cover.avif 185w,\n/leon-blog/static/a7277484fc3f474a421690674c09c3e8/6964f/cover.avif 369w,\n/leon-blog/static/a7277484fc3f474a421690674c09c3e8/09253/cover.avif 738w,\n/leon-blog/static/a7277484fc3f474a421690674c09c3e8/4b69b/cover.avif 1476w","type":"image/avif","sizes":"(min-width: 738px) 738px, 100vw"},{"srcSet":"/leon-blog/static/a7277484fc3f474a421690674c09c3e8/3edfa/cover.webp 185w,\n/leon-blog/static/a7277484fc3f474a421690674c09c3e8/696e0/cover.webp 369w,\n/leon-blog/static/a7277484fc3f474a421690674c09c3e8/b1703/cover.webp 738w,\n/leon-blog/static/a7277484fc3f474a421690674c09c3e8/97584/cover.webp 1476w","type":"image/webp","sizes":"(min-width: 738px) 738px, 100vw"}]},"width":738,"height":368},"body":"---\ntitle: \"社交百科\"\ncover: sjbk/cover.jpg\ncoverAlt: \"封面\"\ndescription: \"答题得奖励，奖励可提现\"\ndatePublished: \"2022-12-03 21:11:05\"\ndateModified: \"2022-12-03 21:11:05\"\ncategory: \"应用项目\"\ntags:\n  - 跨平台\n  - Flutter\n  - dart\n  - Android端\n  - iOS端\n---\n\n社交百科是一个知识答题类的网赚app。\n\n### 主要功能\n\n- 回答社交领域相关的问题，答对得金币奖励，答错无奖励。连对奖励更多。\n\n- 看广告得金币，保持连对数据。\n\n- 到达一定金币数量可以提现。\n\n- 可以邀请好友，好友收益也可以返利。\n\n- 包含开屏、插屏、激励视频广告。\n\n### 我的职责\n\n1. 负责对标同类型产品设计功能。\n\n2. 负责UI设计。\n\n3. 负责flutter应用开发。\n\n4. 负责广告sdk的接入、对接广告位。\n\n### 技术实现\n\n1. 项目使用flutter开发，支持android和ios。\n\n2. 请求框架使用dio。\n\n3. 应用更新使用ota_update。\n\n4. h5页面使用webview_flutter加载。\n\n5. 接口请求的request、response数据均加密，使用encrypt、crypto库实现。\n\n6. 使用Provider实现全局状态管理和UI更新。\n\n### 截图\n\n![知识答题](./sjbk/question.jpg)\n![收益](./sjbk/benefit.jpg)\n![我的](./sjbk/mine.jpg)","slug":"/社交百科"},{"id":"7493d1e8-6468-5ba4-b982-0c8345d3b2f9","title":"SwipeLoadView","tags":["Android端","Java","UI组件","开源"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdqLAD//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAEFAl//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAUEAEAAAAAAAAAAAAAAAAAAAAg/9oACAEBAAY/Al//xAAZEAEAAgMAAAAAAAAAAAAAAAABABEgMWH/2gAIAQEAAT8hYFah3D//2gAMAwEAAgADAAAAELDP/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPxA//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPxA//8QAHBAAAgICAwAAAAAAAAAAAAAAAREAIRBBMVGR/9oACAEBAAE/EHNaj5t6TGunNLrAADQ3j//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/9788ce343322494910ae6ac60876efed/a5027/slv_cover.jpg","srcSet":"/leon-blog/static/9788ce343322494910ae6ac60876efed/9fa5a/slv_cover.jpg 184w,\n/leon-blog/static/9788ce343322494910ae6ac60876efed/0b64e/slv_cover.jpg 369w,\n/leon-blog/static/9788ce343322494910ae6ac60876efed/a5027/slv_cover.jpg 737w,\n/leon-blog/static/9788ce343322494910ae6ac60876efed/c6c29/slv_cover.jpg 1474w","sizes":"(min-width: 737px) 737px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/9788ce343322494910ae6ac60876efed/9d028/slv_cover.avif 184w,\n/leon-blog/static/9788ce343322494910ae6ac60876efed/6964f/slv_cover.avif 369w,\n/leon-blog/static/9788ce343322494910ae6ac60876efed/a4fd3/slv_cover.avif 737w,\n/leon-blog/static/9788ce343322494910ae6ac60876efed/5fd46/slv_cover.avif 1474w","type":"image/avif","sizes":"(min-width: 737px) 737px, 100vw"},{"srcSet":"/leon-blog/static/9788ce343322494910ae6ac60876efed/ef27d/slv_cover.webp 184w,\n/leon-blog/static/9788ce343322494910ae6ac60876efed/696e0/slv_cover.webp 369w,\n/leon-blog/static/9788ce343322494910ae6ac60876efed/abd43/slv_cover.webp 737w,\n/leon-blog/static/9788ce343322494910ae6ac60876efed/47ce9/slv_cover.webp 1474w","type":"image/webp","sizes":"(min-width: 737px) 737px, 100vw"}]},"width":737,"height":368},"body":"---\ntitle: \"SwipeLoadView\"\ncover: images/slv_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"SwipeLoadView支持为任意下拉刷新组件+ListView/RecyclerView/GridView/ExpandableListView的组合，增加上拉加载更多功能\"\ndatePublished: \"2016-02-22 08:55:59\"\ndateModified: \"2016-02-22 08:55:59\"\ncategory: \"框架工具\"\ntags:\n  - Android端\n  - Java\n  - UI组件\n  - 开源\n---\n\nSwipeLoadView支持为**任意下拉刷新组件**（如SwipeRefreshLayout、SmartRefreshLayout）+ **ListView/RecyclerView/GridView/ExpandableListView**的组合，增加上拉加载更多功能。\n\ngithub仓库：https://github.com/missmess/swipeloadview\n\n> 原SwipeLoadView已经改名为LoadMoreHelper，支持更多刷新控件。\n\nLoadMoreHelper可以为任意下拉刷新控件，多种滚动布局(RecyclerView, ListView, GridView, ExpandableListView等)\n增加上拉加载功能，可以作为下拉刷新库的加载功能补充。\n  \n---\n\n  * [主要功能介绍](#主要功能介绍)\n  * [如何添加到项目中](#如何添加到项目中)\n  * [如何使用](#如何使用)\n  * [示例代码](#示例代码)\n\n---\n\n### 主要功能介绍\n\n* 默认支持为ListView、RecyclerView、GridView、ExpandableListView等内容组件增加pull load功能，其它控件可自行实现接口来添加支持。\n* load more包含上拉加载、加载中、加载失败、没有更多的功能。可以实现接口来完全自定义您想要的布局。\n* 理论上支持添加任意下拉刷新库的关联，关联后可以解决refresh和load状态的一些处理和冲突等。\n* 默认实现了一套完整的功能，包含SwipeRefreshLayout+(ListView, RecyclerView, GridView, ExpandableListView)+DefaultLoadMoreView。\n* 其它想要自定义的话，实现IRefreshLayoutHandler或ILoadViewHandler或ILoadMoreView（看你自己想自定义那些部分），并在构造LoadMoreHelper时传入即可。\n\n---\n\n### 如何添加到项目中\n\n本library已经支持maven。Android Studio用户，只需要在项目的build.gradle中添加该depandencies：\n\n```\ncompile 'com.missmess.swipeloadview:loadmorehelper:2.1.1'\n```\n\n**从2.1.1版本开始，去除了LoadMoreHelper.setAdapter方法，使用时只需要自己去调用各个setAdapter方法即可。使用起来更方便了。**\n\n---\n\n### 如何使用\n\n调用非常简单，只需要几句代码即可实现为你的refresh view添加加载更多的功能。\n\n  用法如下：\n```java\n// new a LoadMoreHelper\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, listView);\n// set refresh and load listener\nloadViewHelper.setOnRefreshLoadListener(new SwipeLoadViewHelper.OnRefreshLoadListener() {\n    @Override\n    public void onRefresh() {\n        // do your refresh OP\n    }\n\n    @Override\n    public void onLoad() {\n        // do your load more OP\n    }\n});\n```\n但是不要忘记在你的刷新或加载更多操作结束后，通知LoadMoreHelper。\n```java\n    // refresh OP finished，notify LoadMoreHelper\n    loadViewHelper.completeRefresh();\n    // load more OP finished，notify LoadMoreHelper\n    loadViewHelper.completeLoadmore();\n```\n---\n\n### 示例代码\n###### 0、默认增加对SwipeRefreshLayout刷新库的支持\n```java\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, listView);\n```\n\n如果需要自己指定特定的刷新库，可以实现对应的IRefreshLayoutHandler。并在构造LoadMoreHelper时，传入。以\nSmartRefreshLayout为例：\n```java\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(smartRefreshLayout, new IRefreshLayoutHandler<SmartRefreshLayout>() {\n\t\t@Override\n\t\tpublic void handleSetRefreshListener(SmartRefreshLayout view, final Runnable runnable) {\n\t\t\tview.setOnRefreshListener(new OnRefreshListener() {\n\t\t\t\t@Override\n\t\t\t\tpublic void onRefresh(RefreshLayout refreshLayout) {\n\t\t\t\t\trunnable.run();\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\t@Override\n\t\tpublic void refresh(SmartRefreshLayout view) {\n\t\t\tview.autoRefresh();\n\t\t}\n\t\t@Override\n\t\tpublic void finishRefresh(SmartRefreshLayout view) {\n\t\t\tview.finishRefresh();\n\t\t}\n\t}, recyclerView);\n```\n\n###### 1、为不同的refresh view添加pull load支持\n\n可以为ListView、RecyclerView、GridView、ExpandableListView添加支持。仅需要为这些不同的refresh view添加对应的泛型，和adapter即可。\n\n* ListView\n```java\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, listView);\n```\n\n* RecyclerView\n```java\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, recyclerView);\n```\n\n* GridView\n\n    需要使用`GridViewWithHeaderAndFooter`替代GridView。\n```java\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, gridView);\n```\n\n* ExpandableListView\n```java\nLoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, expandableListView);\n```\n\n###### 2、通知LoadMoreHelper，没有更多数据了\n\n  没有更多数据时，需要调用setHasMoreData方法告知LoadMoreHelper。\n```java\nif (nomoredata) { //没有更多数据了\n    loadViewHelper.setHasMoreData(false);\n}\n```\n\n###### 3、设置自定义加载失败信息\n\n  加载失败时，可以自定义显示错误信息\n```java\nloadViewHelper.setLoadMoreError(\"connect failed, click to retry\");\n```\n\n###### 4、自定义loadview\n\n  可以完全自定义LoadView的布局，通过实现ILoadViewFactory：\n```java\npublic class MyLoadFactory implements ILoadViewFactory {\n    @Override\n    public ILoadMoreView madeLoadMoreView() {\n        return new MyLoadMoreView();\n    }\n\n    /**\n     * custom load more view\n     */\n    class MyLoadMoreView implements ILoadMoreView {\n        private RadioButton normal;\n        private RadioButton loading;\n        private RadioButton nodata;\n        private RadioButton error;\n\n        @Override\n        public View create(LayoutInflater inflater, View.OnClickListener onClickLoadMoreListener) {\n            View view = inflater.inflate(R.layout.view_custom_load, null);\n            normal = (RadioButton) view.findViewById(R.id.radioButton1);\n            loading = (RadioButton) view.findViewById(R.id.radioButton2);\n            nodata = (RadioButton) view.findViewById(R.id.radioButton3);\n            error = (RadioButton) view.findViewById(R.id.radioButton4);\n\n            return view;\n        }\n\n        @Override\n        public void showNormal() {\n            normal.setChecked(true);\n        }\n\n        @Override\n        public void showNomore() {\n            nodata.setChecked(true);\n        }\n\n        @Override\n        public void showLoading() {\n            loading.setChecked(true);\n        }\n\n        @Override\n        public void showFail(CharSequence e) {\n            // 错误信息通过e.getMessage()来获取\n            error.setText(e);\n            error.setChecked(true);\n        }\n    }\n}\n```\n并在new LoadMoreHelper时，传参：\n```java\n    LoadMoreHelper loadViewHelper = new LoadMoreHelper(swipeRefreshLayout, listView, new MyLoadFactory());\n```\n\n---\n\n### 截图\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc1.jpg)\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc2.jpg)\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc3.jpg)\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc4.jpg)\n![image](https://raw.githubusercontent.com/missmess/swipeloadview/master/raw/picc5.jpg)\n","slug":"/swipe-load-view"},{"id":"9d69db63-f20b-55e6-86d9-ba67df43472e","title":"【uniapp】开发遇到的那些巨坑","tags":["Uniapp","跨平台","踩坑"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQT/xAAVAQEBAAAAAAAAAAAAAAAAAAACA//aAAwDAQACEAMQAAABRY1EuM0Nv//EABsQAAIBBQAAAAAAAAAAAAAAAAECAAMEEiEi/9oACAEBAAEFAhcc5iohSII2ln//xAAXEQEBAQEAAAAAAAAAAAAAAAABAAIR/9oACAEDAQE/AXkZL//EABcRAAMBAAAAAAAAAAAAAAAAAAABERP/2gAIAQIBAT8B0cKz/8QAGhAAAgIDAAAAAAAAAAAAAAAAARAAEiExgf/aAAgBAQAGPwI25Dt4X//EABsQAQEBAAIDAAAAAAAAAAAAAAERACFBMWFx/9oACAEBAAE/IT5Tb4ZAKW9FyHfPswI0HASJ81Yb/9oADAMBAAIAAwAAABBkP//EABcRAQADAAAAAAAAAAAAAAAAAAEAETH/2gAIAQMBAT8QCUrJQyf/xAAXEQADAQAAAAAAAAAAAAAAAAABEBEh/9oACAECAQE/EJQdR//EABwQAQACAwADAAAAAAAAAAAAAAEAESExUWFx4f/aAAgBAQABPxCgFYSLquc+zTwjU9xgHRnBC8zGEuEhFy0q4oquu+Wf/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/483b8/default_img3.jpg","srcSet":"/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/9fa5a/default_img3.jpg 184w,\n/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/63e75/default_img3.jpg 368w,\n/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/483b8/default_img3.jpg 735w,\n/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/99734/default_img3.jpg 1470w","sizes":"(min-width: 735px) 735px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/9d028/default_img3.avif 184w,\n/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/c6ee4/default_img3.avif 368w,\n/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/6f2e7/default_img3.avif 735w,\n/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/201fd/default_img3.avif 1470w","type":"image/avif","sizes":"(min-width: 735px) 735px, 100vw"},{"srcSet":"/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/ef27d/default_img3.webp 184w,\n/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/4ae45/default_img3.webp 368w,\n/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/51181/default_img3.webp 735w,\n/leon-blog/static/973a8d7cf30d10103d322148f48cd6d6/1c5dc/default_img3.webp 1470w","type":"image/webp","sizes":"(min-width: 735px) 735px, 100vw"}]},"width":735,"height":368},"body":"---\ntitle: \"【uniapp】开发遇到的那些巨坑\"\ncover: images/default_img3.jpg\ncoverAlt: \"封面\"\ndescription: \"开发uniapp过程中遇到的巨坑\"\ndatePublished: \"2024-03-08 11:09:02\"\ndateModified: \"2024-03-08 11:09:02\"\nslug: uniapp-bugs\ncategory: \"经验总结\"\ntags:\n  - Uniapp\n  - 跨平台\n  - 踩坑\n---\n\n### uniapp开发遇到的一些坑的合集\n\n>（有的是bug，有的是设计不合理，有的是表现在意料之外）\n\n##### 1. vue和nvue页面之间并不是完全共享数据。\n\n即使在同一个项目下，vue和nvue也不是数据互通的。原因是**vue和nvue分别有自己独立的js引擎，内存并不共享**。\n\n**比如以下情形：**\n\n- Vue.prototype\n\t\n\t仅支持vue，nvue下无法获取，为undefined。所以main.js里全局注册的组件、filter、directive等，都无法在nvue中使用。\n\t\n- 导入js模块\n\t\n\t比如：`import store from '@/store/index'`，直接取store.state，nvue中为null。\n\n\t再如：`import abc from '@/abc.js'`，`abc`为一个global的变量，vue页面设置abc=3。打开nvue页面取abc仍为初始值。\n\t\n\t因为两个js引擎，分别导入了js模块，数据并不共享。\n\t\n- globalThis全局变量（uniapp里不应该使用globalThis来设置和获取全局变量）\n\n\tmain.js或app.vue或某vue里增加了globalThis上的变量，nvue页面都无法获取到\n\n**vue和nvue共享数据的方法:**\n\n- 使用vuex的方法mapState、mapAction等获取状态。\n\t\n\t它们在vue和nvue里是互通的，因为uniapp对vuex特殊处理了。\n\n- 使用App.vue实例下的数据。官方说`getApp().globalData`是共享的，实际测试类似于getApp().abc也共享。\n\n\t原理就是App在vue和nvue下相互拷贝，任何变化都会在两边触发。\n\n- 使用本地存储，如storage、sqlite等。\n\n- uni下的变量。文档没有，但实际测试，uni下的数据如uni.abc，也可以在vue和nvue共享\n\n这几种方法是uniapp单独处理好了，所以可以共享。\n\n**参考文档：**\n\n[vue和nvue共享数据](https://uniapp.dcloud.net.cn/tutorial/nvue-api.html#sharevar)\n\n[uniapp全局变量的几种方式](https://ask.dcloud.net.cn/article/35021)\n\n##### 2. uni.navigateBack是关闭栈顶页，并非关闭调用页。\n\n对比人家Android，调用acitivty.finish()，想关掉哪个就关掉哪个。一定不会关错页面。\n\nuniapp中以下的情况很容易出现bug：\n\n- 在调用navigateBack前，打开了一个新页面，会导致新打开的页面被关闭。比如下面的代码：\n\n```javascript\n...\n// 提交数据\napiServer.post(URL.submitQA).then((res) => {\n\t// 判断是否打开新页面\n\tshouldOpenGuide(res)\n\t// 关闭当前页\n\tuni.navigateBack()\n})\n...\nfunction shouldOpenGuide(res) {\n\t// 如果接口告诉我需要打开guide页面，我就去打开\n\tif (res.openGuide) {\n\t\tuni.navigateTo(\"/pages/guide/guide\");\n\t}\n}\n```\n\n看着代码没有任何问题，期望先打开新页面再关掉当前页面。但实际是错误的效果。\n\n- 同一时间调用几次navigateBack，就往前关闭几个页面。\n\n```javascript\n...\n// 这里的代码会往前关闭3个页面\nuni.navigateBack()\nuni.navigateBack()\nuni.navigateBack()\n...\n```\n\n- 无法实现非栈顶页面关闭，如A=>B=>C=>D，想在D页面关闭B页面实现不了。\n\n我试了n种方法（记在了qingchat/common/navigateCompat里），但**目前看没办法保证在哪个页面调用navigateBack，就关闭哪个页面**，所以必须自己控制页面栈顺序是否正确\n\n##### 3. uni.showToast只能在当前页未销毁时显示\n\n很常见的一种情况，showToast和navigateBack挨着写，你会发现toast一闪即逝。（底层上，toast的view展示在了当前页面的webview上，当前页一关，view随着webview全部销毁）\n```javascript\n// 提交数据\napiServer.post(URL.submitQA).then((res) => {\n\t// 判断是否打开新页面\n\tshowToast({ title: \"数据提交成功\" })\n\t// 关闭当前页\n\tuni.navigateBack()\n})\n```\n\n解决办法：a. navigateBack套上setTimeout，显示完toast再关闭（有点傻的方法）；b. 在app上使用plus.nativeUI.toast代替uni.showToast，它不依赖于当前页，非app上保持原样（参考qingchat/common/toastCompat）。\n\n##### 4. uni.redirectTo无动画直接闪现新页面，体验很差。\n\n不用redirectTo，替代方案为先navigateBack再navigateTo。\n\t\n不过这个方案对于background为透明的页面（比如全局弹窗），这样做会导致上上页面在回退栈中消失了（这百分百是uniapp的bug）。\n\n解决办法：navigateBack({ animationType: 'none' })，再navigateTo，就可以正常跳转（搞不懂，反正这样就是好使了）。\n\t\n#### 5. nvue页面关闭，js引擎也会一同销毁\n\nvue页面不是这样的，vue页面js引擎在整个应用生命周期都存活。（我不知道纯nvue项目下表现会不会不一样）\n\t\nnvue的js引擎销毁，会导致：\t\n- nvue导入的js模块中的变量，每次页面打开都重置。\n- nvue页面调用plus.NativeObj.View显示原生悬浮窗。nvue页面一旦关闭，悬浮窗就无法响应点击和触摸。\n- setTimeout、setInterval在nvue页面关闭后就不会再执行，所以上面的悬浮窗也不能通过timer自动关。\n\t\n原因是：从nvue页面显示出来的原生悬浮窗，js执行使用的是nvue的js引擎。页面一关，引擎一销毁就gg。\n\n解决办法：将悬浮窗的show方法，移入到App.vue中。nvue页面通过getApp().show来显示悬浮窗，这样悬浮窗就是在vue的js引擎中打开的，跟nvue无关了。\n\n#### 6. v-for列表渲染时，偶现列表数据变化后，列表里的组件template中获取到的props为undefined\n\n条件：a. 列表渲染；b. 列表渲染的节点下有子组件；c. 往子组件传了props；d. 列表数据发生变化时。\n\n现象：子组件js中打印的props是正确数据；但template中获取到的props为undefined（也偶现展示的是列表前一个item的）。即：控制台看着是对的，手机上显示的是undefined（WTF，活久见）\n\n```html\n<!-- 父组件 -->\n<template>\n...\n\t<view v-for=\"item in listdata\" :key=\"item.id\">\n\t\t<!-- 子组件 -->\n\t\t<ChildComp :item=\"item\" />\n\t</view>\n...\n</template>\n<script>\nimport OriginalData from \"../def_data\";\n...\n\tdata() {\n\t\treturn {\n\t\t\tlistdata: OriginalData,\n\t\t}\n\t}\n...\n\tonFetchData(data) {\n\t\t// 列表数据发生变化\n\t\tthis.listdata = data;\n\t}\n...\n</script>\n```\n```html\n<!-- 子组件 ChildComp -->\n<template>\n...\n\t<view class=\"child-container\">\n\t\t<!-- 取props里的data，有时候会变成undefined -->\n\t\t<text>{{ item.data }}</text>\n\t</view>\n...\n</template>\n<script>\n...\n\tprops: [\"item\"],\n\tmounted() {\n\t\t// js中获取到的props一直是正常的\n\t\tconsole.log(this.item)\n\t}\n...\n</script>\n```\n\n跟设置key没有关系，这种基础的我早试过了。我猜测原因是：**uniapp渲染层和逻辑层是分开的。列表成功渲染一次后，当数据发生了变化，出于某某bug，某个子组件逻辑层props是正确的，但没有将这个正确的数据发送到渲染层）**\n\n目前秒聊的聊天消息列表出现过这个问题，通过setTimeout，延迟执行messageList更新就解决了，奇怪的很。\n\n秒聊首页列表、会话列表也出现了这个问题（出现概率很高）。v-for不放在view上，直接放在子组件上```<ChildComp v-for=\"item in listdata\" :key=\"item.id\" />```，或者不抽子组件，直接在```<view v-for...>{/*写ui*/}</view>```里面写ui，就不存在子组件的通信问题了。\n\n##### 7. uni-transition组件设置:show=true，列表渲染时偶而无法显示出来\n\t\n解决办法：用属性控制```<uni-transition :show=\"show\" />```，在页面mounted生命周期里设置this.show=true，就能正常。\n\n原因未知。猜测是uni-transition组件open()方法中，setTimeout不知什么原因未执行，目前看只有列表渲染下的uni-transition才出现。\n\t\n##### 8. onLoad中有耗时操作，导致页面打开时白屏很久\n\n😊 我以为的：渲染层和逻辑层分离，逻辑层耗时操作不卡渲染。\n\n😭 实际的：onLoad里的耗时操作，耗时多久，页面就白屏多久。\n\n文档提到了[生命周期](https://uniapp.dcloud.net.cn/tutorial/page.html#lifecycle)，不详细，我测试的情况补充一下：onLoad是页面加载后调用（对应到原生为webview已创建完成），然后调用onShow（此时webview开始加载template），接着调vue的生命周期，created、mounted等相继被调用。首次渲染完成调用onReady。\n\t\n所以在onLoad、onShow中不要执行耗时的js操作，否则会推迟webview开始渲染的时机，看起来就是白屏。耗时操作放到mounted、onReady里面，此时webview渲染和js耗时并行，互不影响。\n\n> 题外话：\n如果界面依赖接口的数据返回（最常见的比如列表的展示）。如果在onReady里做耗时操作，虽然不影响页面渲染，但是它阻塞了接口的promise微任务。导致的结果就是列表一直显示空的，等到耗时操作完成，promise才处理，数据才发送到渲染层，列表才显示出来。\n\t\n##### 9. uniapp与app通信的js方法很耗时\n\n所以需要注意不能放在onLoad、onShow中，防止白屏。目前知道的有：\n\n- 使用Native.js的Api，如plus.android.runtimeMainActivity，plus.android.importClass。如果原生中的这个类特别大，比如Activity，首次导入很慢（低端机1s以上），再次调用不会。\n\t\n- 野火sdk的wfcClient.connect方法耗时贼长（低端机1s以上）。connect方法调用原生的sdk提供的api，不知道原生是如何实现的。\n\t\n- 调用原生插件或uts插件的方法，首次执行时较慢（低端机约200ms）。如：秒聊message页导入uts插件[qingchat-common]，首次调用该插件任意方法返回比较慢，后续就很快。\n\n[🔗 Native.js性能优化](https://uniapp.dcloud.net.cn/tutorial/native-js.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96)\n\n[🔗 unapp性能优化专题](https://uniapp.dcloud.net.cn/tutorial/performance.html#%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E4%B8%93%E9%A2%98)\n\n##### 10. vue的监听器中，耗时操作也可能白屏。\n\n在watch中如果使用了immediate: true，则监听函数handler也会在onLoad或onShow时机之间触发。此时，如果handler中有耗时操作，也会看到很长时间的白屏。\n\n##### 11. 能全靠css做动画就靠css，js去触发也容易被阻塞\n\n在低端机上，仅仅是设置data（如this.showAnim = true）的方法，由于逻辑层与渲染层通信，也有点慢（可能延迟50ms左右）。\n\n所以uni-transition、uni.createAnimation这种需要js去操作动画的，比起纯css动画要慢。同时js容易被耗时方法阻塞，如果被阻塞了，动画播放会滞后。\n","slug":"/uniapp-bugs"},{"id":"8a805668-38d4-5958-84eb-089d3e03469c","title":"【uniapp】与原生通信的几种方式","tags":["Uniapp","跨平台"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAMC/8QAFgEBAQEAAAAAAAAAAAAAAAAAAgED/9oADAMBAAIQAxAAAAHe4japjp//xAAaEAACAgMAAAAAAAAAAAAAAAAAEAECEhMx/9oACAEBAAEFAt9TI4oX/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAETAv/aAAgBAwEBPwGaJ5P/xAAXEQADAQAAAAAAAAAAAAAAAAAAARMC/9oACAECAQE/Aasro//EABUQAQEAAAAAAAAAAAAAAAAAABEg/9oACAEBAAY/Aiv/xAAcEAEAAgIDAQAAAAAAAAAAAAABABEhQRBhcaH/2gAIAQEAAT8hKMyvJRcfIqqaXqam3H//2gAMAwEAAgADAAAAEJTf/8QAFhEAAwAAAAAAAAAAAAAAAAAAAAFR/9oACAEDAQE/EFQUj//EABcRAAMBAAAAAAAAAAAAAAAAAAABIWH/2gAIAQIBAT8QnEjU/8QAHRAAAgMAAgMAAAAAAAAAAAAAAREAITEQcUFhgf/aAAgBAQABPxAe4ZXv3DSN+I9Q2k66fmEBig3sx24//9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/483b8/default_img4.jpg","srcSet":"/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/9fa5a/default_img4.jpg 184w,\n/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/63e75/default_img4.jpg 368w,\n/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/483b8/default_img4.jpg 735w","sizes":"(min-width: 735px) 735px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/9d028/default_img4.avif 184w,\n/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/c6ee4/default_img4.avif 368w,\n/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/6f2e7/default_img4.avif 735w","type":"image/avif","sizes":"(min-width: 735px) 735px, 100vw"},{"srcSet":"/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/ef27d/default_img4.webp 184w,\n/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/4ae45/default_img4.webp 368w,\n/leon-blog/static/08182f7be714083fcb8c0d08998d5a9d/51181/default_img4.webp 735w","type":"image/webp","sizes":"(min-width: 735px) 735px, 100vw"}]},"width":735,"height":368},"body":"---\ntitle: \"【uniapp】与原生通信的几种方式\"\ncover: images/default_img4.jpg\ncoverAlt: \"封面\"\ndescription: \"介绍uniapp中哪些与原生交互的方式\"\ndatePublished: \"2024-03-23 14:33:10\"\ndateModified: \"2024-03-23 14:33:10\"\ncategory: \"经验总结\"\ntags:\n  - Uniapp\n  - 跨平台\n---\n\nuniapp开发APP时，除了要写出优美、流畅的页面外，经常还需要调用原生的底层能力来实现各种功能。\n\n列举了一下，大概这几种：\n\n#### 1. uni.** API\n\n[🔗 uniapp api文档](https://uniapp.dcloud.net.cn/api/)\n\nuniapp官方提供的api，已经抹平了各个平台的差异，均使用统一的接口。基本上常用的基础功能都在uni.**下能找到。比如本地存储、网络请求、路由跳转等。\n\nuni API属于是比较稳定的了，执行速度快，优化好（要注意的是，有部分接口是特属于某些平台的）。\n\n缺点是**接口中规中矩**，能满足70～80%的需求，有很多情况下就会发现不够用。\n\n#### 2. plus.** API\n\n[🔗 h5+ api文档](https://www.html5plus.org/doc/)\n\nuniapp默认已经集成好了H5plus，直接可以使用plus下的api。\n\nplus API功能很全面，接口使用起来也会复杂一些了，比如手机文件管理，uni接口就是uni.saveFile或uni.getSavedFileInfo，连存储到哪里都不能选，就是方便但不灵活。而plus就能自己操作存储位置，拷贝、删除、查找文件等。\n\n> 能理解为什么uni不灵活，因为它要抹平全平台差异，导致的结果就是按照全部平台里的下限来支持。\n\nplus的api能满足几乎90%以上的需求了，使用NativeObj能绘制任意原生view，再配上很丰富的原生模块。*我猜uni API很多接口在实现的时候，涉及到app端也是直接调用plus API，其他端再适配一下就好了。*\n\n缺点也有，**只支持app**，如果你想同时支持h5，那就自己写代码吧。并且，**接口虽丰富，但并不代表易用**。比如NativeObj绘制view的过程堪比canvas手动绘图。\n\n#### 3. Native.js\n\n[🔗 Native.js api文档](https://www.html5plus.org/doc/zh_cn/android.html)\n\nNative.js(NJS)也包装在H5+ runtime里面。这玩意更强大一点，可以通过js语法来任意的调用原生的接口。在Android上是js直接调用java，在iOS上是js直接调用object-c。\n\n它的方法也就几个，不过因为是直接导入和操作原生的类和对象，所以实际能实现几乎全部的原生的功能了。\n![Native.js API](./uniapp/nativejs.jpg)\n\n原理：\n\n- NJS与原生通过javascriptInterface通信。\n- NJS获取到原生传过来的类、对象和基本数据类型，都映射成NJS预设好的类型。从而让js层调用。\n- NJS调用导入类，到达原生层，用反射获取Class。\n- NJS调用类的方法、属性、new。在原生层也是反射去执行。\n\n缺点：\n\n看了原理就知道缺点很多：首先就是**通信成本很高**，比如当前页面的activity实例，这个实例很大，传输到js层并转换，耗时很久（实测低端机至少1秒）。不过NJS对传输过的对象有缓存，所以就要自己控制好各个对象首次传输的时机（说白了就是这几秒肯定是要耗的，就看你耗在哪里）。\n\n其次，本身原生开发，反射就是比较耗时的操作，基本就是能不用就不用。**NJS实现的功能如果靠反射，复杂功能的耗时不敢想**。\n\n再之，NJS也需要了解原生知识才能开发。\n\n#### 4. 原生语言插件\n\n原生语言插件，就不用详细说了。Android端自己写好原生代码，然后打包成aar；iOS端也是写好原生打包framework。打包产物放到uniapp/nativeplugins里面就可以当成原生插件`uni.requireNativePlugin(***)`引入并使用。\n\n缺点：**必须要原生开发环境，原生代码开发**。\n\n\n#### 5. uts原生插件\n\n[我写的uts的介绍](/【uniapp】页面开发方式及原理#4-uts)\n\n使用uts语言去开发原生代码，就像是个语法糖，使用统一的类似ts的语言，最后生成的是原生代码。\n\n优点是对ts熟悉的前端人员很友好，至少不用为了语法发愁。也不用去准备原生开发环境，使用开发工具，再打包等。\n\n缺点是**仍然需要了解原生知识，不然没法开发**。\n\n对比NJS，性能肯定提升一大截，因为最后的产物仍然是原生插件；写法呢，也比NJS简单不少；能实现的功能也更多一些，能写UI组件。NJS想写个原生view出来可不容易啊。\n\n对比原生语言插件，开发方便太多了。\n","slug":"/【uniapp】与原生通信的几种方式"},{"id":"2177285a-5200-5839-a928-5d9192bcdce1","title":"【uniapp】页面开发方式介绍及原理","tags":["Uniapp","跨平台"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFgABAQEAAAAAAAAAAAAAAAAAAAIB/8QAFgEBAQEAAAAAAAAAAAAAAAAAAAED/9oADAMBAAIQAxAAAAHUJnaR/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAISARD/2gAIAQEAAQUCpSlKU3v/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEv/aAAgBAwEBPwGEP//EABYRAAMAAAAAAAAAAAAAAAAAAAABE//aAAgBAgEBPwGrKs//xAAWEAADAAAAAAAAAAAAAAAAAAAAIDH/2gAIAQEABj8CIv8A/8QAGBAAAwEBAAAAAAAAAAAAAAAAAAFhEBH/2gAIAQEAAT8hgiAiM+iz/9oADAMBAAIAAwAAABA7z//EABYRAAMAAAAAAAAAAAAAAAAAAAARUf/aAAgBAwEBPxBaJT//xAAVEQEBAAAAAAAAAAAAAAAAAAAAYf/aAAgBAgEBPxCCD//EABsQAQADAQADAAAAAAAAAAAAAAEAESFBMWGh/9oACAEBAAE/EKTftByoFOm/QsIS2s7Gvl4y2jeT/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/56675/default_img2.jpg","srcSet":"/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/9fa5a/default_img2.jpg 184w,\n/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/2a971/default_img2.jpg 367w,\n/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/56675/default_img2.jpg 734w","sizes":"(min-width: 734px) 734px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/9d028/default_img2.avif 184w,\n/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/fcbd2/default_img2.avif 367w,\n/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/61ef5/default_img2.avif 734w","type":"image/avif","sizes":"(min-width: 734px) 734px, 100vw"},{"srcSet":"/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/ef27d/default_img2.webp 184w,\n/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/6963a/default_img2.webp 367w,\n/leon-blog/static/82ade0d3cd42c9b4486472bcb52898a1/bce1f/default_img2.webp 734w","type":"image/webp","sizes":"(min-width: 734px) 734px, 100vw"}]},"width":734,"height":368},"body":"---\ntitle: 【uniapp】页面开发方式介绍及原理\ndescription: 介绍什么是uniapp的vue、nvue、uvue、uts开发，以及原理\ndatePublished: 2024-03-19 15:18:22\ndateModified: 2024-03-19 15:18:22\ncover: images/default_img2.jpg\ncoverAlt: 封面\nslug: uniapp-vue-nvue-uvue-uts\ncategory: 经验总结\ntags:\n  - Uniapp\n  - 跨平台\n---\n***（以下内容主要考虑app跨平台，小程序、快应用不考虑）***\n\nuniapp可以轻松开发一个跨平台应用。很多人只是知道它可以开发，但是不知道其实uniapp支持多种跨平台开发的方式。每一种方式都有一定的优缺点，同时也反映出来uniapp团队在跨平台技术方案上的不断改进和尝试。\n\n下面我们来详细的分析一下每一种开发方式：\n\n#### 1. vue页面\n\nvue页面是使用vue的语法开发的页面，和web开发没区别，只不过global增加了uni、plus等的api方便调用原生能力。可以使用vue2语法和vue3语法。在app上，vue页面逻辑层和视图层是分离的（微信小程序等很多小程序技术都类似），在编译过程uniapp将视图层代码和逻辑层的代码分开了。vue2语法使用基于webpack的编译器，vue3语法使用基于vite的编译器（uniapp对编译器做了很多调整）。\n\n**渲染层**使用webview渲染。（Android上默认使用系统的webview，但是各手机webview有一定兼容差异性，可以使用腾讯x5引擎代替。iOS默认用WKWebview）。\n\n**逻辑层**使用一个`jscore`（iOS）/`v8`（Android）的js引擎。执行标准js代码，但是没有浏览器专用的window、document等api。可以用uni、plus等api。\n\n> 逻辑层和渲染层分离主要是为了逻辑层的复杂运算不卡渲染层。但是缺点也比较明显，每次通信都有耗时，所以类似于监听scroll并计算位置，再定位元素这种非常频繁通信的操作就不能做。\n\n可能还有其他优化，但不管怎么样，**uniapp的vue页面明显要比纯H5套壳的APP性能要高很多，至少窗口动画，页面渲染很流畅。**不是很复杂的页面的话，基本vue页面已经能满足条件。\n\n#### 2. nvue页面\n\nnvue页面是`native vue`。nvue也是逻辑层和渲染层分离的，所以上面的通信问题nvue也存在。只不过nvue的渲染层是使用基于weex的渲染器，可以将由vue编写的ui模版最终在运行时渲染为原生组件。\n\n> uniapp的渲染层基于weex渲染器，在它的基础上修改了一些bug，并扩展了一些排版能力。参考[nvue介绍](https://uniapp.dcloud.net.cn/tutorial/nvue-outline.html#nvue%E4%BB%8B%E7%BB%8D)\n\n简单理解就是仍然使用前端技术栈，vue作为语法糖，编译时通过改进的compiler将vue编译为js代码。在运行时由逻辑层生成虚拟DOM，并将虚拟DOM通过`JsBridge`发送到原生来绘制为原生组件\n\n```html\n<!-- 比如以下template -->\n<view style=\"display: flex; flex-direction: column; height: 300px;\">\n    <text style=\"color: red;\">Hello</text>\n    <text style=\"color: black; flex: 1;\">Leon</text>\n</view>\n\n<!-- 渲染到Android就是 -->\n<LinearLayout\n    android:layout_width=\"match_parent\"\n    android:layout_height=\"300px\"\n    android:gravity=\"vertical\" >\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:color=\"#ff0000\"\n        android:text=\"Hello\" />\n\n    <TextView\n        android:layout_width=\"wrap_content\"\n        android:layout_height=\"wrap_content\"\n        android:layout_weight=\"1\"\n        android:color=\"#000000\"\n        android:text=\"Leon\" />\n</LinearLayout>\n```\n\n这么一看，weex处理了非常多的繁杂的组件对应，属性对应，属性计算/转换等等工作👍。不是很难但确实很烦。所以nvue支持的能力有限（几乎不可能在app上支持全部的css属性），比如nvue只能使用flex布局。不过到目前为止[nvue支持的组件和属性](https://uniapp.dcloud.net.cn/tutorial/nvue-css.html)已经很多了，基本能满足使用。\n\nnvue的逻辑层也是基于jscore/v8的引擎。逻辑层响应式数据变更，利用JsBridge通信驱动渲染层原生组件UI变更。\n\nnvue可以和vue混合去开发一个app，也可以纯nvue、或者纯vue开发app。**注意：混合开发时，它们的js引擎实例是分开的，独立的**。\n\nnvue对比vue：\n\n* nvue在滚动和长列表上的性能明显优于vue。nvue最终还是使用原生组件比如ScrollView、RecyclerView来渲染的，体验就是原生的体验。布局复用布局销毁都非常快。\n* nvue使用canvas绘图组件，不太行。官方说性能不如vue。\n* nvue页面初始化很快，相比之下，vue初始化慢不少，所以vue页面的启动页等待时间挺久的。\n* nvue写起来复杂很多。需要按照原生的习惯和风格写，但是写的又是css代码，好多属性也不支持。对于原生开发和css开发都有一定的学习成本。\n* nvue有一些不支持的特性，比如不支持Vue的全局组件、过滤器、指令等。\n\nnvue比vue渲染性能要好不少，**因为UI换成了原生组件**。但是js层仍有很大优化空间。\n\n#### 3. uvue\n\nuvue跟vue/nvue是分开的技术栈了，也不再叫uniapp开发，改叫uniapp x开发。所以uvue跟vue/nvue不能混用。并且uniapp x只支持web、android、ios三个平台。\n\nuvue最终是会被编译为原生代码的，Android编译为`kotlin`、ios编译为`swift`、web编译为`js`。\n\n**所以本质上uvue就是类vue写法的原生应用**。通过编译器将uvue语法转为最后的原生语法。包括uts编译器和uvue编译器。uvue编译器是基于vite扩展开发的。\n\n* template里写入组件树，只能用uview可以用的组件。（最终编译为原生组件）\n* script仅支持[uts语法](#4-uts)。（最终编译为原生代码）\n* style的是web css的子集，和nvue支持的css差不太多。可用css、less、scss语法。（最终也是作为原生组件的属性）\n\nuvue和vue开发方式差不多，但是最终都转为原生的代码了。uvue对比之前的跨平台方案，不存在逻辑层和渲染层分离的问题，通信也没有任何压力。uvue对比flutter这样的自渲染方案，不会存在原生组件和自渲染组件的融合问题。[uvue渲染](https://doc.dcloud.net.cn/uni-app-x/#_2-uvue%E6%B8%B2%E6%9F%93%E5%BC%95%E6%93%8E)。\n\n看起来uvue是最完美的方案了。**不过目前组件和api不全，css的bug还有uts的bug暂时不明了**。有待优化。\n\n> 按我的理解，uvue编译器类似于vite，负责处理SFC并打包。支持treeshaking、解析SFC、css预编译等。最终转为uts代码。uvue底层使用一个重写的类似于vue的uts库。也实现了响应式系统和虚拟DOM。所有uts代码准备完毕后，交给uts编译器。uts编译器转译uts代码为原生代码，再调用kotlin编译器、swift编译器编译原生代码为字节码。\n\n#### 4. uts\n\n[uts](https://doc.dcloud.net.cn/uni-app-x/uts/)仅是一门语言，带类型的语言，语法类似于ts。但实际上它不仅仅只作为uvue的逻辑层语言，uts还可以独立去开发原生插件和原生UI组件，并且插件和UI组件能同时支持所有端（前提是你自己适配了）。\n\n三种开发场景的不同：\n\n| 区别       | uvue中           | 开发插件          | 开发UI组件             |\n| -------- | --------------- | ------------- | ------------------ |\n| **文件后缀** | .uvue           | .uts          | .vue               |\n| **区分平台** | 条件编译语法          | 平台目录下         | 平台目录下              |\n| **可用平台** | web、Android、iOS | 全平台           | 全平台（app下不支持vue）    |\n| **组织方式** | vue2选项式/vue3组合式 | export导出方法    | index.vue中书写vue2语法 |\n| **产物**   | 原生页面            | 原生插件，import导入 | 原生view             |\n\nuts能编译成原生的代码。所以它相当于换了一种形式写原生代码。同时也能看到，要支持写原生代码，再加上需要类型，在Andoid端它把Android源码的类都做了对应的一份type定义（我很好奇Android源码上百万个类，method、field更是不计其数，uniapp团队能全部整理出来吗？还是通过class批量生成的？）\n\n```javascript\n// uts开发插件示例：\n// 导入了android的类\nimport NotificationManagerCompat from 'androidx.core.app.NotificationManagerCompat';\n// 检查是否有通知权限\nexport const isNotificationEnabledSync : IsNotificationEnabledSync = function () : boolean {\n\tconst context = UTSAndroid.getAppContext()\n\tif (context != null) {\n\t\tconst res = NotificationManagerCompat.from(context).areNotificationsEnabled()\n\t\treturn res\n\t} else {\n\t\treturn false\n\t}\n}\n```\n\n![androidx通知管理器类型定义](./uniapp/notificationmgr.jpg)\n\n（可能是错误的）uts编译过程：*（下面包含一些我的个人理解和猜测，因为没有开源、文档也没那么深入原理）*\n\n* uts对基础语法，比如数据类型、关键字、if、for、class等，最终根据平台编译为对应平台的语法。\n* uts导入系统包、三方aar包等语句，把import语句转为对应平台语法的字符串了。\n* uts导入另一个模块，类似于ESM导入，静态分析，并编译对应模块的uts。\n* 以上三步完成后就形成了对应平台的源码，再调用对应平台的编译器（如kotlin、swift）生成最终的字节码产物。\n\nuvue编译过程：\n\n* uvue文件先走uvue编译器，取SFC代码块，模版和样式经过编译。最终输出为uts代码。\n* 上一步后，uvue文件转译为uts文件\n* uts文件走上述uts编译过程，形成原生产物。\n\nuts也有学习成本，因为你仍然需要原生知识，比如android上，我要使用哪些类，调用类的哪些方法来实现xx功能。iOS上可能就是另外的实现方式。它其实是方便了习惯ts的开发人员不用再学习新的语言，也不用准备复杂的开发环境，IDE，打包等等。","slug":"/uniapp-vue-nvue-uvue-uts"},{"id":"ebf9fc60-3bae-5881-a2d3-579dcc24557f","title":"点名识别","tags":["C++","脚本","语音处理","AI","库"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBP/EABUBAQEAAAAAAAAAAAAAAAAAAAEE/9oADAMBAAIQAxAAAAHruVc0Un//xAAZEAEAAgMAAAAAAAAAAAAAAAABAAIQISL/2gAIAQEAAQUCK8lIm8//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAVEQEBAAAAAAAAAAAAAAAAAAAQIf/aAAgBAgEBPwGn/8QAFxAAAwEAAAAAAAAAAAAAAAAAAAEgIf/aAAgBAQAGPwIWz//EABkQAAMAAwAAAAAAAAAAAAAAAAABESAhQf/aAAgBAQABPyGjPoh7RSEYf//aAAwDAQACAAMAAAAQ8N//xAAXEQADAQAAAAAAAAAAAAAAAAABEBFR/9oACAEDAQE/EKMX/8QAFhEBAQEAAAAAAAAAAAAAAAAAAQBh/9oACAECAQE/EHULf//EAB0QAAICAQUAAAAAAAAAAAAAAAERACEQMUFRofD/2gAIAQEAAT8QCRepcV7qVZ3DVQZgZGFj/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/301eb/speech_cover.jpg","srcSet":"/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/d2c77/speech_cover.jpg 137w,\n/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/9e829/speech_cover.jpg 273w,\n/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/301eb/speech_cover.jpg 546w","sizes":"(min-width: 546px) 546px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/6d865/speech_cover.avif 137w,\n/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/09d0f/speech_cover.avif 273w,\n/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/4cad8/speech_cover.avif 546w","type":"image/avif","sizes":"(min-width: 546px) 546px, 100vw"},{"srcSet":"/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/dfc78/speech_cover.webp 137w,\n/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/5aa8e/speech_cover.webp 273w,\n/leon-blog/static/79f898dd8bd8e2cec2e5330123914ee5/24d43/speech_cover.webp 546w","type":"image/webp","sizes":"(min-width: 546px) 546px, 100vw"}]},"width":546,"height":274},"body":"---\ntitle: \"点名识别\"\ncover: images/speech_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"大数据部-课堂老师提取音频，speech-to-text，拼音模糊音匹配算法\"\ndatePublished: \"2019-01-16 07:33:04\"\ndateModified: \"2019-01-16 07:33:04\"\ncategory: \"框架工具\"\ntags:\n  - C++\n  - 脚本\n  - 语音处理\n  - AI\n  - 库\n---\n\n点名识别使用课堂老师音频提取、切割转码、speech-to-text、拼音模糊音算法匹配等手段，计算点名次数\n\n### 背景\n\n需要对各个授课老师课堂教学效果进行数据化评测。\n\n### 我的职责\n\n作为项目负责人负责点名的数据化分析工作。包括数据资源获取、方案调研、方案设计、编码实施、申请资源、效果统计等。\n\n### 主要技术\n\n1. 整体程序使用shell脚本运行\n\n2. shell负责处理oss音频批量提取webm、webm提取pcm、pcm静音去除/降噪、pcm静音切分vad、pcm转wav\n\n3. 其中静音切分使用webrtc的vad模块c++源码\n\n4. wav调用百度/讯飞接口speech-to-text转文本\n\n5. 文本转拼音，不断调整模糊音匹配算法，提升准确率","slug":"/点名识别"},{"id":"9bc51684-8121-596a-88aa-444a4566a58f","title":"vite-reactts-starter","tags":["前端","脚手架","React","Antd","Vite","开源"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIFBP/EABQBAQAAAAAAAAAAAAAAAAAAAAH/2gAMAwEAAhADEAAAAdFKdURBwf/EABwQAAEDBQAAAAAAAAAAAAAAAAACBBIBAxARM//aAAgBAQABBQJjTdqKSKRhxx//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAbEAABBAMAAAAAAAAAAAAAAAABACEykRARcf/aAAgBAQAGPwI7d1EUoike5//EABgQAQADAQAAAAAAAAAAAAAAAAEQQWHw/9oACAEBAAE/IReR3TJlLjyf/9oADAMBAAIAAwAAABAkL//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABYRAAMAAAAAAAAAAAAAAAAAAAEQMf/aAAgBAgEBPxA1f//EABsQAAEEAwAAAAAAAAAAAAAAABEAAdHxEKGx/9oACAEBAAE/EDU7YN3AKuQqRC3vGf/Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/dba67/cover.jpg","srcSet":"/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/891f5/cover.jpg 176w,\n/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/19cc4/cover.jpg 352w,\n/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/dba67/cover.jpg 704w,\n/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/1f3b1/cover.jpg 1408w","sizes":"(min-width: 704px) 704px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/94818/cover.avif 176w,\n/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/bd4f6/cover.avif 352w,\n/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/2856f/cover.avif 704w,\n/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/69a09/cover.avif 1408w","type":"image/avif","sizes":"(min-width: 704px) 704px, 100vw"},{"srcSet":"/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/76df1/cover.webp 176w,\n/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/d3e0a/cover.webp 352w,\n/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/b4509/cover.webp 704w,\n/leon-blog/static/f0c93c86aa0622d07abc2a465eb0949a/816c4/cover.webp 1408w","type":"image/webp","sizes":"(min-width: 704px) 704px, 100vw"}]},"width":704,"height":368},"body":"---\ntitle: \"vite-reactts-starter\"\ncover: vrars/cover.jpg\ncoverAlt: \"脚手架模版\"\ndescription: \"vite+react+ts+Antd+redux+eslint项目启动脚手架\"\ndatePublished: \"2021-10-10 10:27:09\"\ndateModified: \"2021-10-10 10:27:09\"\ncategory: \"框架工具\"\ntags:\n  - 前端\n  - 脚手架\n  - React\n  - Antd\n  - Vite\n  - 开源\n---\n\nVite for React快速启动脚手架。\n\n*[Vite + React + TypeScript + React Router + Redux Toolkit + Antd + Eslint + Prettier + axios + less]*\n\nGithub仓库：https://github.com/missmess/vite-reactts-antd-redux-starter\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [截图](#截图)\n\n### 主要功能\n\n1. **集成常用三方框架，一键启动**\n\n1. **默认自带通用管理后台样式**\n\n1. **支持配置式路由**\n\n    支持本地tsx或json来配置菜单。\n\n    页面组件可以直接用string格式路径。\n\n1. **支持N级嵌套菜单**\n\n1. **菜单和路由联动**\n\n1. **可使用页面标签卡组件**\n\n1. **面包屑/页面标签卡和路由联动**\n\n### 截图\n\n![管理后台](./vite-react/1.png)\n![配置菜单代码](./vite-react/2.png)","slug":"/vite-reactts-starter"},{"id":"6a9d8eb1-0458-5142-87bb-cc1695d20308","title":"vite-plugin-qiankun","tags":["前端","库","微前端","Vite","开源"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAEEAgP/xAAWAQEBAQAAAAAAAAAAAAAAAAADAAT/2gAMAwEAAhADEAAAAd0w9R1IRF//xAAaEAACAwEBAAAAAAAAAAAAAAAAAQIDERMh/9oACAEBAAEFAvE+2KVluoiNs//EABgRAAIDAAAAAAAAAAAAAAAAAAACESEx/9oACAEDAQE/AWyyT//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABoQAAICAwAAAAAAAAAAAAAAAAACETEBEDL/2gAIAQEABj8CuSEXBy27P//EABwQAQABBQEBAAAAAAAAAAAAAAEAESExQXGBkf/aAAgBAQABPyEtFMbUgvECbB4MyezaVWX2f//aAAwDAQACAAMAAAAQQ+//xAAXEQADAQAAAAAAAAAAAAAAAAAAAUEh/9oACAEDAQE/EGToZh//xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8QB2f/xAAdEAEBAAIBBQAAAAAAAAAAAAABEQAhQXGBkbHx/9oACAEBAAE/EKpATAJLVfGA7gciD15wrtxdj1jSS/GNm3GF1Huz/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/fff17/default_img5.jpg","srcSet":"/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/9fa5a/default_img5.jpg 184w,\n/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/63e75/default_img5.jpg 368w,\n/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/fff17/default_img5.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/9d028/default_img5.avif 184w,\n/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/c6ee4/default_img5.avif 368w,\n/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/b4627/default_img5.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/ef27d/default_img5.webp 184w,\n/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/4ae45/default_img5.webp 368w,\n/leon-blog/static/c1ff24cf1a57db96025bbcec71e9035b/20e6b/default_img5.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"vite-plugin-qiankun\"\ncover: images/default_img5.jpg\ncoverAlt: \"封面\"\ndescription: \"让qiankun框架支持vite的es特性的框架\"\ndatePublished: \"2022-09-02 11:38:19\"\ndateModified: \"2022-09-02 11:38:19\"\ncategory: \"框架工具\"\ntags:\n  - 前端\n  - 库\n  - 微前端\n  - Vite\n  - 开源\n---\n\nvite-plugin-qiankun是用于vite构建的微应用，想要接入qiankun时，需要引入该插件。\n\ngithub仓库：https://github.com/missmess/vite-plugin-qiankun/tree/feature/support-prod-publicpath\n\n---\n\n### 为什么需要这个插件？\n\nqiankun加载vite微应用时，开发模式下，对于ES模块无法获取到对应的生命周期函数。所以需要修改html entry的代码来hack生命周期的函数。\n\n同时微应用的相对路径的资源需要添加前缀（微应用的地址）```window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__```。否则资源加载会出现404。\n\n> 参考：[qiankun使用webpack时的publicPath](https://qiankun.umijs.org/zh/faq#a-%E4%BD%BF%E7%94%A8-webpack-%E8%BF%90%E8%A1%8C%E6%97%B6-publicpath-%E9%85%8D%E7%BD%AE)\n\nwebpack本身就有[runtime publicPath技术](https://webpack.js.org/guides/public-path/#on-the-fly)，而vite还没有。\n\n### 原理\n\nqiankun加载vite微应用，hack代理方法window.proxy[vite-app-name].mount指向代码中配置的`renderWithQiankun`的参数对象。这样qiankun就能正常调用各个生命周期函数。\n\n同时，vite开发环境下，加载qiankun微应用的esm模块时，需要修改路径追加前缀。\n比如```./main.ts```，需要改为```window.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ + '/main.ts'```。\n\n这样的话，qiankun就能正常加载es模块入口代码。\n\n### 使用方法\n\n**安装**\n\n`@oneline.top/vite-plugin-qiankun`用于支持qiankun。`vite-plugin-dynamic-base`用于vite支持动态publicPath。\n\n```shell\nnpm install -D @oneline.top/vite-plugin-qiankun vite-plugin-dynamic-base\n```\n\n**vite.config.ts**\n\n配置动态base为`window.__DYNAMIC_BASE_PATH__`变量。\n\n```typescript\nimport qiankun from '@oneline.top/vite-plugin-qiankun';\n...\nexport default defineConfig(({ mode }) => {\n  return {\n    plugins: [\n      ...\n      qiankun(MICRO_APP_NAME, {\n        useDevMode: true,\n        // qiankun-plugin默认会处理js文件，跟设置的base冲突了，所以需要手动去掉\n        urlTransform: (ori) => ori.replace('/__dynamic_base__', ''),\n      }),\n      dynamicBase({\n        // 所有的资源导入路径，前缀加上该动态变量\n        publicPath: ' window.__DYNAMIC_BASE_PATH__ ',\n        // 是否转换入口html文件\n        transformIndexHtml: true,\n      }),\n    ],\n    ...\n    // dynamicBase要求打包时必须加上该前缀，用来在代码中匹配并替换为dynamicBase.publicPath\n    base: process.env.NODE_ENV === 'production' ? '/__dynamic_base__/' : '/',\n  }\n})\n```\n\n**main.ts**\n\n在入口文件设置`window.__DYNAMIC_BASE_PATH__`动态变量从qiankun变量来获取。\n\n\n```javascript\n// 用于子应用的资源动态加载路径\nwindow.__DYNAMIC_BASE_PATH__ = window.proxy ? window.proxy.__INJECTED_PUBLIC_PATH_BY_QIANKUN__ : '';\n```\n\n### 存在的问题\n\n生产环境必须要在vite.config.ts中配置base。但是这样的话就不能支持多环境部署了（如微应用部署到//xxx.prod.com、//xxx.test.com）。\n\n但是vite又不像webpack一样支持runtime publicPath，所以用到了另一个插件：[vite-plugin-dynamic-base](https://github.com/chenxch/vite-plugin-dynamic-base)。\n\nvite-plugin-qiankun和这个插件有冲突，所以修改了vite-plugin-qiankun源码，增加了urlTransform特性，让插件对路径做预转换。\n\n同时去掉插件中，生产环境下不支持动态base的代码。\n\n最后实现的效果就是，vite+React的微应用能在开发环境下正常使用。同时生产打包后，能支持多环境部署。微应用可以用域名直接访问；也可以在主应用中加载，微应用的资源地址始终是从`__INJECTED_PUBLIC_PATH_BY_QIANKUN__`参数获取的，不会404。\n\n原issue链接：https://github.com/tengmaoqing/vite-plugin-qiankun/issues/16","slug":"/vite-plugin-qiankun"},{"id":"ba366ed7-d01e-5167-b0ba-5f5a4ee9a648","title":"【造轮子】在React中手搓一个Vue","tags":["前端","Vue2","架构","造轮子"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABtElEQVQoz62Sz4rTUBjF+zyzmZ1rB0RwMxQqgjaTm+bec77kJm3+3DbN1E4VupDWdlQ6ylARxI3gTnf6AL6GD+EDKGnRAXHhgKtv8cGPczi/FgCSjADEACyAhGQfwABARrIgWQJwJEckK5JjADXJCcmHJKcAZiQftUAQwtgA1pApyPSfgcAOCPLM/AYaMFUmsFZM0jMhNSzJARsYkBNogA7AkMCIwJhkDeAU2CeMoSeR0dMd0GRx3J5ll522mh+P021QJRU0GYpYLZIYcmBEMk3mYXNFCi3i9C4p6p5Eszv9etO27nwHtNoEt7f11xtR9ONoU32Ds+m4610431+XSq0KpRZD33+RK7WcdLvvh77/yinV/Ldl4D85ys4uDkbrL4du8aljy3Ur8nUYnPaHNz/Mvt9bluf2ftgre2pVed7LyvMuC6WWTqnneRAsq5OTN2PPe1t73jvn+6/znprfyqabg9H686FbfLxri1ULQpEQeDDPH0OYEEiMSByS+8oifSMy+KNy+atyKNHsOB0969ji6X6URhthJEpjp83VytcaRWCmV8DGQ6EFYXkdD/+qzX8W+yfMUk5jYrGQhQAAAABJRU5ErkJggg=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/f945c/vue-in-react.png","srcSet":"/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/6c0e0/vue-in-react.png 184w,\n/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/b5bc4/vue-in-react.png 368w,\n/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/f945c/vue-in-react.png 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/9d028/vue-in-react.avif 184w,\n/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/c6ee4/vue-in-react.avif 368w,\n/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/b4627/vue-in-react.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/ef27d/vue-in-react.webp 184w,\n/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/4ae45/vue-in-react.webp 368w,\n/leon-blog/static/32fc9508faffdc87ca27c8b9e924bce3/20e6b/vue-in-react.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"【造轮子】在React中手搓一个Vue\"\ncover: ../static/assets/vue-in-react.png\ncoverAlt: \"封面\"\ndescription: \"如何在React中模拟写出来一个Vue\"\ndatePublished: \"2021-12-22 21:30:17\"\ndateModified: \"2021-12-22 21:30:17\"\nslug: \"vue-demo\"\ncategory: \"经验总结\"\ntags:\n  - 前端\n  - Vue2\n  - 架构\n  - 造轮子\n---\n\n闲来无事，突发奇想，来造个轮子吧：如何在React中，仿照Vue的框架功能设计，重造一个Vue出来。\n\n> 注意！并不是**Vue的源码解析**，也不是**Vue官方版本的minimal**。完全是我个人根据Vue的功能，凭空捏的一个变种Vue。做这个的目的只是为了提升自己的框架设计能力！\n\n花了4、5个小时的时间，一步一步捏出来，最后实现的功能大概有这些：\n\n| 功能点 | 说明 |\n| --- | --- |\n| data | 支持响应式数据 |\n| watch | 监听响应式数据的变化 |\n| methods | 支持方法 |\n| components | 支持添加子组件 |\n| props | 子组件支持props |\n| mounted | 组件加载 |\n| destroyed | 组件卸载 |\n| render | 使用渲染函数渲染组件，支持子组件，html元素 |\n| style | 支持style内联样式 |\n| 事件处理 | 支持事件监听 |\n| 局部重绘 | 只有状态变更的组件才会重绘 |\n| 虚拟dom | 组件树转换成了VNode |\n\n没有列出的功能都是没有实现的，包括但不限于`模版语法`、`diff算法`、`计算属性`、`条件/列表渲染`、`组件slot`、`$emit`、`filter`、`mixin`、`全局方法`等等。*（内容有点太多了，这些都可以慢慢加，并不是重点）*。\n\n> 总结下来就是：Vue的核心设计包括`响应式`、`组件化`、`虚拟dom`、`diff算法`、`模版语法`。本次demo实现了`响应式`、`组件化`、`虚拟dom`。\n\n最终的用法和Vue一样：\n```javascript\nnew Vue({\n  el: ref.current!, // 挂载到react的div元素上\n  data() {\n    return {\n      toggle: true,\n    };\n  },\n  methods: {\n    clickChange() {\n      this.toggle = !this.toggle;\n    },\n  },\n  watch: {\n    toggle: function (newVal, oldVal) {\n      console.log(`toggle: ${oldVal} -> ${newVal}`);\n    },\n  },\n  mounted() {\n    console.log(\"page mounted\");\n  },\n  render(h) {\n    return h(\"article\", {}, [\n      h(\"h3\", {}, [\"父组件-【App】\"]),\n      h(\"span\", {}, [`当前状态：${this.toggle ? \"开启\" : \"关闭\"}`]),\n      h(\"button\", { onClick: this.clickChange }, [\"切换\"]),\n    ]);\n  },\n});\n```\n\n💻源码在最后。\n\n---\n\n### 先看Demo效果\n\n展示的效果如下：\n\n<video src=\"../static/assets/vue-演示.mov\" width=\"100%\" autoplay muted loop />\n\n渲染函数的组件结构：\n\n```typescript\n// App组件\nrender(h) {\n  return h(\n    \"article\",\n    { style: { backgroundColor: \"aliceblue\", padding: \"10px\" } },\n    [\n      h(\"h3\", {}, [\"父组件-【App】\"]),\n      h(\"span\", {}, [`当前状态：${this.toggle ? \"开启\" : \"关闭\"}`]),\n      h(\"button\", { onClick: this.clickChange }, [\"切换\"]),\n      h(\"section\", {}, [h(\"Comp\", { state: this.toggle })]), // Comp子组件\n    ]\n  );\n}\n...\n// Comp组件\nrender(h) {\n  return h(\"div\", { style: { background: \"antiquewhite\" } }, [\n    h(\"h3\", {}, [\"子组件-【Comp】\"]),\n    h(\"p\", {}, [`父组件状态：${this.state ? \"开启\" : \"关闭\"}`]),\n    h(\"button\", { onClick: this.clickAdd }, [\"count+1\"]),\n    h(\"span\", { \"aria-label\": \"计数\" }, [`count: ${this.count}`]),\n  ]);\n}\n```\n\n最终生成的dom结构：\n\n![](../static/assets/dom结构.jpg)\n\n### 实现步骤\n\n#### 搭出一个Vue架子\n\n**0. 准备工作**\n\n先创建一个`React项目`，用CRA也好，用其他模版也好。项目创建好后，在源码目录下创建一个`libs/vue.tsx`。\n\n**1. Vue设置选项**\n\n先想好我们要支持哪些功能，然后在`vue.tsx`中写好Vue的设置选项的类型`VueOptions`。这样我们`new Vue({/* VueOptions */})`的时候就能看到这些选项了。\n\n```typescript\nexport type VueOptions = {\n  el?: HTMLElement | null;\n  components?: Record<string, VueOptions>;\n  props?: string[];\n  data?: () => Record<string, any>;\n  watch?: Record<string, (newVal: any, oldVal: any) => void>;\n  methods?: Record<string, any>;\n  mounted?: () => void;\n  destroyed?: () => void;\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode;\n};\n```\n\n**2. Vue的class初始化**\n\n开始写Vue的class实现。Vue实例需要从VueOptions里读取配置，并初始化，存储为class变量。\n\n```typescript\nexport default class Vue {\n  _options: VueOptions; // 选项\n  el?: HTMLElement | null; // 父级element元素\n  components: Record<string, VueOptions>; // 声明的组件\n  _componentInstances: Record<string, Vue>; // 使用到的组件实例\n  data: Record<string, any>; // 数据\n  methods: Record<string, any>; // 数据\n  props: Record<string, any>; // 数据\n  watchers: Record<string, (newVal: any, oldVal: any) => void>; // 监听器\n  mounted: () => void; // 挂载完成回调\n  destroyed: () => void; // 销毁回调\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode; // 渲染函数\n\n  constructor(options: VueOptions) {\n    this._options = options;\n    // el\n    this.el = options.el;\n    // components\n    this.components = options.components || {};\n    // data\n    this.data = options.data?.() || {};\n    // method\n    this.methods = options.methods || {};\n    // prop\n    this.props = {}\n    for (const key of (options.props || [])) {\n      this.props[key] = undefined;\n    }\n    // watch\n    this.watchers = options.watch || {};\n    // lifecycle\n    this.mounted = options.mounted || (() => {});\n    this.destroyed = options.destroyed || (() => {});\n\n    this.render = options.render;\n\n    this._init();\n  }\n  _init() {\n    this.mounted();\n    // 首次渲染\n    this._doRender.call(this);\n  }\n  ...\n}\n```\n\n#### 监听数据变化\n\n数据都获取到了，开始搓Vue最重要的一个功能：`响应式`。响应式贯穿了Vue很多的功能，不过我们本次demo要实现的功能简化版的：监听data或props的数据变化，并且在变化时，触发watcher和重新渲染。Vue2和Vue3略有不同，Vue2使用`Object.defineProperty`实现，Vue3使用`Proxy`实现。我们这次demo直接用`Proxy`。\n\n考虑到我们要在watcher、method、生命周期里面都要通过this.xxx能访问到**data、methods和props**。所以将**data、methods和props**都加到一个proxy实例上，这个proxy是我们要实现响应式的核心。既要通过这个proxy监听数据变化，也要将watcher、method之类的`this指向`设置到为proxy上。\n\n> 这里和正版Vue的实现不一样，正版Vue的proxy为Vue实例本身，我们是新加了一个proxy对象。\n\n```typescript\nexport default class Vue {\n  ...\n  // 去掉data、methods、props\n  proxy: Record<string, any>; // 代理对象，用于访问this.data、this.methods、this.props\n  ...\n  constructor(options: VueOptions) {\n    // 也去掉data、methods、props的初始化\n    this.proxy = this._proxyThis(\n      options.data?.(),\n      options.methods,\n      options.props\n    );\n  }\n  ...\n  // 为当前Vue实例创建一个代理\n  _proxyThis(data: Record<string, any> = {}, methods: Record<string, any> = {}, props: string[] = []) {\n    const that = this;\n    const obj = { ...data, ...methods };\n    for (const key of props) {\n      obj[key] = undefined;\n    }\n    const proxy = new Proxy(obj, {\n      get: (target, p: string, receiver) => {\n        const value = target[p];\n        if (typeof value === \"function\") {\n          // 为methods绑定proxy\n          return value.bind(proxy);\n        }\n        return value;\n      },\n      set: (target, p: string, newValue, receiver) => {\n        const oldValue = target[p];\n        target[p] = newValue;\n        // 触发watcher\n        if (p in that.watchers) {\n          that.watchers[p].call(proxy, newValue, oldValue);\n        }\n        // 重新渲染\n        that._doRender.call(that);\n        return true;\n      },\n    });\n    return proxy;\n  }\n}\n```\n\n代码中，我们为methods和watchers重新设置`this`指向proxy。同时在`set`props和data时，触发watcher和重新渲染。\n\n#### 渲染一：生成虚拟dom\n\n接下来就是渲染过程。本次demo中我们没有使用`模版语法`，直接使用的是渲染函数。属实是简化了许多。\n\n> 正版Vue的模版语法，是有**解析模版html转为AST** -> **AST转为调用渲染函数** -> **渲染函数生成虚拟dom** -> **虚拟dom更新真实dom**。\n\n渲染函数即在每个vue组件中，都实现`render函数`来告知vue本组件是什么结构。`render函数`提供一个`h方法`来创建虚拟dom。\n\n所以我们需要通过我们提供的`h方法`，将本组件中的虚拟dom节点都记录下来。`h方法`我们保持和正版vue相同的三个参数：`type`-节点类型，`props`-节点属性，`children`-该节点的子节点数组。节点包含原生dom元素和已注册的vue组件，如果是原生dom元素，那props我们就当作元素的attrs设置上去；如果是组件，那props就作为组件的props传递下去。\n\n先不考虑vue组件，实现一下`h方法`：\n\n```typescript\n/** 虚拟node节点 */\nexport type VNode = {\n  type: string;\n  props: Record<string, any>;\n  children: VNode[];\n};\n\nexport default class Vue {\n  ...\n  h(type: string, props: any, children: any[] = []): VNode {\n    let vnode: VNode;\n    if (this.components.hasOwnProperty(type)) {\n      // 如果是自定义组件 TODO\n    } else {\n      // 如果是原生标签\n      // 存储为VNode\n      vnode = { type, props, children };\n      // 添加children\n      vnode.children = [];\n      for (const child of children) {\n        if (typeof child === \"string\") {\n          vnode.children.push({\n            type: \"text\",\n            props: { textContent: child },\n            children: [],\n          });\n        } else {\n          vnode.children.push(child);\n        }\n      }\n    }\n    return vnode;\n  }\n  ...\n}\n```\n\n这样我们就将原生dom元素和纯文本保存为`VNode`（就是定义的虚拟dom节点）\n\n#### 渲染二：创建真实dom\n\n前面我们在`init()`和`watcher触发`时都调用了`_doRender()方法`，在这里我们就是要执行具体的渲染操作了：将虚拟dom映射为真实dom上。该创建创建该更新更新。不过这个demo也是为了简单，正版vue是需要通过diff算法来判断哪些dom需要创建，哪些dom不需要创建只需要更新，这次的demo先去掉这些，每次渲染都是全部卸载后创建。*（日后有时间再补上）*\n\n```typescript\nexport default class Vue {\n  ...\n  // 执行渲染（简化版本，没有加diff算法）\n  _doRender() {\n    if (this.el) {\n      const vnodeTree = this.render(this.h.bind(this));\n      // 清空el下所有元素\n      this.el.innerHTML = \"\";\n      // 重新渲染子树\n      this._renderRecursively(vnodeTree, this.el);\n    }\n  }\n\n  // 递归渲染vnode树\n  _renderRecursively(vnode: VNode, parent: HTMLElement) {\n    if (vnode.type === \"text\") {\n      // 文本节点\n      parent.appendChild(document.createTextNode(vnode.props.textContent));\n      return;\n    } else if (vnode.type === \"Component\") {\n      // 组件节点 TODO\n      return;\n    }\n    // 其他节点，创建HtmlElement\n    const element = document.createElement(vnode.type);\n    // 设置属性\n    for (const key in vnode.props) {\n      if (key === \"style\") {\n        // style\n        Object.assign(element.style, vnode.props[key]);\n      } else if (key.startsWith(\"on\")) {\n        // 事件\n        element.addEventListener(key.slice(2).toLowerCase(), vnode.props[key]);\n      } else {\n        // 其他\n        element.setAttribute(key, vnode.props[key]);\n      }\n    }\n    // 递归渲染children\n    for (const child of vnode.children) {\n      this._renderRecursively(child, element);\n    }\n    parent.appendChild(element);\n  }\n  ...\n}\n```\n\n`_renderRecursively`就是递归渲染VNode树。如果是文本虚拟dom，直接append；如果是组件，后面讲；否则作为原生dom元素：创建`element`，处理一下属性，然后递归处理children，再把处理完的自己加到dom树上。\n\n> 正版vue处理的属性不止`style`和`on事件`。这里简化了。\n\n#### 在React中试用\n\n到这里，我们手搓的简版vue对于渲染原生dom节点，并支持响应式、watcher、method等，已经没有任何问题！。赶紧试一下吧：\n\n创建一个React组件，引入vue，`import Vue from \"src/libs/vue\"`。加一个div，我们将vue组件渲染到这个div下。在`useEffect`hooks下，初始化vue实例，方便于React组件销毁时同时销毁Vue组件。\n\n```typescript\nimport React, { useEffect, useRef } from \"react\";\nimport Vue from \"../../libs/vue\";\n\nconst VueTest: React.FC = () => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    // App组件\n    const App = new Vue({\n      el: ref.current!, // 挂载到react的div元素上\n      data() {\n        return {\n          toggle: true,\n        };\n      },\n      methods: {\n        clickChange() {\n          this.toggle = !this.toggle;\n        },\n      },\n      watch: {\n        toggle: function (newVal, oldVal) {\n          console.log(`toggle: ${oldVal} -> ${newVal}`);\n        },\n      },\n      mounted() {\n        console.log(\"page mounted\");\n      },\n      render(h) {\n        return h(\"article\", {}, [\n          h(\"h3\", {}, [\"父组件-【App】\"]),\n          h(\"span\", {}, [`当前状态：${this.toggle ? \"开启\" : \"关闭\"}`]),\n          h(\"button\", { onClick: this.clickChange }, [\"切换\"]),\n        ]);\n      },\n    });\n    // react页面销毁时，销毁vue的App实例\n    return () => App.destroy();\n  });\n\n  return <div id=\"vue-app\" ref={ref}></div>;\n};\n\nexport default VueTest;\n```\n\n功能一切正常！\n\n![](../static/assets/base测试.jpg)\n\n#### 支持组件化\n\n要支持组件化，主要是两步：一是在提供的`h方法`里，我们要初始化子组件实例，传递props，调用子组件的`render函数`获取子组件的VNode，然后把子组件的VNode记录下来，注意要把它和原生元素区分开。二是在实际渲染时，如果有子组件，则递归渲染子组件，然后append到dom树上即可。\n\n**1. 创建子组件实例**\n\n在原来的`h方法`里，补充上子组件的实现。注意子组件需要缓存下来，不能每次new一个新的实例。同时为了区分它是个组件类型，创建了一个`type: \"Component\"`的虚拟dom。\n\n```typescript\nexport default class Vue {\n  ...\n  h(type: string, props: any, children: any[] = []): VNode {\n    let vnode: VNode;\n    if (this.components.hasOwnProperty(type)) {\n      // 如果是自定义组件\n      // 获取组件实例\n      let component = this._componentInstances[type];\n      if (!component) {\n        component = new Vue(this.components[type]);\n      }\n      this._componentInstances[type] = component;\n      // 更新proxy的props\n      for (const key in props) {\n        component.proxy[key] = props[key];\n      }\n      // 渲染组件到element\n      vnode = {\n        type: \"Component\",\n        props,\n        _component: component,\n        children: [component.render(component.h.bind(component))],\n      };\n    } else {\n      // 如果是原生标签\n      ...\n    }\n    return vnode;\n  }\n  ...\n}\n```\n\n**2. 子组件递归渲染**\n\n渲染真实dom时，如果有子组件，递归渲染子组件。*（需要告知子组件父级真实dom是什么，不然无法append上去）*\n```typescript\nexport default class Vue {\n  ...\n  // 递归渲染vnode树\n  _renderRecursively(vnode: VNode, parent: HTMLElement) {\n    if (vnode.type === \"text\") {\n      // 文本节点\n      ...\n    } else if (vnode.type === \"Component\") {\n      // 组件节点\n      if (vnode._component) {\n        vnode._component.el = parent;\n      }\n      // 本身不用append，从第一个child开始\n      this._renderRecursively(vnode.children[0], parent);\n      return;\n    }\n    // 其他节点，创建HtmlElement\n    ...\n  }\n  ...\n}\n```\n\n至此，Vue的组件化系统也支持完毕了。现在vue组件内可以声明子组件，渲染子组件。当然，子组件也可以继续包含子组件，形成任意级嵌套。属性也能通过props传递下去。最终的demo效果在开篇就已经展示了。\n\n### 源码\n\n完整的“Vue”的源码如下：\n\n```typescript\n// src/libs/vue.tsx\n/** Vue设置选项（同Vue2） */\nexport type VueOptions = {\n  el?: HTMLElement | null;\n  components?: Record<string, VueOptions>;\n  props?: string[];\n  data?: () => Record<string, any>;\n  watch?: Record<string, (newVal: any, oldVal: any) => void>;\n  methods?: Record<string, any>;\n  mounted?: () => void;\n  destroyed?: () => void;\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode;\n\n  [key: string]: any;\n};\n\n/** 虚拟node节点 */\nexport type VNode = {\n  type: string;\n  props: Record<string, any>;\n  children: VNode[];\n  _component?: Vue;\n};\n\n/** Vue对象 */\nexport default class Vue {\n  _options: VueOptions; // 选项\n  el?: HTMLElement | null; // 父级element元素\n  components: Record<string, VueOptions>; // 声明的组件\n  _componentInstances: Record<string, Vue>; // 使用到的组件实例\n  proxy: Record<string, any>; // 代理对象，用于访问this.data、this.methods、this.props\n  watchers: Record<string, (newVal: any, oldVal: any) => void>; // 监听器\n  mounted: () => void; // 挂载完成回调\n  destroyed: () => void; // 销毁回调\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode; // 渲染函数\n\n  constructor(options: VueOptions) {\n    this._options = options;\n    // el\n    this.el = options.el;\n    // components\n    this.components = options.components || {};\n    this._componentInstances = {};\n    // data\n    this.proxy = this._proxyThis(\n      options.data?.(),\n      options.methods,\n      options.props\n    );\n    // watch\n    this.watchers = options.watch || {};\n    // lifecycle\n    this.mounted = options.mounted || (() => {});\n    this.destroyed = options.destroyed || (() => {});\n\n    this.render = options.render.bind(this.proxy);\n\n    this._init();\n  }\n\n  _init() {\n    this.mounted();\n    // 首次渲染\n    this._doRender.call(this);\n  }\n\n  // 为当前Vue实例创建一个代理\n  _proxyThis(\n    data: Record<string, any> = {},\n    methods: Record<string, any> = {},\n    props: string[] = []\n  ) {\n    const that = this;\n    const obj = { ...data, ...methods };\n    for (const key of props) {\n      obj[key] = undefined;\n    }\n    const proxy = new Proxy(obj, {\n      get: (target, p: string, receiver) => {\n        const value = target[p];\n        if (typeof value === \"function\") {\n          // 为methods绑定proxy\n          return value.bind(proxy);\n        }\n        return value;\n      },\n      set: (target, p: string, newValue, receiver) => {\n        const oldValue = target[p];\n        target[p] = newValue;\n        // 触发watcher\n        if (p in that.watchers) {\n          that.watchers[p].call(proxy, newValue, oldValue);\n        }\n        // 重新渲染\n        that._doRender.call(that);\n        return true;\n      },\n    });\n    return proxy;\n  }\n\n  // 执行渲染（简化版本，没有加diff算法）\n  _doRender() {\n    if (this.el) {\n      const vnodeTree = this.render(this.h.bind(this));\n      // 清空el下所有元素\n      this.el.innerHTML = \"\";\n      // 重新渲染子树\n      this._renderRecursively(vnodeTree, this.el);\n    }\n  }\n\n  // 递归渲染vnode树\n  _renderRecursively(vnode: VNode, parent: HTMLElement) {\n    if (vnode.type === \"text\") {\n      // 文本节点\n      parent.appendChild(document.createTextNode(vnode.props.textContent));\n      return;\n    } else if (vnode.type === \"Component\") {\n      // 组件节点\n      if (vnode._component) {\n        vnode._component.el = parent;\n      }\n      // 本身不用append，从第一个child开始\n      this._renderRecursively(vnode.children[0], parent);\n      return;\n    }\n    // 其他节点，创建HtmlElement\n    const element = document.createElement(vnode.type);\n    // 设置属性\n    for (const key in vnode.props) {\n      if (key === \"style\") {\n        // style\n        Object.assign(element.style, vnode.props[key]);\n      } else if (key.startsWith(\"on\")) {\n        // 事件\n        element.addEventListener(key.slice(2).toLowerCase(), vnode.props[key]);\n      } else {\n        // 其他\n        element.setAttribute(key, vnode.props[key]);\n      }\n    }\n    // 递归渲染children\n    for (const child of vnode.children) {\n      this._renderRecursively(child, element);\n    }\n    parent.appendChild(element);\n  }\n\n  h(type: string, props: any, children: any[] = []): VNode {\n    let vnode: VNode;\n\n    if (this.components.hasOwnProperty(type)) {\n      // 如果是自定义组件\n      // 获取组件实例\n      let component = this._componentInstances[type];\n      if (!component) {\n        component = new Vue(this.components[type]);\n      }\n      this._componentInstances[type] = component;\n      // 更新proxy的props\n      for (const key in props) {\n        component.proxy[key] = props[key];\n      }\n      // 渲染组件到element\n      vnode = {\n        type: \"Component\",\n        props,\n        _component: component,\n        children: [component.render(component.h.bind(component))],\n      };\n    } else {\n      // 如果是原生标签\n      // 存储为VNode\n      vnode = { type, props, children };\n      // 添加children\n      vnode.children = [];\n      for (const child of children) {\n        if (typeof child === \"string\") {\n          vnode.children.push({\n            type: \"text\",\n            props: { textContent: child },\n            children: [],\n          });\n        } else {\n          vnode.children.push(child);\n        }\n      }\n    }\n\n    return vnode;\n  }\n\n  destroy() {\n    // 销毁子组件\n    for (const key in this._componentInstances) {\n      this._componentInstances[key].destroy();\n    }\n    // 销毁自己\n    this.destroyed();\n  }\n}\n```\n\n完整的react测试页面如下：\n```typescript\n// src/pages/vuetest/index.tsx\nimport React, { useEffect, useRef } from \"react\";\nimport Vue, { VueOptions } from \"../../libs/vue\";\n\n// 子组件\nconst Comp: VueOptions = {\n  props: [\"state\"],\n\n  data() {\n    return {\n      count: 0,\n    };\n  },\n\n  watch: {\n    count: function (newVal, oldVal) {\n      console.log(`count: ${oldVal} -> ${newVal}`);\n    },\n  },\n\n  methods: {\n    clickAdd() {\n      this.add();\n    },\n    add() {\n      this.count++;\n    },\n  },\n\n  mounted() {\n    console.log(\"comp mounted\");\n  },\n\n  destroyed() {\n    console.log(\"comp destroyed\");\n  },\n\n  render(h) {\n    return h(\"div\", { style: { background: \"antiquewhite\" } }, [\n      h(\"h3\", {}, [\"子组件-【Comp】\"]),\n      h(\"p\", {}, [`父组件状态：${this.state ? \"开启\" : \"关闭\"}`]),\n      h(\"button\", { onClick: this.clickAdd }, [\"count+1\"]),\n      h(\"span\", { \"aria-label\": \"计数\" }, [`count: ${this.count}`]),\n    ]);\n  },\n};\n\nconst VueTest: React.FC = () => {\n  const ref = useRef<HTMLDivElement>(null);\n\n  useEffect(() => {\n    // App组件\n    const App = new Vue({\n      el: ref.current!, // 挂载到react的div元素上\n      components: { Comp },\n      data() {\n        return {\n          toggle: true,\n        };\n      },\n\n      methods: {\n        clickChange() {\n          this.toggle = !this.toggle;\n        },\n      },\n\n      mounted() {\n        console.log(\"page mounted\");\n      },\n\n      destroyed() {\n        console.log(\"page destroyed\");\n      },\n\n      render(h) {\n        return h(\n          \"article\",\n          { style: { backgroundColor: \"aliceblue\", padding: \"10px\" } },\n          [\n            h(\"h3\", {}, [\"父组件-【App】\"]),\n            h(\"span\", {}, [`当前状态：${this.toggle ? \"开启\" : \"关闭\"}`]),\n            h(\"button\", { onClick: this.clickChange }, [\"切换\"]),\n            h(\"section\", {}, [h(\"Comp\", { state: this.toggle })]), // Comp子组件\n          ]\n        );\n      },\n    });\n    // react页面销毁时，销毁vue的App实例\n    return () => App.destroy();\n  });\n\n  return <div id=\"vue-app\" ref={ref}></div>;\n};\n\nexport default VueTest;\n```\n","slug":"/vue-demo"},{"id":"f6788ee2-1376-51e6-b997-cb3faa8932c1","title":"【造轮子】Vue双端diff算法","tags":["前端","Vue2","架构","造轮子"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAe9NAo//xAAVEAEBAAAAAAAAAAAAAAAAAAABIP/aAAgBAQABBQJr/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFBABAAAAAAAAAAAAAAAAAAAAIP/aAAgBAQAGPwJf/8QAGRAAAgMBAAAAAAAAAAAAAAAAAAEQMUEh/9oACAEBAAE/IUoafLjTY//aAAwDAQACAAMAAAAQAw//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAaEAEAAgMBAAAAAAAAAAAAAAABETEAECFR/9oACAEBAAE/EGWM8eximFH3TTGmv//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/c75c8/vue-diff.jpg","srcSet":"/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/4a515/vue-diff.jpg 172w,\n/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/818fc/vue-diff.jpg 344w,\n/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/c75c8/vue-diff.jpg 688w","sizes":"(min-width: 688px) 688px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/98980/vue-diff.avif 172w,\n/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/2a756/vue-diff.avif 344w,\n/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/44a4e/vue-diff.avif 688w","type":"image/avif","sizes":"(min-width: 688px) 688px, 100vw"},{"srcSet":"/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/24a77/vue-diff.webp 172w,\n/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/5f47c/vue-diff.webp 344w,\n/leon-blog/static/41f9f7e66245a805f0e2669c3ee51465/ee976/vue-diff.webp 688w","type":"image/webp","sizes":"(min-width: 688px) 688px, 100vw"}]},"width":688,"height":344},"body":"---\ntitle: \"【造轮子】Vue双端diff算法\"\ncover: ../static/assets/vue-diff.jpeg\ncoverAlt: \"封面\"\ndescription: \"结合之前手写的的Vue，加上diff算法实现差量更新dom\"\ndatePublished: \"2022-09-28 12:52:49\"\ndateModified: \"2022-09-28 12:52:49\"\nslug: \"vue-demo-diff\"\ncategory: \"经验总结\"\ntags:\n  - 前端\n  - Vue2\n  - 架构\n  - 造轮子\n---\n\n去年抽空花了半天时间，手敲了个[Vue的简易版](/vue-demo)，能够实现Vue的常规使用、响应式、虚拟dom、组件化等。但是布局渲染部分，是使用的虚拟dom转换为真实dom，然后全量插入到Vue的根节点。每次刷新都是全量，这个性能可见一斑。\n\n这次花点时间，在原来版本的基础上，尝试加上VNode的diff算法，然后在diff过程中差量更新真实dom树，实现一个真正能用的vue版本。\n\n> 声明！本次依然不是vue源码解析，是我自己基于vue的diff算法的理解，在原来的自制vue版本基础上加进去的。不代表官方实现！\n\n源码依然贴在最后面。\n\n#### 节点key\n\n在前面，我们实现了通过渲染函数生成虚拟dom树（VNode）。diff算法就是为了对比出新的Vnode树和旧的VNode树的差异：哪些VNode是新增的节点，哪些是要删除的节点，哪些是移动了位置的节点。对于新增的节点，我们要创建对应的真实dom；对于删除的节点，我们要删除对应的dom；对于移动位置的节点，我们可以复用原来的dom，只需要更新dom属性即可。\n\n在vue中，比对是根据节点的key和节点类型来判断的。如果key和类型一致，则视为同一节点；不一致则为不同节点。每个节点都有一个名为key的属性。如果未提供key，默认使用列表中的index。提供了key的话，比较起来会更高效。\n\n先加上创建key的函数：\n\n```typescript\n/**\n * 创建VNode的key\n * 默认key为type-idx\n * 如果提供了props.key，则为type-key\n */\nfunction _createKey(\n  type: string,\n  key: string | undefined,\n  idx: number = 0\n): string {\n  return key ? `${type}-${key}` : `${type}-${idx}`;\n}\n```\n\n然后改造一下`h函数`，让它在生成VNode的同时生成key。\n\n```typescript\n/** h函数帮助生成虚拟节点VNode */\nfunction h(type: string, props: any, children: (VNode | string | null)[] = []): VNode {\n  // 存储为VNode\n  let vnode: VNode = { type, props, children: [], key: _createKey(type, props.key) };\n  let nonNullChildren = children.filter((child) => child !== null);\n  // 添加children\n  for (let idx = 0; idx < nonNullChildren.length; idx++) {\n    const child = nonNullChildren[idx];\n    if (typeof child === \"string\") {\n      vnode.children.push({\n        type: \"text\",\n        props: { textContent: child },\n        children: [],\n        key: _createKey(\"text\", undefined, idx),\n      });\n    } else {\n      // 重新计算key\n      child.key = _createKey(child.type, child.props.key, idx);\n      vnode.children.push(child);\n    }\n  }\n\n  return vnode;\n}\n```\n\n> 这里没有考虑静态节点（不根据状态变化的节点）优化，所以节点如果不提供key的话，会跟它所处的index有关。那么只要发生中间元素的插入或删除，都会导致后面元素的key发生变化，匹配不上导致性能下降。\n\n#### 双端diff算法\n\n有了key之后，就可以根据key来判断新旧两组VNode，是如何变化的。vue采用了一种很高效的双端diff算法，即同时从新旧VNode数组的前后两端共4个指针，尝试相互匹配并向中间移动：即判断新前.key==旧前.key、新后.key==旧后.key、新前.key==旧后.key、新后.key==旧前.key，匹配到了则指针往中间移动一位。这四种匹配已经满足了大部分的列表变更情形：比如在列表中插入一个或多个元素，或者删除一个或多个元素。只要不是位置互换，这四种匹配都一定能匹配上。但是不保险，假如发生了位置很错乱的互换，那么这四种就可能匹配不到。所以还得有一个**backup方案**，就是直接在旧数组里面，查找key==新前.key的，如果查不到，那证明该元素是新增的，查到了则将旧数组这个位置的VNode置空，防止被再次匹配上。这种性能会差一些，但一般走不到。\n\n如果最后有一方指针走完了（新前指针大于新后指针或者旧前指针大于旧后指针），则代表新旧数组不可能再有匹配的了。如果这时候新数组还有剩余，那都是要新建的；如果旧数组还有剩余，那都是要删除的。\n\n在遍历过程中，要实时更新真实dom，比如创建、删除dom元素、或者只需要更新元素属性。有一些特殊情况，就是创建的要考虑dom元素插入的位置。比如旧前.key==新后.key，那就需要将旧前对应的dom移动到旧后对应的dom后面。同理如果某VNode.key==新前.key，那么需要将该节点的dom移动到旧前对应的dom前面（记住始终变动的是旧列表，所以位置都是以旧列表的指针来的）。\n\n完整的diff算法如下：\n\n```typescript\n/**\n * 遍历以及diff一组新旧VNode，同时对parent下的真实dom进行创建、更新、移动或删除。\n * 从而以最小的变动让真实dom和最新VNode树保持一致。\n */\n_renderDomWithDiff(oldChildren: VNode[], newChildren: VNode[], parent: HTMLElement) {\n  let oldStartIdx = 0;\n  let oldEndIdx = oldChildren.length - 1;\n  let newStartIdx = 0;\n  let newEndIdx = newChildren.length - 1;\n\n  while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n    // 旧节点可能已被匹配，被置空了，跳过\n    if (!oldChildren[oldStartIdx]) {\n      oldStartIdx++;\n    } else if (!oldChildren[oldEndIdx]) {\n      oldEndIdx--;\n    } else if (\n      oldChildren[oldStartIdx].key === newChildren[newStartIdx].key\n    ) {\n      // 旧开始节点和新开始节点key相同，无需移动dom\n      console.log(`【${this.name}】[${oldChildren[oldStartIdx].key}]匹配到节点`);\n      this._patch(oldChildren[oldStartIdx], newChildren[newStartIdx], parent);\n      oldStartIdx++;\n      newStartIdx++;\n    } else if (oldChildren[oldEndIdx].key === newChildren[newEndIdx].key) {\n      // 旧结束节点和新结束节点key相同，无需移动dom\n      console.log(`【${this.name}】[${oldChildren[oldEndIdx].key }]匹配到节点`);\n      this._patch(oldChildren[oldEndIdx], newChildren[newEndIdx], parent);\n      oldEndIdx--;\n      newEndIdx--;\n    } else if (oldChildren[oldStartIdx].key === newChildren[newEndIdx].key) {\n      // 旧开始节点和新结束节点key相同，需要移动到旧结束节点后面\n      console.log(`【${this.name}】[${oldChildren[oldStartIdx].key}]匹配到节点`);\n      const node = this._patch(\n        oldChildren[oldStartIdx],\n        newChildren[newEndIdx],\n        parent\n      );\n      parent.insertBefore(node, oldChildren[oldEndIdx]._domNode!.nextSibling);\n      oldStartIdx++;\n      newEndIdx--;\n    } else if (oldChildren[oldEndIdx].key === newChildren[newStartIdx].key) {\n      // 旧结束节点和新开始节点key相同，需要移动到旧开始节点前面\n      console.log(`【${this.name}】[${oldChildren[oldEndIdx].key}]匹配到节点`);\n      const node = this._patch(\n        oldChildren[oldEndIdx],\n        newChildren[newStartIdx],\n        parent\n      );\n      parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\n      oldEndIdx--;\n      newStartIdx++;\n    } else {\n      // 前面四种情况都不匹配，尝试从旧数组中匹配新开始节点\n      const idxInOld = oldChildren.findIndex(\n        (node) => node && node.key === newChildren[newStartIdx].key\n      );\n      if (idxInOld !== -1) {\n        // 找到了，需要移动到旧开始节点前面\n        console.log(`【${this.name}】[${newChildren[newStartIdx].key}]匹配到节点`);\n        const node = this._patch(\n          oldChildren[idxInOld],\n          newChildren[newStartIdx],\n          parent\n        );\n        parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\n        // 置空，防止反复鞭尸\n        // @ts-ignore\n        oldChildren[idxInOld] = undefined;\n      } else {\n        // 找不到，创建dom，插入到旧开始节点前面\n        console.log(`【${this.name}】[${newChildren[newStartIdx].key}]是新增节点`);\n        // 插入到oldStartIdx前面正好保证顺序\n        const node = this._patch(undefined, newChildren[newStartIdx], parent);\n        parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\n      }\n      newStartIdx++;\n    }\n  }\n\n  // 新节点比较完毕，旧节点还有剩余\n  if (oldStartIdx <= oldEndIdx) {\n    for (let i = oldStartIdx; i <= oldEndIdx; i++) {\n      if (!oldChildren[i]) continue;\n      // 删除掉对应的dom\n      console.log(`【${this.name}】[${oldChildren[i].key}]是删除节点`);\n      parent.removeChild(oldChildren[i]._domNode!);\n      // 如果是组件，需要销毁\n      if (this.components.hasOwnProperty(oldChildren[i].type)) {\n        this._unmountComponent(oldChildren[i].key);\n      }\n    }\n  } else if (newStartIdx <= newEndIdx) {\n    // 旧节点比较完毕，新节点还有剩余\n    for (let i = newStartIdx; i <= newEndIdx; i++) {\n      console.log(`【${this.name}】[${newChildren[i].key}]是新增节点`);\n      // 创建dom，插入到parent末尾\n      const node = this._patch(undefined, newChildren[i], parent);\n      parent.insertBefore(node, newChildren[newEndIdx + 1]?._domNode || null);\n    }\n  }\n}\n```\n\n这样，只需要告诉新旧两个VNode树，和它们的parent节点。调用该方法后，就能在parent节点下，差量更新它的children dom元素。\n\n#### _patch方法\n\n里面还有一个重要的方法，就是`_patch方法`。这个方法就是处理那些key相同的VNode，如果是text，则更新文本内容。如果是组件，则复用组件更新props。否则为dom，让它们更新属性。（额外的情况，如果旧VNode为空，则创建对应的dom）。\n\n同时需要在这里处理递归，调用`_renderDomWithDiff`函数。\n\n```typescript\n/**\n * 创建或更新真实dom节点。\n * 1. 如果有oldVNode：复用dom，只更新dom属性。\n * 2. 如果没有oldVNode：创建新的dom\n * 3. 递归处理children\n */\n_patch(oldVNode: VNode | undefined, vnode: VNode, parent: HTMLElement): Node {\n  // 1. 文本节点\n  if (vnode.type === \"text\") {\n    if (!oldVNode) {\n      // 没有则创建\n      const node = document.createTextNode(vnode.props.textContent);\n      vnode._domNode = node;\n    } else {\n      if (oldVNode.props.textContent !== vnode.props.textContent) {\n        oldVNode._domNode!.textContent = vnode.props.textContent;\n      }\n      vnode._domNode = oldVNode._domNode;\n    }\n    return vnode._domNode!;\n  }\n\n  // 2. 组件节点\n  if (this.components.hasOwnProperty(vnode.type)) {\n    if (!oldVNode) {\n      // 没有则创建\n      let component = this._componentInstances[vnode.key];\n      if (!component) {\n        component = new Vue(this.components[vnode.type]);\n        component._innerSetName(vnode.type);\n        this._componentInstances[vnode.key] = component;\n      }\n      // 更新proxy的props\n      for (const key in vnode.props) {\n        component.proxy[key] = vnode.props[key];\n      }\n      vnode._component = component;\n    } else {\n      // 否则只需更新\n      for (const key in vnode.props) {\n        oldVNode._component!.proxy[key] = vnode.props[key];\n      }\n      vnode._component = oldVNode._component;\n    }\n\n    vnode._component!.el = parent;\n    // 子组件去渲染自己的元素即可\n    vnode._component!._doRender();\n    vnode._domNode = vnode._component!._lastVNode!._domNode!;\n    return vnode._domNode;\n  }\n\n  // 3. 其他节点\n  if (!oldVNode) {\n    // 没有则创建\n    const element = document.createElement(vnode.type);\n    // 设置属性\n    _updateProps(element, vnode.props);\n    vnode._domNode = element;\n  } else {\n    // 否则只需更新\n    _updateProps(\n      oldVNode._domNode as HTMLElement,\n      vnode.props,\n      oldVNode.props\n    );\n    vnode._domNode = oldVNode._domNode;\n  }\n\n  // 递归处理children\n  this._renderDomWithDiff(\n    oldVNode?.children || [],\n    vnode.children,\n    vnode._domNode as HTMLElement\n  );\n\n  return vnode._domNode!;\n}\n```\n\n到这里通过双端diff算法差量更新真实dom的工作就全部做完了。现在我们需要将递归渲染函数，由原来的全量创建版本`_renderRecursively`改为现在写的差量更新版本`_renderDomWithDiff`。\n\n#### 区分App组件和子组件\n\n现在每个Vue组件都可以使用`_renderDomWithDiff`函数，来将自己下面的元素都绘制到`this.el`上了。但是子组件还好，它能始终保证它的`this.el`下面children都是由我们的渲染机制渲染出来的。而App组件就无法保证了，因为它挂载在一个根dom元素上，可能这个根dom元素上本来就有其他元素。这样我们差量更新可能会导致更新了错误的元素。所以我们要区分一下App根组件和其他组件。\n\n参考Vue3，它是通过`createApp`方法来创建一个App级别的Vue实例的。我们也一样：\n\n```typescript\n/** 创建一个根Vue组件 */\nexport function createApp(options: VueOptions) {\n  const vue = new Vue(options);\n  vue._isAppRoot = true;\n  vue._innerSetName(\"App\");\n  // @ts-ignore\n  window.__vue_app__ = vue;\n  return vue;\n}\n```\n\n然后我们在执行`_renderDomWithDiff`函数之前，如果首次渲染，需要清空元素。\n\n```typescript\n// 执行渲染\n_doRender() {\n  if (this.el) {\n    const vnodeTree = this.render(h.bind(this));\n    // 根组件首次渲染，清空el下所有元素，防止VNode和真实dom不一致\n    if (this._isAppRoot) {\n      // 首次渲染\n      if (!this._lastVNode) {\n        this.el.innerHTML = \"\";\n      }\n    }\n\n    // 使用diff算法重新渲染子树\n    this._renderDomWithDiff(\n      this._lastVNode ? [this._lastVNode] : [],\n      [vnodeTree],\n      this.el\n    );\n    // 记录下来\n    this._lastVNode = vnodeTree;\n  }\n}\n```\n\n#### 异步更新\n\n整个差量更新渲染流程已经ready。但是还有一个问题，现在是同步执行的渲染，初始化或者每次数据变更，都会导致一个`_doRender()`差量更新。虽然已经差量更新了，但也架不住可能出现的1秒更新100次吧...\n\n所以参考vue，我们加一下异步更新，即多次发起render，但是一段时间只会执行一次实际渲染。\n\n我们通过微任务+防抖实现，这样的话，同步代码触发的不管多少次，都会在同步代码执行结束后，只执行一次实际渲染。\n\n```typescript\n// 异步更新队列，在微任务结束后执行渲染\n_queueRender() {\n  // 防抖\n  if (!this._updateQueued) {\n    this._updateQueued = true;\n    Promise.resolve().then(() => {\n      this._doRender();\n      this._updateQueued = false;\n    });\n  }\n}\n```\n\n初始化和proxy状态变更触发，都调用`_queueRender`：\n\n```typescript\n  _init() {\n    this.mounted();\n    // 首次渲染\n    this._queueRender.call(this);\n  }\n\n  _proxyThis(data: Record<string, any> = {}, methods: Record<string, any> = {}, props: string[] = []) {\n    ...\n    const proxy = new Proxy(obj, {\n      ...\n      set: (target, p: string, newValue, receiver) => {\n        ...\n        // 重新渲染\n        that._queueRender.call(that);\n      ...\n      }\n    }\n    ...\n  }\n```\n\n#### 其他\n\n其他还有一些变动，诸如组件卸载逻辑、dom属性更新逻辑。都不是重点，不再介绍，简单看下源码即可。\n\n#### 源码\n\n加上了diff算法差量更新，以及异步更新后，最新的手搓简版vue代码如下：\n\n```typescript\n/** Vue设置选项（同Vue2） */\nexport type VueOptions = {\n  name?: string;\n  el?: HTMLElement | null;\n  components?: Record<string, VueOptions>;\n  props?: string[];\n  data?: () => Record<string, any>;\n  watch?: Record<string, (newVal: any, oldVal: any) => void>;\n  methods?: Record<string, any>;\n  mounted?: () => void;\n  destroyed?: () => void;\n  render: (\n    h: (tag: string, opts: any, children?: (VNode | string | null)[]) => VNode\n  ) => VNode;\n\n  [key: string]: any;\n};\n\n/** 虚拟node节点 */\nexport type VNode = {\n  key: string;\n  type: string;\n  props: Record<string, any>;\n  children: VNode[];\n  _component?: Vue;\n  _domNode?: Node | null;\n};\n\n/** 创建一个根Vue组件 */\nexport function createApp(options: VueOptions) {\n  const vue = new Vue(options);\n  vue._isAppRoot = true;\n  vue._innerSetName(\"App\");\n  // @ts-ignore\n  window.__vue_app__ = vue;\n  return vue;\n}\n\n/** Vue对象 */\nexport default class Vue {\n  name?: string;\n  _isAppRoot: boolean = false; // 是否是App根组件\n  _options: VueOptions; // 选项\n  el?: HTMLElement | null; // 父级element元素\n  components: Record<string, VueOptions>; // 声明的组件\n  _componentInstances: Record<string, Vue>; // 使用到的组件实例\n  proxy: Record<string, any>; // 代理对象，用于访问this.data、this.methods、this.props\n  watchers: Record<string, (newVal: any, oldVal: any) => void>; // 监听器\n  _lastVNode?: VNode; // 上一次渲染的vnode\n  mounted: () => void; // 挂载完成回调\n  destroyed: () => void; // 销毁回调\n  render: (h: (tag: string, opts: any, children?: any[]) => VNode) => VNode; // 渲染函数\n  _updateQueued: boolean = false; // 是否有更新任务\n\n  constructor(options: VueOptions) {\n    this._options = options;\n    // name\n    this.name = options.name;\n    // el\n    this.el = options.el;\n    // components\n    this.components = options.components || {};\n    this._componentInstances = {};\n    // data\n    this.proxy = this._proxyThis(\n      options.data?.(),\n      options.methods,\n      options.props\n    );\n    // watch\n    this.watchers = options.watch || {};\n    // lifecycle\n    this.mounted = options.mounted || (() => {});\n    this.destroyed = options.destroyed || (() => {});\n\n    this.render = options.render.bind(this.proxy);\n\n    this._init();\n  }\n\n  _init() {\n    this.mounted();\n    // 首次渲染\n    this._queueRender.call(this);\n  }\n\n  /** 设置组件name，如果已在options中设置，则忽略 */\n  _innerSetName(name: string) {\n    if (!this.name) this.name = name;\n  }\n\n  // 为当前Vue实例创建一个代理\n  _proxyThis(\n    data: Record<string, any> = {},\n    methods: Record<string, any> = {},\n    props: string[] = []\n  ) {\n    const that = this;\n    const obj = { ...data, ...methods };\n    for (const key of props) {\n      obj[key] = undefined;\n    }\n    const proxy = new Proxy(obj, {\n      get: (target, p: string, receiver) => {\n        const value = target[p];\n        if (typeof value === \"function\") {\n          // 为methods绑定proxy\n          return value.bind(proxy);\n        }\n        return value;\n      },\n      set: (target, p: string, newValue, receiver) => {\n        const oldValue = target[p];\n        target[p] = newValue;\n        // 触发watcher\n        if (p in that.watchers) {\n          that.watchers[p].call(proxy, newValue, oldValue);\n        }\n        // 重新渲染\n        that._queueRender.call(that);\n        return true;\n      },\n    });\n    return proxy;\n  }\n\n  // 异步更新队列，在微任务结束后执行渲染\n  _queueRender() {\n    // 防抖\n    if (!this._updateQueued) {\n      this._updateQueued = true;\n      Promise.resolve().then(() => {\n        this._doRender();\n        this._updateQueued = false;\n      });\n    }\n  }\n\n  // 执行渲染\n  _doRender() {\n    if (this.el) {\n      const vnodeTree = this.render(h.bind(this));\n      // 根组件首次渲染，清空el下所有元素，防止VNode和真实dom不一致\n      if (this._isAppRoot) {\n        // 首次渲染\n        if (!this._lastVNode) {\n          this.el.innerHTML = \"\";\n        }\n      }\n\n      // 使用diff算法重新渲染子树\n      this._renderDomWithDiff(\n        this._lastVNode ? [this._lastVNode] : [],\n        [vnodeTree],\n        this.el\n      );\n      // 记录下来\n      this._lastVNode = vnodeTree;\n    }\n  }\n\n  destroy() {\n    // 销毁子组件\n    this._unmountComponents();\n    // 销毁自己\n    this.destroyed();\n  }\n\n  /** 销毁特定的子组件实例 */\n  _unmountComponent(key: string) {\n    if (this._componentInstances.hasOwnProperty(key)) {\n      this._componentInstances[key].destroy();\n      delete this._componentInstances[key];\n    }\n  }\n\n  /** 未销毁的子组件实例全部销毁 */\n  _unmountComponents() {\n    for (const key in this._componentInstances) {\n      this._componentInstances[key].destroy();\n    }\n    this._componentInstances = {};\n  }\n\n  /**\n   * 遍历以及diff一组新旧VNode，同时对parent下的真实dom进行创建、更新、移动或删除。\n   * 从而以最小的变动让真实dom和最新VNode树保持一致。\n   *\n   * 原理：\n   * 使用双端diff算法，新旧前后共4个指针从两端向中间移动并尝试相互匹配。\n   * 匹配到key相同的VNode，复用dom，调用patch更新属性，然后移动或保持dom位置（根据指针）；\n   * 未匹配到key相同的VNode，创建dom并插入到parent某个位置下（根据指针）；\n   * 最后，如果旧的VNode有多余，删除parent下对应的dom。\n   *\n   * @param oldChildren 旧children\n   * @param newChildren 新children\n   * @param parent 父级dom元素\n   */\n  _renderDomWithDiff(\n    oldChildren: VNode[],\n    newChildren: VNode[],\n    parent: HTMLElement\n  ) {\n    let oldStartIdx = 0;\n    let oldEndIdx = oldChildren.length - 1;\n    let newStartIdx = 0;\n    let newEndIdx = newChildren.length - 1;\n\n    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {\n      // 旧节点可能已被匹配，被置空了，跳过\n      if (!oldChildren[oldStartIdx]) {\n        oldStartIdx++;\n      } else if (!oldChildren[oldEndIdx]) {\n        oldEndIdx--;\n      } else if (\n        oldChildren[oldStartIdx].key === newChildren[newStartIdx].key\n      ) {\n        // 旧开始节点和新开始节点key相同，无需移动dom\n        console.log(\n          `【${this.name}】[${oldChildren[oldStartIdx].key}]匹配到节点`\n        );\n        this._patch(oldChildren[oldStartIdx], newChildren[newStartIdx], parent);\n        oldStartIdx++;\n        newStartIdx++;\n      } else if (oldChildren[oldEndIdx].key === newChildren[newEndIdx].key) {\n        // 旧结束节点和新结束节点key相同，无需移动dom\n        console.log(\n          `【${this.name}】[${oldChildren[oldEndIdx].key}]匹配到节点`\n        );\n        this._patch(oldChildren[oldEndIdx], newChildren[newEndIdx], parent);\n        oldEndIdx--;\n        newEndIdx--;\n      } else if (oldChildren[oldStartIdx].key === newChildren[newEndIdx].key) {\n        // 旧开始节点和新结束节点key相同，需要移动到旧结束节点后面\n        console.log(\n          `【${this.name}】[${oldChildren[oldStartIdx].key}]匹配到节点`\n        );\n        const node = this._patch(\n          oldChildren[oldStartIdx],\n          newChildren[newEndIdx],\n          parent\n        );\n        parent.insertBefore(node, oldChildren[oldEndIdx]._domNode!.nextSibling);\n        oldStartIdx++;\n        newEndIdx--;\n      } else if (oldChildren[oldEndIdx].key === newChildren[newStartIdx].key) {\n        // 旧结束节点和新开始节点key相同，需要移动到旧开始节点前面\n        console.log(\n          `【${this.name}】[${oldChildren[oldEndIdx].key}]匹配到节点`\n        );\n        const node = this._patch(\n          oldChildren[oldEndIdx],\n          newChildren[newStartIdx],\n          parent\n        );\n        parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\n        oldEndIdx--;\n        newStartIdx++;\n      } else {\n        // 前面四种情况都不匹配，尝试从旧数组中匹配新开始节点\n        const idxInOld = oldChildren.findIndex(\n          (node) => node && node.key === newChildren[newStartIdx].key\n        );\n        if (idxInOld !== -1) {\n          // 找到了，需要移动到旧开始节点前面\n          console.log(\n            `【${this.name}】[${newChildren[newStartIdx].key}]匹配到节点`\n          );\n          const node = this._patch(\n            oldChildren[idxInOld],\n            newChildren[newStartIdx],\n            parent\n          );\n          parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\n          // 置空，防止反复鞭尸\n          // @ts-ignore\n          oldChildren[idxInOld] = undefined;\n        } else {\n          // 找不到，创建dom，插入到旧开始节点前面\n          console.log(\n            `【${this.name}】[${newChildren[newStartIdx].key}]是新增节点`\n          );\n          // 插入到oldStartIdx前面正好保证顺序\n          const node = this._patch(undefined, newChildren[newStartIdx], parent);\n          parent.insertBefore(node, oldChildren[oldStartIdx]._domNode!);\n        }\n        newStartIdx++;\n      }\n    }\n\n    // 新节点比较完毕，旧节点还有剩余\n    if (oldStartIdx <= oldEndIdx) {\n      for (let i = oldStartIdx; i <= oldEndIdx; i++) {\n        if (!oldChildren[i]) continue;\n        // 删除掉对应的dom\n        console.log(`【${this.name}】[${oldChildren[i].key}]是删除节点`);\n        parent.removeChild(oldChildren[i]._domNode!);\n        // 如果是组件，需要销毁\n        if (this.components.hasOwnProperty(oldChildren[i].type)) {\n          this._unmountComponent(oldChildren[i].key);\n        }\n      }\n    } else if (newStartIdx <= newEndIdx) {\n      // 旧节点比较完毕，新节点还有剩余\n      for (let i = newStartIdx; i <= newEndIdx; i++) {\n        console.log(`【${this.name}】[${newChildren[i].key}]是新增节点`);\n        // 创建dom，插入到parent末尾\n        const node = this._patch(undefined, newChildren[i], parent);\n        parent.insertBefore(node, newChildren[newEndIdx + 1]?._domNode || null);\n      }\n    }\n  }\n\n  /**\n   * 创建或更新真实dom节点。\n   *\n   * 1. 如果有oldVNode：复用dom，只更新dom属性。\n   * 2. 如果没有oldVNode：创建新的dom\n   * 3. 递归处理children\n   * @param oldVNode 旧的vnode\n   * @param vnode 新的vnode\n   * @param parent 父级dom元素\n   * @returns 真实dom节点\n   */\n  _patch(oldVNode: VNode | undefined, vnode: VNode, parent: HTMLElement): Node {\n    // 1. 文本节点\n    if (vnode.type === \"text\") {\n      if (!oldVNode) {\n        // 没有则创建\n        const node = document.createTextNode(vnode.props.textContent);\n        vnode._domNode = node;\n      } else {\n        if (oldVNode.props.textContent !== vnode.props.textContent) {\n          oldVNode._domNode!.textContent = vnode.props.textContent;\n        }\n        vnode._domNode = oldVNode._domNode;\n      }\n      return vnode._domNode!;\n    }\n\n    // 2. 组件节点\n    if (this.components.hasOwnProperty(vnode.type)) {\n      if (!oldVNode) {\n        // 没有则创建\n        let component = this._componentInstances[vnode.key];\n        if (!component) {\n          component = new Vue(this.components[vnode.type]);\n          component._innerSetName(vnode.type);\n          this._componentInstances[vnode.key] = component;\n        }\n        // 更新proxy的props\n        for (const key in vnode.props) {\n          component.proxy[key] = vnode.props[key];\n        }\n        vnode._component = component;\n      } else {\n        // 否则只需更新\n        for (const key in vnode.props) {\n          oldVNode._component!.proxy[key] = vnode.props[key];\n        }\n        vnode._component = oldVNode._component;\n      }\n\n      vnode._component!.el = parent;\n      // 子组件去渲染自己的元素即可\n      vnode._component!._doRender();\n      vnode._domNode = vnode._component!._lastVNode!._domNode!;\n      return vnode._domNode;\n    }\n\n    // 3. 其他节点\n    if (!oldVNode) {\n      // 没有则创建\n      const element = document.createElement(vnode.type);\n      // 设置属性\n      _updateProps(element, vnode.props);\n      vnode._domNode = element;\n    } else {\n      // 否则只需更新\n      _updateProps(\n        oldVNode._domNode as HTMLElement,\n        vnode.props,\n        oldVNode.props\n      );\n      vnode._domNode = oldVNode._domNode;\n    }\n\n    // 递归处理children\n    this._renderDomWithDiff(\n      oldVNode?.children || [],\n      vnode.children,\n      vnode._domNode as HTMLElement\n    );\n\n    return vnode._domNode!;\n  }\n}\n\n/** 差量更新dom节点的属性 */\nfunction _updateProps(\n  element: HTMLElement,\n  props: Record<string, any>,\n  oldProps?: Record<string, any>\n) {\n  for (const key in props) {\n    if (key === \"style\") {\n      // style\n      if (oldProps && oldProps[\"style\"]) {\n        // 清空旧的style\n        for (const styleKey in oldProps[\"style\"]) {\n          // @ts-ignore\n          element.style[styleKey] = \"\";\n        }\n      }\n      Object.assign(element.style, props[key]);\n    } else if (key.startsWith(\"on\")) {\n      // 事件\n      if (oldProps && oldProps[key]) {\n        // 移除旧的事件\n        element.removeEventListener(key.slice(2).toLowerCase(), oldProps[key]);\n      }\n      element.addEventListener(key.slice(2).toLowerCase(), props[key]);\n    } else {\n      // 其他\n      if (oldProps && oldProps[key]) {\n        // 移除旧属性\n        element.removeAttribute(key);\n      }\n      element.setAttribute(key, props[key]);\n    }\n  }\n}\n\n/** h函数帮助生成虚拟节点VNode */\nfunction h(\n  type: string,\n  props: any,\n  children: (VNode | string | null)[] = []\n): VNode {\n  // 存储为VNode\n  let vnode: VNode = {\n    type,\n    props,\n    children: [],\n    key: _createKey(type, props.key),\n  };\n  let nonNullChildren = children.filter((child) => child !== null);\n  // 添加children\n  for (let idx = 0; idx < nonNullChildren.length; idx++) {\n    const child = nonNullChildren[idx];\n    if (typeof child === \"string\") {\n      vnode.children.push({\n        type: \"text\",\n        props: { textContent: child },\n        children: [],\n        key: _createKey(\"text\", undefined, idx),\n      });\n    } else {\n      // 重新计算key\n      child.key = _createKey(child.type, child.props.key, idx);\n      vnode.children.push(child);\n    }\n  }\n\n  return vnode;\n}\n\n/**\n * 创建VNode的key\n * 默认key为type-idx\n * 如果提供了props.key，则为type-key\n */\nfunction _createKey(\n  type: string,\n  key: string | undefined,\n  idx: number = 0\n): string {\n  return key ? `${type}-${key}` : `${type}-${idx}`;\n}\n```","slug":"/vue-demo-diff"},{"id":"6e9ccd41-5db8-514a-b5a9-19175d877b1b","title":"vue-i18n-converter","tags":["前端","Node.js","脚本","开源"],"category":"框架工具","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAQBAgX/xAAWAQEBAQAAAAAAAAAAAAAAAAABAgP/2gAMAwEAAhADEAAAAXLpQY6IkS//xAAZEAADAQEBAAAAAAAAAAAAAAAAAQIREwP/2gAIAQEAAQUCm1nSUdZZrzzGf//EABURAQEAAAAAAAAAAAAAAAAAAAAR/9oACAEDAQE/AVf/xAAXEQADAQAAAAAAAAAAAAAAAAAAARIR/9oACAECAQE/AaeFH//EABwQAAEDBQAAAAAAAAAAAAAAAAABETEQIkFxof/aAAgBAQAGPwK530ZUjhNf/8QAGhAAAwEAAwAAAAAAAAAAAAAAAAERMSGBof/aAAgBAQABPyF/AFXhBLW+wqeQzGd1n//aAAwDAQACAAMAAAAQj+//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREh/9oACAEDAQE/EEspZ//EABcRAAMBAAAAAAAAAAAAAAAAAAABEVH/2gAIAQIBAT8QVDws/8QAHRABAAICAgMAAAAAAAAAAAAAAQARIUFRoTGRwf/aAAgBAQABPxAzbeLO4qXbwY9wdm1kSzqfcE5jnLnzBuvZP//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/5a367293a900128d4f2e18e558abee15/fff17/default_img6.jpg","srcSet":"/leon-blog/static/5a367293a900128d4f2e18e558abee15/9fa5a/default_img6.jpg 184w,\n/leon-blog/static/5a367293a900128d4f2e18e558abee15/63e75/default_img6.jpg 368w,\n/leon-blog/static/5a367293a900128d4f2e18e558abee15/fff17/default_img6.jpg 736w,\n/leon-blog/static/5a367293a900128d4f2e18e558abee15/da7d9/default_img6.jpg 1472w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/5a367293a900128d4f2e18e558abee15/9d028/default_img6.avif 184w,\n/leon-blog/static/5a367293a900128d4f2e18e558abee15/c6ee4/default_img6.avif 368w,\n/leon-blog/static/5a367293a900128d4f2e18e558abee15/b4627/default_img6.avif 736w,\n/leon-blog/static/5a367293a900128d4f2e18e558abee15/42b07/default_img6.avif 1472w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/5a367293a900128d4f2e18e558abee15/ef27d/default_img6.webp 184w,\n/leon-blog/static/5a367293a900128d4f2e18e558abee15/4ae45/default_img6.webp 368w,\n/leon-blog/static/5a367293a900128d4f2e18e558abee15/20e6b/default_img6.webp 736w,\n/leon-blog/static/5a367293a900128d4f2e18e558abee15/79f02/default_img6.webp 1472w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"vue-i18n-converter\"\ncover: images/default_img6.jpg\ncoverAlt: \"封面\"\ndescription: \"将vue2项目源码中，提取中文替换为i18n配置，提升国际化效率\"\ndatePublished: \"2022-03-25 16:30:20\"\ndateModified: \"2022-03-25 16:30:20\"\ncategory: \"框架工具\"\ntags:\n  - 前端\n  - Node.js\n  - 脚本\n  - 开源\n---\n\n**vue-i18n-converter**是一个脚本工具。用于vue2项目中，提取项目中的中文转为i18n的配置，并生成i18n配置文件。\n\nGitee仓库：https://gitee.com/missmess/vue-i18n-converter-script\n\n---\n\n### 导航\n\n- [使用方法](#使用方法)\n- [已实现功能](#已实现功能)\n- [其他场景](#其他场景)\n\n### 使用方法\n```shell\nnode index.js (文件或目录路径) [-js]\n```\n\n#### 参数说明\n\n参数1（必填参数）:\n\nvue文件地址或目录地址，如果传目录地址则递归处理该目录下的所有vue文件\n\n参数2 `-js`（可选参数）:\n\n如果传入`-js`，才会去处理vue文件中的script块。默认不传入则不处理script块\n\n#### 示例:\n```shell\nnode index.js /Users/missmess/FEProjects/lilishop-ui/buyer/src/ -js\n```\n\n脚本执行成功后，将在output目录下，会生成作为参数传入的，并且已经转换好的vue文件或同样结构的目录。同时生成cn.json的语言配置文件。\n\n可以将转换后的文件或目录覆盖源文件或目录，然后自己复制多套语言配置文件，自行翻译，并放入到项目中使用。\n\n> **注意：需要自己安装[vue-i18n](https://kazupon.github.io/vue-i18n/zh/introduction.html)，并在main.js中配置i18n。**\n\n---\n\n### 已实现功能\n1. 处理template块中组件属性中的连续中文：\n  ```html\n  <!-- CouponCenter.vue -->\n  <!-- 转换前 -->\n  <Input search style=\"width:400px\" @on-search='search' enter-button=\"搜索\" placeholder=\"搜索优惠券\" />\n  <!-- 转换后 -->\n  <Input search style=\"width:400px\" @on-search='search' :enter-button=\"$t('CouponCenter.搜索')\" :placeholder=\"$t('CouponCenter.搜索优惠券')\" />\n  ```\n  对应的i18n配置文件的key（下同）\n  ```json\n  {\n    \"CouponCenter\": {\n      \"搜索\": \"搜索\",\n      \"搜索优惠券\": \"搜索优惠券\",\n    }\n  }\n  ```\n\n2. 处理template块中的非属性中的连续中文\n  ```html\n  <!-- CouponCenter.vue -->\n  <!-- 转换前 -->\n  <p>使用范围</p>\n  <p>有效期：{{item.endTime}}</p>\n  <!-- 转换后 -->\n  <p>{{ $t(\"CouponCenter.使用范围\") }}</p>\n  <p>{{ $t(\"CouponCenter.有效期\") }}：{{item.endTime}}</p>\n  ```\n\n3. 处理script块中字符串中文段落\n  仅当执行脚本时，传入`-js`参数才生效\n  ```javascript\n  /* Cart.vue */\n  // 转换前\n  this.$Message.success(\"领取成功\");\n  // 转换后\n  this.$Message.success(this.$t(\"Cart.领取成功\"));\n  ```\n\n  > **谨慎使用:**\n  > 本脚本在处理script块中的中文时，会将中文字符串替换为this.$t(\"\")的函数。此时需要特别注意this的指向问题，如果this并不指向vue组件实例，则执行时会抛异常。请自行检查。\n\n---\n\n### 其他场景\n\n一些国际化场景本脚本暂未支持，请自行处理：\n1. 只处理vue文件中的中文配置，非vue文件将保持原样。\n\n2. template块中的非连续中文支持不友好，比如：\n  ```html\n  <!-- 转换前 -->\n  <span>满{{ item.consumeThreshold }}元可用</span>\n  <!-- 转换后：被拆为\"满\"和\"元可用\"两部分 -->\n  <span>{{ $t(\"Cart.满\") }}{{ item.consumeThreshold }}{{ $t(\"Cart.元可用\") }}</span>\n  ```\n  这是由于脚本无法正确处理动态的拼接中文，同时无法分析语义。\n\n3. script块中的动态拼接中文或html文本，比如：\n  ```javascript\n  // html文本 转换前\n  this.$Modal.confirm({ title: \"删除\", content: \"<p>确定要删除该商品吗？</p>\" });\n  // html文本 转换后\n  this.$Modal.confirm({ title: this.$t(\"Cart.删除\"), content: \"<p>确定要删除该商品吗？</p>\" });\n\n  // 动态文本 转换前\n  this.$Message.success(`清空购物车${res}个`);\n  // 动态文本 转换后\n  this.$Message.success(`清空购物车${res}个`);\n  ```\n\n4. style块中的中文暂不支持\n\n","slug":"/vue-i-18-n-converter"},{"id":"49310976-20c0-5fac-9ea0-8c99db934f74","title":"渲染流程：Vue vs React","tags":["前端","架构","Vue2","React"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAALABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQT/xAAVAQEBAAAAAAAAAAAAAAAAAAABBP/aAAwDAQACEAMQAAABjHOdmUYaP//EABoQAAICAwAAAAAAAAAAAAAAAAECABEDECL/2gAIAQEAAQUCBmTtmWje/wD/xAAYEQACAwAAAAAAAAAAAAAAAAACAxARIf/aAAgBAwEBPwFYbcf/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAgEBPwFX/8QAGBAAAgMAAAAAAAAAAAAAAAAAAAERICH/2gAIAQEABj8CEpyv/8QAGRAAAwEBAQAAAAAAAAAAAAAAAAERIRBR/9oACAEBAAE/IcLSIuPBDUtKnf/aAAwDAQACAAMAAAAQgw//xAAXEQADAQAAAAAAAAAAAAAAAAABEBFR/9oACAEDAQE/EBVhf//EABYRAQEBAAAAAAAAAAAAAAAAAAEREP/aAAgBAgEBPxAI3H//xAAbEAEAAgMBAQAAAAAAAAAAAAABESEAQYEQMf/aAAgBAQABPxDSI+JuctaBm1PcV+A04ombCDnv/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/4710f/vuevsreact.jpg","srcSet":"/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/002be/vuevsreact.jpg 165w,\n/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/b4f54/vuevsreact.jpg 330w,\n/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/4710f/vuevsreact.jpg 659w,\n/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/eeb57/vuevsreact.jpg 1318w","sizes":"(min-width: 659px) 659px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/79731/vuevsreact.avif 165w,\n/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/6ae0f/vuevsreact.avif 330w,\n/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/b9b98/vuevsreact.avif 659w,\n/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/4ddb9/vuevsreact.avif 1318w","type":"image/avif","sizes":"(min-width: 659px) 659px, 100vw"},{"srcSet":"/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/55a9a/vuevsreact.webp 165w,\n/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/39687/vuevsreact.webp 330w,\n/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/62d22/vuevsreact.webp 659w,\n/leon-blog/static/569bdc688231d02bc094191ee14f8ee4/6c1b1/vuevsreact.webp 1318w","type":"image/webp","sizes":"(min-width: 659px) 659px, 100vw"}]},"width":659,"height":368},"body":"---\ntitle: 渲染流程：Vue vs React\ndescription: 对比Vue2和React15渲染流程中的原理和差异\ndatePublished: 2023-01-04T08:05:58.604Z\ndateModified: 2023-01-04T08:05:58.610Z\ncover: ../static/assets/vuevsreact.jpeg\ncoverAlt: cover\nslug: vue-react-render\ncategory: 经验总结\ntags:\n  - 前端\n  - 架构\n  - Vue2\n  - React\n---\n\n本文主要从渲染流程中对比Vue和React的原理和结构差异。其中Vue使用的是Vue2，React是React15。\n\n## 架构\n\n### Vue\n\nVue中，每个组件都有一个Vue实例。渲染、挂载、卸载、子组件管理、响应式都在这个实例内进行。所有功能以实例为载体实现。\n\n每个Vue实例内，通过render函数，得到VNode树并存储下来。在实例的渲染过程中，通过深度优先遍历+双端diff算法对比新旧VNode树，并patch相应的dom变更。对于子组件，要么实例化新的，要么从组件缓存中获取。子组件的渲染交给子组件自己去执行。从而实现整个组件树的渲染。\n\n### React\n\nReact中，渲染分为Reconciler（协调）和Renderer（渲染）。16.8版本之前使用的是[Stack Reconciler](https://zh-hans.legacy.reactjs.org/docs/implementation-notes.html)。包含框架从`ReactDom.render`入口开始，深度遍历渲染整个组件树。React在渲染过程中，会将每个jsx节点都对应创建一个内部实例，包含**组合组件**（CompositeComponent）和**宿主组件**（HostComponent）两种类型。组合组件与`<App />`这样的React组件节点对应。宿主组件与`<div />`这样的原生节点对应。内部实例里包含了每个节点需要的上下文信息。\n\n> 它的工作机制类似于函数调用栈，所以称为Stack Reconciler。包括mount、unmount、更新等，都是递归调用+深度优先。\n\n**宿主组件**mount时，根据当前的jsx虚拟节点（element）。创建或更新对应的原生节点（node）。然后遍历children并挨个创建内部实例，得到子内部实例列表（renderedChildren）。再调用`renderedChildren.forEach.mount()`往深层执行。mount函数执行过程中，存储element、node和renderedChildren。函数最后return node。\n\n**组合组件**mount时，根据当前的jsx虚拟节点（element）。如果是class组件则实例化，执行生命周期，执行render函数。如果是函数组件则无需实例化（本身即render函数）。执行render后得到组件根jsx节点，对应创建内部实例（renderedComponent）。组合组件无需遍历children，因为永远只有一个根节点。函数执行过程中存储element、renderedComponent。函数最后返回值为`return renderedComponent.mount()`，即继续执行子内部实例的mount函数，并取其返回值。这么看来，它最终返回的是离它深度最小的子宿主组件的node。执行过程中通知renderer挂载dom。\n\n### 数据结构对比\n\n现有如下的一个模版：\n```html\n<App>\n    <h1>App标题</h1>\n    <Detail />\n</App>\n\n// App组件：\n\n<div>{children}</div>\n\n// Detail组件：\n<button />\n```\n\n在Vue里的存储结构为：\n\n![Vue实例结构](assets/vue-render-struct.jpg \"Vue render struct\")\n\n图中每个实线框都是一个VNode，每个Vue组件对应一个Vue实例。\n\n在vue中，父级实例包含子级实例：App实例包含一个div根级VNode，div下包含一个h1和一个Detail的VNode，其中Detail虚拟节点对应了Detail实例，Detail实例下又包含了一个button的VNode。\n\n同样的模版，在React里的存储结构为：\n\n![React实例结构](assets/react-render-sturct.jpg \"React render struct\")\n\n图中每个圆角框都是一个内部实例。组合组件总是有一个且只有一个renderedComponent，指向另一个内部实例。宿主组件的renderedChildren可能包含多个，指向其他的内部实例。此外，宿主组件会return dom节点元素。而组合组件会return第一个宿主组件的return值。\n\n## Diff更新\n\n### Vue\n\nVue使用深度优先，对每个实例下的VNode tree进行递归渲染，同一级的VNode trees使用双端diff算法进行最小化的差异对比，并同步操作真实dom树。\n\n双端diff算法，使用四个指针，通过对新旧VNode数组的头头、尾尾、头尾、尾头的俩俩对比，匹配节点。这四种对比能覆盖80%以上的列表变更的场景。如果这四种都不满足，那会直接在旧数组中查找，如果还未查找到，则说明是新增节点。四指针遍历结束后，如果新数组还有剩余，则说明旧数组中找不到，要添加dom。如果旧数组还有剩余，则说明新数组中找不到，要删除dom。\n\n### React\n\nReact在首次挂载完后，便通过内部实例之间的相互引用，得到了一个内部实例的树。渲染更新时，由根内部实例，深度递归遍历，调用实例的receive方法。receive方法接收一个可以复用的新jsx节点（element），即key和type都相同。\n\n在组合组件的receive方法中，如果是class组件，更新props，执行生命周期，并调用render方法；如果是函数组件，执行函数。得到子jsx虚拟节点。与旧的虚拟节点对比，如果key和type都一样，则可以复用子内部实例，调用子内部实例的receive方法，形成递归。如果不可复用，则重新创建子内部实例。并unmount旧的子内部实例，mount新的子内部实例。同时通知renderer卸载dom。\n\n在宿主组件的receive方法中，首先更新props为新的element的props。接着开始遍历处理props.children。对比旧的子内部实例数组（prevRenderedChildren）和新的数组（nextRenderedChildren）。数组遍历中，找到可以复用的，也是直接调用该子内部实例的receive方法，往下递归，如果存在位置移动，添加一个“MOVE”操作到操作队列（operationQueue）里。如果找不到，则需要新增，添加一个“ADD”操作到操作队列里。如果旧数组存在而新数组不存在，则需要删除，添加一个“REMOVE”操作到操作队列里。最终遍历操作队列，通知renderer更新dom。\n\n总结下来就是，组合组件每次渲染更新都执行render函数，并对比renderedComponent是否可以复用。宿主组件每次渲染更新，都更新props，对比props.children考虑renderedChildren中哪些可以复用。复用的则向下递归调用receive方法。不复用的则调用renderer更新dom。\n\n## 简单版源码\n\n本文的结构分析是基于我造轮子的[Vuelon](https://github.com/missmess/leon-build-wheel/tree/main/packages/vuelon)和[Reacteon](https://github.com/missmess/leon-build-wheel/tree/main/packages/reacteon)。\n\n有兴趣的可以同时从npm包下载，直接在[npmjs.com](https://npmjs.com)搜索包即可：Vuelon和Reacteon。\n","slug":"/vue-react-render"},{"id":"cd4a61e9-70fe-52d9-bbc1-3de10a8e0ec8","title":"程序员Leon","tags":["前端","React","Node.js","Gatsby","graphQL","PWA"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAQAEBf/EABQBAQAAAAAAAAAAAAAAAAAAAAL/2gAMAwEAAhADEAAAAeqIVqmR/8QAGhABAQACAwAAAAAAAAAAAAAAAQMAAhATMf/aAAgBAQABBQKlEbW68PN8oDx//8QAFxEBAQEBAAAAAAAAAAAAAAAAARECEP/aAAgBAwEBPwHBWPP/xAAVEQEBAAAAAAAAAAAAAAAAAAABEP/aAAgBAgEBPwFn/8QAGhAAAgIDAAAAAAAAAAAAAAAAAREAEBJRgf/aAAgBAQAGPwIYrsCVh6r/xAAaEAEBAQADAQAAAAAAAAAAAAABEQAhMUFh/9oACAEBAAE/IY6+sTgK+OVD1cRCni7iIZRcdb//2gAMAwEAAgADAAAAEDcP/8QAFREBAQAAAAAAAAAAAAAAAAAAARD/2gAIAQMBAT8QA4f/xAAWEQEBAQAAAAAAAAAAAAAAAAABEBH/2gAIAQIBAT8Q2CjP/8QAHBABAQACAgMAAAAAAAAAAAAAAREAITFhQVFx/9oACAEBAAE/EDxIsKb1Jm80Ko11oJy5plgMfGRMYSnD7wTZSCx1s7zg+Z//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/88c99/wang_blog.jpg","srcSet":"/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/38847/wang_blog.jpg 185w,\n/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/a0d87/wang_blog.jpg 370w,\n/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/88c99/wang_blog.jpg 740w","sizes":"(min-width: 740px) 740px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/e48a9/wang_blog.avif 185w,\n/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/707b2/wang_blog.avif 370w,\n/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/a0829/wang_blog.avif 740w","type":"image/avif","sizes":"(min-width: 740px) 740px, 100vw"},{"srcSet":"/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/3edfa/wang_blog.webp 185w,\n/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/790c9/wang_blog.webp 370w,\n/leon-blog/static/5d0fd1c2d2d66c90f1bbd50907707e28/d1c74/wang_blog.webp 740w","type":"image/webp","sizes":"(min-width: 740px) 740px, 100vw"}]},"width":740,"height":368.00000000000006},"body":"---\ntitle: \"程序员Leon\"\ncover: images/wang_blog.jpg\ncoverAlt: \"封面\"\ndescription: \"本站\"\ndatePublished: \"2022-01-30 11:22:01\"\ndateModified: \"2022-01-30 11:22:01\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - React\n  - Node.js\n  - Gatsby\n  - graphQL\n  - PWA\n---\n\n本站！\n\n### 优势\n\n- SEO优化\n  1. 所有的可访问页面在打包后都生成了对应的html文件。做了seo优化，html里的内容就是最终的页面内容。\n\n- 支持PWA特性\n  1. 首次访问通过http加载html，并注册ServiceWorker。后续访问使用sw加载。可离线访问。\n  2. 支持pwa桌面应用安装。\n  3. nprogress展示网页加载进度。\n\n- SPA体验\n  1. 使用Link组件链接的页面，会在当前页面加载完成后，异步加载，以提升跳转时的体验。\n\n### 功能点\n\n1. 支持markdown和MDX。\n\n2. 图片渐进式加载。\n\n3. 支持分类（category）和标签（tag）。\n\n4. 列表页都支持分页加载。\n\n5. 支持模糊搜索。\n\n6. 全部页面都进行了SEO优化。\n\n7. 响应式设计，同时支持pc端和移动端浏览器\n\n### 技术点\n\n1. 使用Gatsby实现的纯静态站点。Node.js + React + styled-components。\n\n2. 数据层通过graphQL和remark插件读取和处理所有markdown和mdx文档。\n\n3. 在Node.js层控制分页json数据查询，在client端通过fetch+react query实现分页加载。\n\n4. 在Node.js层生成每个category、每个tag、每个blog的静态页面。\n\n5. 使用gatsby-plugin-image对图片渲染优化。\n\n6. 使用fusejs、gatsby-plugin-fusejs在Node.js层实现索引，client端通过react-use-fusejs插件进行关键字搜索。\n\n7. 借助[gatsby themes](https://www.gatsbyjs.com/docs/themes/using-multiple-gatsby-themes/)实现功能和UI抽离，并支持主题切换。所有功能在themes/advanced模块下，只包含基础ui。像素主题的ui在themes/pixel模块下。","slug":"/程序员-leon"},{"id":"e087ef7a-f4b5-52a3-b52c-a7847ad51b0f","title":"Webpack是如何处理ESM的","tags":["前端","架构","造轮子"],"category":"经验总结","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDAQX/xAAWAQEBAQAAAAAAAAAAAAAAAAAAAQL/2gAMAwEAAhADEAAAAedaK3LGh//EABkQAAIDAQAAAAAAAAAAAAAAAAABAgMQEv/aAAgBAQABBQIshzjxH//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABgQAAIDAAAAAAAAAAAAAAAAAAABESAh/9oACAEBAAY/AhbNf//EABkQAAMAAwAAAAAAAAAAAAAAAAABMRARIf/aAAgBAQABPyGQau3YSKxB/9oADAMBAAIAAwAAABBYP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EABwQAQADAAIDAAAAAAAAAAAAAAEAESExQXGB0f/aAAgBAQABPxBLCtuNwduVvyKll+iJVsteVawvqc3mf//Z"},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/fff17/webpack-package.jpg","srcSet":"/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/9fa5a/webpack-package.jpg 184w,\n/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/63e75/webpack-package.jpg 368w,\n/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/fff17/webpack-package.jpg 736w,\n/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/da7d9/webpack-package.jpg 1472w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/9d028/webpack-package.avif 184w,\n/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/c6ee4/webpack-package.avif 368w,\n/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/b4627/webpack-package.avif 736w,\n/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/42b07/webpack-package.avif 1472w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/ef27d/webpack-package.webp 184w,\n/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/4ae45/webpack-package.webp 368w,\n/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/20e6b/webpack-package.webp 736w,\n/leon-blog/static/eb777c876db5fcd5b1f3e2bec74894d4/79f02/webpack-package.webp 1472w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"Webpack是如何处理ESM的\"\ncover: ../static/assets/webpack-package.jpg\ncoverAlt: \"封面\"\ndescription: \"介绍一段import和require的代码在webpack中如何被打包\"\ndatePublished: \"2023-02-08 21:52:32\"\ndateModified: \"2023-02-08 21:52:32\"\ncategory: \"经验总结\"\ntags:\n  - 前端\n  - 架构\n  - 造轮子\n---\n\n周所周知，ES6引入了官方的模块化方案`import`和`export`。在此之前，js想要实现模块化开发，需要依赖于非官方方案。\n\n#### 模块化历史\n\n**最早期：IIFE**\n\n最开始为了避免在全局作用域执行代码，开发者使用IIFE将代码封装在函数作用域内。\n\n```javascript\nvar mathToolModule = (function () {\n    var pi = 3.141592653\n    function add (a, b) {\n        return a + b\n    }\n    return {\n        pi: pi,\n        add: add\n    }\n})()\n\nmathToolModule.add(1, 2)\n```\n\n**CommonJs**\n\n比较常用的模块化方案，使用`require`和`module.exports`来导入/导出模块。现今的Node.js仍然使用该模块化标准。\n\n```javascript\n// toolsModule.js\nmodule.exports = {\n    add: function (a, b) {\n        return a + b\n    }\n}\n\n// main.js\nconst mathToolModule = require('./toolsModule.js');\nmathToolModule.add(1, 2)\n```\n\n缺点很明显，因为是同步加载，所以在浏览器上网络差的情况下会比较慢影响性能。而Node服务端因为都在本地所以不影响。\n\n**AMD（Async Module Definition）**\n\n`CommonJs`实现不了异步加载模块，所以出现了AMD标准。`RequireJs`是AMD的一种实现：\n\n```javascript\n// 定义一个mathTools模块\ndefine('mathTools', [], function () {\n    var add = function (a, b) {\n        return a + b;\n    };\n    return {\n        add: add,\n    };\n});\n\n// 引入math作为依赖模块\nrequire(['mathTools'], function (math) {\n    math.add(1, 2)\n})\n```\n\n通过引入依赖数组，并异步加载全部的模块，等待加载完成后再运行内部代码。缺点是依赖数组前置了，所以用或者不用都会加载这些模块。没有按需加载。\n\n**CMD（Common Module Definition））**\n\n阿里巴巴提出的一种前端模块化规范。CMD规范主要用于`Sea.js`模块加载器。特点是按需加载，依赖就近（依赖可以写在代码任意地方，只有使用时才去解析依赖）。\n\n```javascript\n// 定义math模块\ndefine(function (require, exports, module) {\n    exports.add = function (a, b) {\n        return a + b;\n    }\n})\n\n// 使用math模块\ndefine(function (require, exports, module) {\n    var mathTools = require('./math.js');\n    mathTools.add(1, 2)\n})\n```\n\n`require`和`exports`都作为`define`内函数的参数。分别代表自己要使用什么模块，以及导出哪些变量。\n\n**UMD（Universal Module Definition）**\n\nUMD规范的目的是让一个模块能同时在不同环境下运行。不论是浏览器、Node.js还是其他环境。它兼容了AMD、CommonJs以及全局变量。\n\n```javascript\n// mathTools.js\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define([], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // CommonJS\n        module.exports = factory();\n    } else {\n        // 浏览器全局变量\n        root.mathTools = factory();\n    }\n}(this, function () {\n    // 主体代码\n    return {\n        add: function (a, b) {\n            return a + b\n        }\n    }\n}));\n\n// main.js\n(function (root, factory) {\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['mathTools'], factory);\n    } else if (typeof module === 'object' && module.exports) {\n        // CommonJS\n        module.exports = factory(require('mathTools'));\n    } else {\n        // 浏览器全局变量\n        root.myModule = factory(root.mathTools);\n    }\n}(this, function (mathTools) {\n    // 主体代码\n    mathTools.add(1, 2)\n}));\n```\n\n可以看到每个模块的主体代码都在`factory函数`里。模块执行时使用IFFE：判断当前使用哪种模块规范，并把自己导出为当前的模块规范。从而让每个模块都能运行在各种模块规范下。\n\n**ESM（EMCAScript Module）**\n\nES6从语言层面实现了模块化。旨在统一标准。使用`import`导入模块，`export`导出模块。\n\n```javascript\n// mathTools.js\nexport default {\n    add: (a, b) => a + b\n}\n\n// main.js\nimport add from 'mathTools'\n\nadd(1, 2)\n```\n\n并且ESM慢慢成为浏览器的标配。使用`<script type=\"module\">`就可以定义一个脚本使用该模块规范。在node端也支持ESM。通过在package.json里配置`type: \"module\"`或者使用`.mjs`后缀，就可以使用ESM。\n\n#### ESM和CommonJs的模块加载差异\n\nwebpack可以通过配置[output.type](https://www.webpackjs.com/configuration/output/#outputlibrarytype)将代码打包成各种模块规范的格式，我们可以根据库的目标运行环境来更改模块类型。如果要兼容，可以选`umd`格式。\n\n本次主要对比一下ESM和CJS的模块加载机制的不同。\n\n- esm是静态加载的，即`import`语句是在编译时静态解析和优化的。而commonjs是动态加载的，`require`语句在运行代码时解析。（所以`import`语句只能写在（top-leve）顶层作用域，不可在{}块级作用域中。而`require`无限制）。\n\n- 浏览器中，esm是异步加载的。而commonjs是同步加载的。\n\n- esm模块导出的是引用，而commonjs导出的是副本。[看下面](#其他)\n\n**ESM在浏览器中是如何加载的**\n\n定义了`type=\"module\"`的js脚本中可以直接使用esm语法。\n\nesm脚本的加载是异步的。也就是说下面的代码是等同的：\n\n```html\n<script type=\"module\" src=\"./index.js\"></script>\n<script type=\"module\" src=\"./index.js\" defer></script>\n```\n\n*BTW：`defer`属性的脚本会在html解析完成后执行并且保证defer脚本的执行顺序。而`async`脚本会在该脚本下载完成后立即执行，执行顺序不保证，执行时间也不保证。所以`async`适合与dom无关，独立运行的脚本。而`defer`适合不需要阻塞html解析的异步脚本。*\n\n*执行顺序：html开始解析 => 同步script按顺序执行 => html解析完成 => defer脚本按顺序执行 => DOMContentLoaded事件 => 其他资源加载（link外部样式表，img的图片资源） => 全部完成触发onload事件*\n\nesm是编译时静态分析的，虽然在浏览器中使用esm没有了编译阶段。但静态分析仍然存在。浏览器加载esm的步骤：\n\n1. 入口：从`<script type=\"module\">`标签的模块入口，开始解析和加载。\n\n2. 预解析模块：在执行代码之前，浏览器先预解析模块文本，确定模块依赖关系，形成模块关系图。\n\n3. 加载模块：并行加载和实例化模块，确定导出对象。*（在此过程，浏览器可以做一些优化，比如tree shaking掉未使用的导出）*。\n\n4. 执行模块代码：到这里开始，按照深度优先顺序，执行模块的代码（最深的模块最先执行）。并且每个模块的代码只会执行一次（防止循环依赖）。\n\n比如以下情况：\n\n```javascript\n// index.js\nconsole.log(\"1\");\nimport \"./esm-a.js\";\nconsole.log(\"2\");\nimport \"./esm-b.js\";\nconsole.log(\"3\");\n\n// esm-a.js\nconsole.log(\"a\");\nexport default {}\n\n// esm-b.js\nconsole.log(\"b\");\nexport default {}\n```\n\n输出的结果为：a => b => 1 => 2 => 3\n\n如果在`esm-a.js`内部加上`import \"./esm-b.js\"`，那输出的结果就变为：b => a => 1 => 2 => 3\n\n> 详细参考：https://tech.taobao.org/news/go81zn\n\n同比之下，commonjs因为是同步执行的，加载机制就简单很多。还是上面的例子，改为commonjs：\n\n```javascript\n// index.js\nconsole.log(\"1\");\nrequire(\"./esm-a.js\");\nconsole.log(\"2\");\nrequire(\"./esm-b.js\");\nconsole.log(\"3\");\n```\n\n输出结果为：1 => a => 2 => b => 3\n\n同时，esm也支持动态导入模块，使用`import()`函数，可以在任意位置调用，无需top-level。比如`import(\"./esm-a.js\")`会返回一个Promise，在Promise里可以获取到模块导出的内容。动态导入的模块只在调用`import()`函数时，才被解析、加载和执行。\n\n```javascript\n// index.js\nconsole.log(\"1\");\nimport(\"./esm-a.js\")\nconsole.log(\"2\");\nimport(\"./esm-b.js\")\nconsole.log(\"3\");\n```\n\n输出结果为：1 => 2 => 3 => a => b\n\n**Node端处理ESM**\n\nNode端解析和执行ESM的逻辑和顺序，和浏览器端如出一辙。无非是Node支持通过裸模块名加载本地模块。比如`import fs from 'fs'`。它会通过不断往上查找`node_modules`目录来加载对应模块。\n\n#### Webpack上编译ESM和CommonJs\n\n前面所讲的都是浏览器或Node对ESM模块的原生支持，而我们常常会使用Webpack这样的打包工具，对前端应用进行构建打包。而Webpac目前对ESM支持还有限，它在构建ESM时，并不会保留ESM，而是转译成另一种实现。最后通过`webpack.config.js`设置`library.type`来生成最终的输出格式。\n\n```javascript\n// webpack.config.js\nmodule.exports = {\n  entry: \"./index.js\",\n  output: {\n    filename: \"bundle.js\",\n    path: path.resolve(__dirname, \"dist\"),\n    globalObject: \"this\",\n    library: {\n      type: \"umd\", // 配置模块输出格式为umd\n    },\n  },\n}\n```\n\n我们看一下Webpack在development模式下是如何实现esm模块的。*（production模式下看不出来，因为做了代码压缩、treeshaking、模块合并等）。*拿下面的例子来看esm静态导入和动态导入模块，webpack编译后是什么样子：\n\n```javascript\n// ========== index.js - 编译前\nconsole.log(\"1\");\n{\n    import(\"./esm-a.js\").then(() => {\n        console.log(\"esm-a loaded\");\n    })\n}\nconsole.log(\"2\");\nimport \"./esm-b.js\"\nconsole.log(\"3\");\n\n// ========== index.js - 编译后\n__webpack_require__.r(__webpack_exports__);\nvar _esm_b_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(\"./esm-b.js\");\nconsole.log(\"1\");\n{\n    __webpack_require__.e(\"esm-a_js\").then(__webpack_require__.bind(__webpack_require__, \"./esm-a.js\")).then(() => {\n        console.log(\"esm-a loaded\");\n    })\n}\nconsole.log(\"2\");\nconsole.log(\"3\");\n```\n\n可以看到静态import的模块，被提到了代码顶部，并通过`__webpack_require__()`函数加载模块。动态import()的模块还在原来的位置，通过`__webpack_require__.e`Promise化后再加载对应模块，并在模块加载后执行回调函数。\n\nwebpack处理CommonJs的就比较简单了。直接使用`__webpack_require__()`加载模块即可。\n\n```javascript\n// ========== index.js - 编译前\nconsole.log(\"1\");\nrequire(\"./esm-b.js\");\nconsole.log(\"2\");\n\n// ========== index.js - 编译后\nconsole.log(\"1\");\n__webpack_require__(\"./esm-b.js\");\nconsole.log(\"2\");\n```\n\n**__webpack_require__**\n\n也顺便看看webpack的`__webpack_require__()`方法做了什么。\n\n```javascript\n// __webpack_modules__是一个对象。\nvar __webpack_modules__ = ({\n    \"./esm-b.js\": ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n        eval(/** code省略 */);\n    }),\n\n    \"./index.js\": ((__unused_webpack_module, __unused_webpack_exports, __webpack_require__) => {\n        eval(\"console.log(\\\"1\\\");\\n__webpack_require__(/*! ./esm-b.js */ \\\"./esm-b.js\\\");\\nconsole.log(\\\"2\\\");\\n\\n//# sourceURL=webpack://esm/./index.js?\");\n    })\n});\n\n// 模块缓存\nvar __webpack_module_cache__ = {};\n\n// require函数实现，用来加载模块\nfunction __webpack_require__(moduleId) {\n  var cachedModule = __webpack_module_cache__[moduleId]\n  if (cachedModule !== undefined) {\n    return cachedModule.exports\n  }\n\n  var module = __webpack_module_cache__[moduleId] = {exports: {}}\n\n  __webpack_modules__[moduleId](module, module.exports, __webpack_require__)\n\n  return module.exports\n}\n\n// 执行导入入口文件\n__webpack_require__(\"./index.js\");\n```\n\n可以看到，`__webpack_modules__`用来存储所有的模块（不包含异步模块）。以模块路径为key，值为对应模块的工厂函数。\n\n`__webpack_require__`函数用来加载模块。它会首先检查缓存，如果有缓存就直接返回缓存。否则调用`__webpack_modules__`中对应模块的工厂函数。\n\n工厂函数内，直接`eval`执行了编译后的模块代码。模块代码的作用域限定在函数内，工厂函数提供的三个参数即模块代码的执行上下文。执行模块代码时：使用`__webpack_require__`导入其他模块。导出内容输出到`__webpack_exports__`上。\n\n最后执行入口文件的require。从而形成了整个闭环。\n\n#### 其他\n\n1. ESM的特性之一就是导出的是引用，假如值被某模块修改了，其他模块获取的仍是最新值。ESM官方实现应该是导出的变量是引用，都是指向同一块内存地址。Webpack在实现这个特性时，是通过`Object.definedProperty`设置get()函数。原始值始终是在原模块内，其他模块通过get()取到的始终是原模块内的值。\n\n    ```javascript\n    // esm-b.js - 编译前\n    export var a = 1\n    export function setA() {\n        a++\n    }\n\n    // esm-b.js - 编译后并展开__webpack_require__.d\n    Object.defineProperty(__webpack_exports__, 'a', {\n        get: () => (a),\n    });\n    Object.defineProperty(__webpack_exports__, 'setA', {\n        get: () => (setA)\n    });\n\n    var a = 1\n    function setA() {\n        a++\n    }\n    ```\n\n2. 对于动态加载的模块，前面我们看到了是通过`__webpack_require__.e`处理的。简单说一下：\n\n    - 动态模块会被单独提到一个chunk中，生成对应的bundle.js。动态模块不会出现在初始的`__webpack_modules__`里。\n\n    - 生成的bundle.js里，会把自己执行代码和模块id都push到`chunkLoadingGlobal`里\n\n    - `__webpack_require__.e`会执行一系列promise。\n    \n    - 加载的promise函数内，会通过script标签加载bundle.js。\n\n    - 加载成功后会执行`webpackJsonpCallback`函数，将该模块的id和添加到`__webpack_modules__`上。\n\n    - promise执行下一步。调用`__webpack_require__`执行模块代码。\n\n    > 详细参考https://blog.csdn.net/letterTiger/article/details/136977101","slug":"/webpack是如何处理-esm的"},{"id":"101cbf0e-c9ca-556e-a54c-19d7273a1e3a","title":"优优小班课公众号","tags":["前端","Vue2","Vant","公众号"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAIDBf/EABYBAQEBAAAAAAAAAAAAAAAAAAEDBP/aAAwDAQACEAMQAAAB10oYKTHB/8QAFhAAAwAAAAAAAAAAAAAAAAAAACAh/9oACAEBAAEFAir/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABYQAAMAAAAAAAAAAAAAAAAAAAAgQf/aAAgBAQAGPwIi/wD/xAAaEAACAgMAAAAAAAAAAAAAAAAAAREgITFx/9oACAEBAAE/IWb5cODp/9oADAMBAAIAAwAAABDP/wD/xAAVEQEBAAAAAAAAAAAAAAAAAAAAEf/aAAgBAwEBPxBX/8QAFREBAQAAAAAAAAAAAAAAAAAAABH/2gAIAQIBAT8QR//EABoQAAIDAQEAAAAAAAAAAAAAAAERACFhEDH/2gAIAQEAAT8Q8UQ9iRoInALrpE//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/fff17/public_cover.jpg","srcSet":"/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/9fa5a/public_cover.jpg 184w,\n/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/63e75/public_cover.jpg 368w,\n/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/fff17/public_cover.jpg 736w","sizes":"(min-width: 736px) 736px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/9d028/public_cover.avif 184w,\n/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/c6ee4/public_cover.avif 368w,\n/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/b4627/public_cover.avif 736w","type":"image/avif","sizes":"(min-width: 736px) 736px, 100vw"},{"srcSet":"/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/ef27d/public_cover.webp 184w,\n/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/4ae45/public_cover.webp 368w,\n/leon-blog/static/822b68624be567da7ce38cbfcb473eb7/20e6b/public_cover.webp 736w","type":"image/webp","sizes":"(min-width: 736px) 736px, 100vw"}]},"width":736,"height":368},"body":"---\ntitle: \"优优小班课公众号\"\ncover: banma/public_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"优优小班课-微信公众号项目\"\ndatePublished: \"2019-10-28 13:49:02\"\ndateModified: \"2019-10-28 13:49:02\"\ncategory: \"应用项目\"\ntags:\n  - 前端\n  - Vue2\n  - Vant\n  - 公众号\n---\n\n优优小班课-微信公众号，用于学生/家长微信内直接购课，参与团购，查看购课订单，分享。\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n1. 微信直接登录。\n\n2. 在线购课（课时包、秒杀），支持微信支付、支付宝支付、支付宝分期、花呗支付等。\n\n3. 查看购物车。\n\n4. 查看购课订单。\n\n5. 参与和发起团购。\n\n6. 学前测评。\n\n7. 查看课程日历。\n\n8. 微信分享活动信息。\n\n### 我的职责\n\n1. 负责公众号一期功能开发。\n\n2. 参与公众号项目维护。\n\n3. 开发人员团队管理。\n\n### 技术实现\n\n1. 基于vue2、vant框架开发。\n\n2. 接入微信jssdk实现登录、分享等微信能力。\n\n3. 打包为静态资源，发布oss，配置二级域名。处理缓存问题。\n\n### 截图\n\n![](./banma/public_login.jpg)\n![](./banma/public_goods.jpg)\n![](./banma/public_tuangou.jpg)","slug":"/优优小班课公众号"},{"id":"a6718bfc-fac0-5d6e-80d0-bc8cc3cd2183","title":"优优小班-AI信令sdk","tags":["跨平台","Flutter","dart","库","架构"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwABAQEBAAAAAAAAAAAAAAAAAAMCBP/EABUBAQEAAAAAAAAAAAAAAAAAAAEC/9oADAMBAAIQAxAAAAHjvCkybD//xAAbEAABBAMAAAAAAAAAAAAAAAABAAIDMhARQf/aAAgBAQABBQLuzIhiO7r/AP/EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABURAQEAAAAAAAAAAAAAAAAAAAEQ/9oACAECAQE/AWf/xAAaEAACAgMAAAAAAAAAAAAAAAAAAQIQESFx/9oACAEBAAY/AjG3aJdP/8QAGhABAAMAAwAAAAAAAAAAAAAAAQARMRBBYf/aAAgBAQABPyF1FYVOrAgqz2OvID//2gAMAwEAAgADAAAAEOg//8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERMf/aAAgBAwEBPxBbCQ//xAAXEQEBAQEAAAAAAAAAAAAAAAABEQAx/9oACAECAQE/EOKYaXf/xAAaEAEAAwEBAQAAAAAAAAAAAAABABEhMZGh/9oACAEBAAE/EKacvYb16ADydMNUs4z7Ge9qEDMBAT//2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/1c8778720ca8941d9864cabf000093c0/1a18e/aisdk_cover.jpg","srcSet":"/leon-blog/static/1c8778720ca8941d9864cabf000093c0/38847/aisdk_cover.jpg 185w,\n/leon-blog/static/1c8778720ca8941d9864cabf000093c0/0b64e/aisdk_cover.jpg 369w,\n/leon-blog/static/1c8778720ca8941d9864cabf000093c0/1a18e/aisdk_cover.jpg 738w","sizes":"(min-width: 738px) 738px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/1c8778720ca8941d9864cabf000093c0/e48a9/aisdk_cover.avif 185w,\n/leon-blog/static/1c8778720ca8941d9864cabf000093c0/6964f/aisdk_cover.avif 369w,\n/leon-blog/static/1c8778720ca8941d9864cabf000093c0/09253/aisdk_cover.avif 738w","type":"image/avif","sizes":"(min-width: 738px) 738px, 100vw"},{"srcSet":"/leon-blog/static/1c8778720ca8941d9864cabf000093c0/3edfa/aisdk_cover.webp 185w,\n/leon-blog/static/1c8778720ca8941d9864cabf000093c0/696e0/aisdk_cover.webp 369w,\n/leon-blog/static/1c8778720ca8941d9864cabf000093c0/b1703/aisdk_cover.webp 738w","type":"image/webp","sizes":"(min-width: 738px) 738px, 100vw"}]},"width":738,"height":368},"body":"---\ntitle: \"优优小班-AI信令sdk\"\ncover: banma/aisdk_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"优优小班AI课信令驱动sdk\"\ndatePublished: \"2020-03-27 20:05:31\"\ndateModified: \"2020-03-27 20:05:31\"\ncategory: \"应用项目\"\ntags:\n  - 跨平台\n  - Flutter\n  - dart\n  - 库\n  - 架构\n---\n\n类直播课的AI课形式，收集到素材课（直播课）的全部信令。通过本AI信令sdk，驱动信令的执行，来演绎回放AI课。\n\n### 为什么需要？\n\n一期的AI课走的是server端回放模式，AI课堂上的信令都是从服务端通过websocket按时发送过来。对于网络条件良好的学生来说，误差不会太大，延迟不会太高。但是大部分二三线城市的学生网络状况较差，并且由于信令内容较大，导致延迟很高，课堂效果差。\n\n### 调研\n\n调研了多种实现方式：\n\n1. 原生开发：信令sdk实现很复杂，原生开发逻辑一致性无法保证。测试压力也很大。\n\n2. h5版sdk：统一逻辑，在两端的webview加载h5版sdk，通过js接口通信。问题：性能较差、通信成本高。\n\n3. flutter版sdk：统一逻辑，使用Flutter引擎加载，性能好，双向通信速度很快，通信方法很多。Android上可以通过曲线方式实现热更新。\n\n### 主要功能\n\n1. 解析信令文件内容，根据时间戳，设置timer按顺序按时间点发送信令到app端，控制课堂进程。\n\n2. 初始化时，根据一定时间间隔生成信令快照，便于后续seek时，快速恢复信令现场。\n\n3. seek时，考虑使用快照或者不使用快照，并合并最终信令发送到app端。\n\n4. 提供接口供app端调用。\n\n![信令sdk流程图](./banma/yyxb_aisdk.jpg)\n\n### 技术点\n\nAI信令sdk，作为一个纯dart语言开发的库，打包成动态库，集成到Android端和iOS端，app端使用FlutterEngine去加载。\n\napp端使用MethodChannel与flutter通信。\n\n课堂seek（跳时间点）时，for循环信令列表计算最终信令数组。\n\n使用快照技术，提升课堂seek后的计算速度，减少计算。\n","slug":"/优优小班-a-i信令sdk"},{"id":"9976aabd-01b1-53fb-9243-5949d1a5ce74","title":"优优小班","tags":["Android端","Java","iOS端","组件化","Hybrid"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAGAAAAwEBAAAAAAAAAAAAAAAAAAIDBAX/xAAVAQEBAAAAAAAAAAAAAAAAAAABAv/aAAwDAQACEAMQAAAB666Yw1GE/8QAGhAAAgIDAAAAAAAAAAAAAAAAAAECEhMxQf/aAAgBAQABBQKTo8gtM6f/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAWEQEBAQAAAAAAAAAAAAAAAAAAESH/2gAIAQIBAT8Bmo//xAAXEAEAAwAAAAAAAAAAAAAAAAABACAx/9oACAEBAAY/AhZlf//EABwQAAICAgMAAAAAAAAAAAAAAAABETEhQXGhwf/aAAgBAQABPyFVIeKJdyTRvBryeGKj/9oADAMBAAIAAwAAABCUP//EABYRAQEBAAAAAAAAAAAAAAAAAAEAEf/aAAgBAwEBPxAdG1v/xAAWEQEBAQAAAAAAAAAAAAAAAAABABH/2gAIAQIBAT8QQAs3/8QAGxABAQEAAgMAAAAAAAAAAAAAAREAITFBUXH/2gAIAQEAAT8QlQPwKa+b60RVSIbxR6uABSVL1gJQMDzgIYXHR83/2Q=="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/a5027/yyxb_cover.jpg","srcSet":"/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/9fa5a/yyxb_cover.jpg 184w,\n/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/0b64e/yyxb_cover.jpg 369w,\n/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/a5027/yyxb_cover.jpg 737w","sizes":"(min-width: 737px) 737px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/9d028/yyxb_cover.avif 184w,\n/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/6964f/yyxb_cover.avif 369w,\n/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/a4fd3/yyxb_cover.avif 737w","type":"image/avif","sizes":"(min-width: 737px) 737px, 100vw"},{"srcSet":"/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/ef27d/yyxb_cover.webp 184w,\n/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/696e0/yyxb_cover.webp 369w,\n/leon-blog/static/3e772f9aae75eb2185fa902d331167b2/abd43/yyxb_cover.webp 737w","type":"image/webp","sizes":"(min-width: 737px) 737px, 100vw"}]},"width":737,"height":368},"body":"---\ntitle: \"优优小班\"\ncover: banma/yyxb_cover.jpg\ncoverAlt: \"封面\"\ndescription: \"K12教育AI课产品\"\ndatePublished: \"2020-03-01 21:39:10\"\ndateModified: \"2020-03-01 21:39:10\"\ncategory: \"应用项目\"\ntags:\n  - Android端\n  - Java\n  - iOS端\n  - 组件化\n  - Hybrid\n---\n\n优优小班课是K12教育领域类直播形式的AI课产品。\n\n> 市面上的AI课，都是提前录好素材，在APP端进行拼接，课程中夹杂互动的形式。<br/>优优小班课的类直播形式是使用真实[袋鼠小班](/袋鼠小班)直播课的素材，在AI课上回放该直播课，替换掉主演，让上AI课的该学生有一种身临其境在上直播课的体验，有同学伴读的感觉。教学效果大大提升。\n\n学生端为上课端，包含登录、课表、AI课堂、课后练习等。支持Android、iphone、ipad。\n\n---\n\n### 导航\n\n- [主要功能](#主要功能)\n- [我的职责](#我的职责)\n- [技术实现](#技术实现)\n- [截图](#截图)\n\n### 主要功能\n\n1. 学生登录进入主界面，查看自己的课程表。\n\n2. 到点进入课堂上课。课堂为AI课形式，从学生进入时间点开始播放AI课程。\n\n3. 学生中途退出，AI课时间仍然会流逝，重进后从流逝后的时间点继续播放课堂。\n\n4. AI课完全还原直播课堂的体验。\n\n### 我的职责\n\n1. 主导技术项目的开发，包括Android优优小班课、[课件容器](/优优小班-课件容器)、[AI信令sdk](/优优小班-a-i信令sdk)、iOS的技术跟进等。\n\n2. 主导重难点技术方案的设计：\n\n    - 课件容器架构设计和研发。\n    - 稳定性相关：课堂关键状态上报、日志sdk、实时监课和远程控制（查看学生视频流、刷新学生课堂白板、刷新课堂等）。\n    - AI信令sdk架构设计和研发。\n    - AI课堂恢复算法设计和研发。\n    - 题库设计。包括管理后台出题、学生端渲染题目、十几种题目类型支持、题目判对判错交互。\n    - 答题课件设计，比答题器交互更沉浸。\n    - 等等。\n\n3. 多端通信协议及规范设计。\n\n4. 稳定性持续跟进和优化。\n\n5. 大前端开发团队管理。\n\n6. 项目管理。\n\n### 技术实现\n\n1. Android端基于Java、MessUi、Retrofit等。\n\n2. 与h5的通信基于AppSocket。\n\n3. 与Flutter sdk的通信基于MethodChannel。\n\n4. 学生推送音视频流，基于zego sdk。\n\n5. 实现了组件化开发，各个业务module可独立运行、开发、测试。\n\n6. **【corelib】**module包含：业务无关的基础依赖、基础UI框架、事件总线RxBus、基础请求框架、常用弹窗、常用工具类。\n\n7. **【rcmpt】**module包含：业务相关的基础依赖、BaseActivity/BaseFragment、页面路由定义、业务请求封装、基础控件、一些常量。\n\n8. **【app】**module包含：Application基类，启动页。（仅作为app壳子）。\n\n9. **【BmLogSdk】**module包含：日志sdk导出的aar。\n\n10. **【ClassRoomSdk】**module包含：白板部分和课件容器。\n\n11. **【eduhdsdk】**module包含：课堂页面及对应的组件。\n\n12. 其他业务模块：如classtable、mine等，各个模块包含自己独立的业务代码。这部分代码包含：\n\n    - 页面，activity/fragment/view\n    - bean model\n    - 接口类\n    - 业务资源\n\n### 截图\n\n<video src=\"./banma/xb_class.mp4\" autoplay muted controls />\n\n![](./banma/xb_class_m.jpg)","slug":"/优优小班"},{"id":"62d3add4-4517-54c3-84cc-ab9ee5651a42","title":"优优小班-AI标注平台","tags":["Android端","后端","Node.js","Express","脚本","前端","Vue2"],"category":"应用项目","coverImg":{"layout":"constrained","placeholder":{"fallback":"data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAKABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEAv/EABUBAQEAAAAAAAAAAAAAAAAAAAEA/9oADAMBAAIQAxAAAAGvU7BcJI//xAAZEAEBAQADAAAAAAAAAAAAAAABEQIhMUH/2gAIAQEAAQUCJPMdKzDxlZ//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/AT//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/AT//xAAaEAADAAMBAAAAAAAAAAAAAAAAASEQMUHw/9oACAEBAAY/Al0u8K+gxU//xAAdEAACAgIDAQAAAAAAAAAAAAABMQARYZEhQVHB/9oACAEBAAE/IWFaYlgCKHhaxPGtDyNDcGYWPkaiHeJ//9oADAMBAAIAAwAAABAQ/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAACAgMAAwAAAAAAAAAAAAABEQAhMUFRYXGh/9oACAEBAAE/EDNoBAdWOLiEjIBs93iKLNbFlMwUACGKbsGv9x4n6ZnE/9k="},"backgroundColor":"transparent","images":{"fallback":{"src":"/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/a5027/aitag.jpg","srcSet":"/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/9fa5a/aitag.jpg 184w,\n/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/0b64e/aitag.jpg 369w,\n/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/a5027/aitag.jpg 737w","sizes":"(min-width: 737px) 737px, 100vw"},"sources":[{"srcSet":"/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/9d028/aitag.avif 184w,\n/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/6964f/aitag.avif 369w,\n/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/a4fd3/aitag.avif 737w","type":"image/avif","sizes":"(min-width: 737px) 737px, 100vw"},{"srcSet":"/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/ef27d/aitag.webp 184w,\n/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/696e0/aitag.webp 369w,\n/leon-blog/static/90be46c143f793d2db59bde3f2905ca9/abd43/aitag.webp 737w","type":"image/webp","sizes":"(min-width: 737px) 737px, 100vw"}]},"width":737,"height":368},"body":"---\ntitle: \"优优小班-AI标注平台\"\ncover: banma/aitag.jpg\ncoverAlt: \"封面\"\ndescription: \"用于老师、学生音视频标注\"\ndatePublished: \"2020-06-12 23:10:09\"\ndateModified: \"2020-06-12 23:10:09\"\ncategory: \"应用项目\"\ntags:\n  - Android端\n  - 后端\n  - Node.js\n  - Express\n  - 脚本\n  - 前端\n  - Vue2\n---\n\nAI标注平台用于标注人员对老师和学生音频转文字标注、学生图像在框识别标注。\n\n标注平台及配套设施包括：\n\n#### AI标注平台web端\n\n标注平台web端，用于标注人员在线上直接标注和查看标注结果。支持老师和学生音频转文字标注，支持学生图像在框识别标注。\n\n交互形式为类似windows文件夹的交互，图片以文件夹形式网格展示，支持多选框选，ctrl点选操作。（方便标注人员像操作文件夹一样在线操作）\n\n#### AI标注Android端\n\n用于手机端对百度语音识别结果进行人工标注。支持查看待标注内容、修改识别结果。\n\n#### AI标注平台server端\n\nserver端基于Node.js、Express框架开发。主要为web端和Android端提供接口。\n\n无数据库，所有数据从oss获取，并转存oss。以目录作为资源分隔方式。\n\n#### 标注资源获取脚本\n\n该脚本旨在生成标注源数据。通过音视频云服务商提供的接口，批量获取某一天上课的所有课程、所有音视频流的webm下载地址，然后下载资源、分割、转存oss。","slug":"/优优小班-ai标注平台"}]}}}